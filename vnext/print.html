<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rhai - Embedded Scripting for Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Tutorial and reference on the Rhai scripting engine and language.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about/index.html">What is Rhai</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/features.html">Features</a></li><li class="chapter-item expanded "><a href="about/targets.html">Supported Targets and Builds</a></li><li class="chapter-item expanded "><a href="about/non-design.html">What Rhai Isn't</a></li><li class="chapter-item expanded "><a href="about/license.html">Licensing</a></li><li class="chapter-item expanded "><a href="about/related.html">Related Resources</a></li></ol></li><li class="chapter-item expanded "><a href="start/index.html">Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/playground.html">Online Playground</a></li><li class="chapter-item expanded "><a href="start/install.html">Install the Rhai Crate</a></li><li class="chapter-item expanded "><a href="start/features.html">Optional Features</a></li><li class="chapter-item expanded "><a href="start/builds/index.html">Special Builds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/builds/performance.html">Performance</a></li><li class="chapter-item expanded "><a href="start/builds/minimal.html">Minimal</a></li><li class="chapter-item expanded "><a href="start/builds/no-std.html">no-std</a></li><li class="chapter-item expanded "><a href="start/builds/wasm.html">WebAssembly (WASM)</a></li></ol></li><li class="chapter-item expanded "><a href="start/bin.html">Packaged Utilities</a></li><li class="chapter-item expanded "><a href="start/examples/index.html">Examples</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/examples/rust.html">Rust</a></li><li class="chapter-item expanded "><a href="start/examples/scripts.html">Scripts</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="engine/index.html">Using the Engine</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/hello-world.html">Hello World in Rhai – Evaluate a Script</a></li><li class="chapter-item expanded "><a href="engine/compile.html">Compile to AST for Repeated Evaluations</a></li><li class="chapter-item expanded "><a href="engine/call-fn.html">Call a Rhai Function from Rust</a></li><li class="chapter-item expanded "><a href="engine/func.html">Create a Rust Closure from a Rhai Function</a></li><li class="chapter-item expanded "><a href="engine/expressions.html">Evaluate Expressions Only</a></li><li class="chapter-item expanded "><a href="engine/raw.html">Raw Engine</a></li><li class="chapter-item expanded "><a href="engine/scope.html">Scope – Initializing and Maintaining State</a></li><li class="chapter-item expanded "><a href="engine/options.html">Engine Configuration Options</a></li></ol></li><li class="chapter-item expanded "><a href="rust/index.html">Extend Rhai with Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/traits.html">Traits</a></li><li class="chapter-item expanded "><a href="rust/functions.html">Register a Rust Function</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/strings.html">String Parameters in Rust Functions</a></li></ol></li><li class="chapter-item expanded "><a href="rust/generic.html">Register a Generic Rust Function</a></li><li class="chapter-item expanded "><a href="rust/fallible.html">Register a Fallible Rust Function</a></li><li class="chapter-item expanded "><a href="rust/override.html">Override a Built-in Function</a></li><li class="chapter-item expanded "><a href="rust/operators.html">Operator Overloading</a></li><li class="chapter-item expanded "><a href="rust/custom.html">Register any Rust Type and its Methods</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/getters-setters.html">Property Getters and Setters</a></li><li class="chapter-item expanded "><a href="rust/indexers.html">Indexers</a></li><li class="chapter-item expanded "><a href="rust/disable-custom.html">Disable Custom Types</a></li><li class="chapter-item expanded "><a href="rust/print-custom.html">Printing Custom Types</a></li></ol></li><li class="chapter-item expanded "><a href="rust/modules/index.html">Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/modules/create.html">Create from Rust</a></li><li class="chapter-item expanded "><a href="rust/modules/ast.html">Create from AST</a></li><li class="chapter-item expanded "><a href="rust/modules/resolvers.html">Module Resolvers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/modules/imp-resolver.html">Custom Module Resolvers</a></li></ol></li><li class="chapter-item expanded "><a href="rust/modules/self-contained.html">Self-Contained AST</a></li></ol></li><li class="chapter-item expanded "><a href="plugins/index.html">Plugins</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugins/module.html">Export a Rust Module</a></li><li class="chapter-item expanded "><a href="plugins/function.html">Export a Rust Function</a></li></ol></li><li class="chapter-item expanded "><a href="rust/packages/index.html">Packages</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rust/packages/builtin.html">Built-in Packages</a></li><li class="chapter-item expanded "><a href="rust/packages/create.html">Custom Packages</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="language/index.html">Rhai Language Reference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/comments.html">Comments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/doc-comments.html">Doc-Comments</a></li></ol></li><li class="chapter-item expanded "><a href="language/values-and-types.html">Values and Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/dynamic.html">Dynamic Values</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/type-of.html">type_of()</a></li><li class="chapter-item expanded "><a href="rust/serde.html">Serialization/Deserialization with serde</a></li></ol></li><li class="chapter-item expanded "><a href="language/numbers.html">Numbers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/num-op.html">Operators</a></li><li class="chapter-item expanded "><a href="language/num-fn.html">Functions</a></li><li class="chapter-item expanded "><a href="language/convert.html">Value Conversions</a></li></ol></li><li class="chapter-item expanded "><a href="language/strings-chars.html">Strings and Characters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/string-fn.html">Built-in Functions</a></li></ol></li><li class="chapter-item expanded "><a href="language/arrays.html">Arrays</a></li><li class="chapter-item expanded "><a href="language/object-maps.html">Object Maps</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/json.html">Parse from JSON</a></li><li class="chapter-item expanded "><a href="language/object-maps-oop.html">Special Support for OOP</a></li></ol></li><li class="chapter-item expanded "><a href="language/timestamps.html">Time-Stamps</a></li></ol></li><li class="chapter-item expanded "><a href="language/keywords.html">Keywords</a></li><li class="chapter-item expanded "><a href="language/statements.html">Statements</a></li><li class="chapter-item expanded "><a href="language/variables.html">Variables</a></li><li class="chapter-item expanded "><a href="language/constants.html">Constants</a></li><li class="chapter-item expanded "><a href="language/logic.html">Logic Operators</a></li><li class="chapter-item expanded "><a href="language/assignment-op.html">Assignment Operators</a></li><li class="chapter-item expanded "><a href="language/if.html">If Statement</a></li><li class="chapter-item expanded "><a href="language/switch.html">Switch Expression</a></li><li class="chapter-item expanded "><a href="language/while.html">While Loop</a></li><li class="chapter-item expanded "><a href="language/do.html">Do Loop</a></li><li class="chapter-item expanded "><a href="language/loop.html">Loop Statement</a></li><li class="chapter-item expanded "><a href="language/for.html">For Loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/iterator.html">Iterators for Custom Types</a></li></ol></li><li class="chapter-item expanded "><a href="language/return.html">Return Values</a></li><li class="chapter-item expanded "><a href="language/throw.html">Throw Exception on Error</a></li><li class="chapter-item expanded "><a href="language/try-catch.html">Catch Exceptions</a></li><li class="chapter-item expanded "><a href="language/functions.html">Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/method.html">Call Method as Function</a></li><li class="chapter-item expanded "><a href="language/overload.html">Overloading</a></li><li class="chapter-item expanded "><a href="language/fn-namespaces.html">Namespaces</a></li><li class="chapter-item expanded "><a href="language/fn-ptr.html">Function Pointers</a></li><li class="chapter-item expanded "><a href="language/fn-curry.html">Currying</a></li><li class="chapter-item expanded "><a href="language/fn-anon.html">Anonymous Functions</a></li><li class="chapter-item expanded "><a href="language/fn-closure.html">Closures</a></li></ol></li><li class="chapter-item expanded "><a href="language/print-debug.html">Print and Debug</a></li><li class="chapter-item expanded "><a href="language/modules/index.html">Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/modules/export.html">Export Variables, Functions and Sub-Modules</a></li><li class="chapter-item expanded "><a href="language/modules/import.html">Import Modules</a></li></ol></li><li class="chapter-item expanded "><a href="language/eval.html">Eval Function</a></li></ol></li><li class="chapter-item expanded "><a href="safety/index.html">Safety and Protection</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety/checked.html">Checked Arithmetic</a></li><li class="chapter-item expanded "><a href="safety/sandbox.html">Sand-Boxing</a></li><li class="chapter-item expanded "><a href="safety/max-string-size.html">Maximum Length of Strings</a></li><li class="chapter-item expanded "><a href="safety/max-array-size.html">Maximum Size of Arrays</a></li><li class="chapter-item expanded "><a href="safety/max-map-size.html">Maximum Size of Object Maps</a></li><li class="chapter-item expanded "><a href="safety/max-operations.html">Maximum Number of Operations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="safety/progress.html">Tracking Progress and Force-Termination</a></li></ol></li><li class="chapter-item expanded "><a href="safety/max-modules.html">Maximum Number of Modules</a></li><li class="chapter-item expanded "><a href="safety/max-call-stack.html">Maximum Call Stack Depth</a></li><li class="chapter-item expanded "><a href="safety/max-stmt-depth.html">Maximum Statement Depth</a></li></ol></li><li class="chapter-item expanded "><a href="engine/optimize/index.html">Script Optimization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/optimize/optimize-levels.html">Optimization Levels</a></li><li class="chapter-item expanded "><a href="engine/optimize/reoptimize.html">Re-Optimize an AST</a></li><li class="chapter-item expanded "><a href="engine/optimize/eager.html">Eager Function Evaluation</a></li><li class="chapter-item expanded "><a href="engine/optimize/side-effects.html">Side-Effect Considerations</a></li><li class="chapter-item expanded "><a href="engine/optimize/volatility.html">Volatility Considerations</a></li><li class="chapter-item expanded "><a href="engine/optimize/semantics.html">Subtle Semantic Changes</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html">Usage Patterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/oop.html">Object-Oriented Programming (OOP)</a></li><li class="chapter-item expanded "><a href="patterns/enums.html">Working With Rust Enums</a></li><li class="chapter-item expanded "><a href="patterns/config.html">Loadable Configuration</a></li><li class="chapter-item expanded "><a href="patterns/control.html">Control Layer</a></li><li class="chapter-item expanded "><a href="patterns/singleton.html">Singleton Command</a></li><li class="chapter-item expanded "><a href="patterns/multi-layer.html">Multi-Layer Functions</a></li><li class="chapter-item expanded "><a href="patterns/parallel.html">One Engine Instance Per Call</a></li><li class="chapter-item expanded "><a href="pattern/../patterns/multi-threading.html">Multi-Threaded Synchronization</a></li><li class="chapter-item expanded "><a href="patterns/events.html">Scriptable Event Handler with State</a></li><li class="chapter-item expanded "><a href="patterns/dynamic-const.html">Dynamic Constants Provider</a></li></ol></li><li class="chapter-item expanded "><a href="advanced.html">Advanced Topics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language/fn-capture.html">Capture Scope for Function Call</a></li><li class="chapter-item expanded "><a href="rust/register-raw.html">Low-Level API</a></li><li class="chapter-item expanded "><a href="engine/var.html">Variable Resolver</a></li><li class="chapter-item expanded "><a href="engine/dsl.html">Use as DSL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/disable.html">Disable Keywords and/or Operators</a></li><li class="chapter-item expanded "><a href="engine/custom-op.html">Custom Operators</a></li><li class="chapter-item expanded "><a href="engine/custom-syntax.html">Extending with Custom Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="patterns/multiple.html">Multiple Instantiation</a></li><li class="chapter-item expanded "><a href="engine/metadata/index.html">Functions Metadata</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="engine/metadata/gen_fn_sig.html">Generate Function Signatures</a></li><li class="chapter-item expanded "><a href="engine/metadata/export_to_json.html">Export Metadata to JSON</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="tools/index.html">External Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/playground.html">Online Playground</a></li><li class="chapter-item expanded "><a href="tools/rhai-doc.html">rhai-doc</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/index.html">Appendix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html">Keywords</a></li><li class="chapter-item expanded "><a href="appendix/operators.html">Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix/literals.html">Literals</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rhai - Embedded Scripting for Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/rhaiscript/rhai" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-rhai" id="what-is-rhai">What is Rhai</a></h1>
<p><img src="about//book/vnext/images/logo/rhai-banner-transparent-colour.svg" alt="Rhai Logo" /></p>
<p>Rhai is an embedded scripting language and evaluation engine for Rust that gives a safe and easy way
to add scripting to any application.</p>
<h2><a class="header" href="#versions" id="versions">Versions</a></h2>
<p>This Book is for version <strong>0.19.11</strong> of Rhai.</p>
<h2><a class="header" href="#etymology-of-the-name-rhai" id="etymology-of-the-name-rhai">Etymology of the name “Rhai”</a></h2>
<h3><a class="header" href="#as-per-rhais-author-johnathan-turner" id="as-per-rhais-author-johnathan-turner">As per Rhai’s author Johnathan Turner</a></h3>
<p>In the beginning there was <a href="http://chaiscript.com">ChaiScript</a>,
which is an embedded scripting language for C++.
Originally it was intended to be a scripting language similar to <strong>JavaScript</strong>.</p>
<p>With java being a kind of hot beverage, the new language was named after
another hot beverage – <strong>Chai</strong>, which is the word for “tea” in many world languages
and, in particular, a popular kind of milk tea consumed in India.</p>
<p>Later, when the novel implementation technique behind ChaiScript was ported from C++ to Rust,
logically the <code>C</code> was changed to an <code>R</code> to make it “RhaiScript”, or just “Rhai”.</p>
<h3><a class="header" href="#on-the-origin-of-the-semi-official-rhai-logo" id="on-the-origin-of-the-semi-official-rhai-logo">On the origin of the semi-official Rhai logo</a></h3>
<p>One of Rhai’s maintainers, <a href="https://github.com/schungx">Stephen Chung</a>, was thinking about a logo when he accidentally
came across a copy of <em>Catcher in the Rye</em> in a restaurant, and drew the first version
of the logo.</p>
<p>Then <a href="https://github.com/semirix"><code>@semirix</code></a> refined it to the current version.</p>
<p>The plan is to make the logo official together with a <code>1.0</code> release.</p>
<h1><a class="header" href="#features" id="features">Features</a></h1>
<h2><a class="header" href="#easy" id="easy">Easy</a></h2>
<ul>
<li>
<p>Simple language similar to JavaScript+Rust with dynamic typing.</p>
</li>
<li>
<p>Tight integration with native Rust <a href="about//book/vnext/language/functions.html">functions</a> and <a href="about//book/vnext/rust/custom.html">types</a> including
<a href="about//book/vnext/rust/getters-setters.html">getters/setters</a>, <a href="about//book/vnext/rust/custom.html">methods</a> and <a href="about//book/vnext/rust/indexers.html">indexers</a>.</p>
</li>
<li>
<p>Freely pass Rust variables/constants into a script via an external <a href="about//book/vnext/engine/scope.html"><code>Scope</code></a> – all clonable
Rust types are supported seamlessly without the need to implement any special trait.</p>
</li>
<li>
<p>Easily <a href="about//book/vnext/engine/call-fn.html">call a script-defined function</a> from Rust.</p>
</li>
<li>
<p>Very few additional dependencies – right now only
<a href="https://crates.io/crates/smallvec"><code>smallvec</code></a>, <a href="https://crates.io/crates/ahash"><code>ahash</code></a>,
plus crates for procedural macros; for <a href="about//book/vnext/start/builds/no-std.html"><code>no-std</code></a> and <code>WASM</code> builds, a number of additional
dependencies are pulled in to provide for missing functionalities.</p>
</li>
<li>
<p><a href="about//book/vnext/plugins/index.html">Plugins</a> system powered by procedural macros simplifies custom API development.</p>
</li>
</ul>
<h2><a class="header" href="#fast" id="fast">Fast</a></h2>
<ul>
<li>
<p>Fairly efficient evaluation (1 million iterations in 0.3 sec on a single-core, 2.3 GHz Linux VM).</p>
</li>
<li>
<p>Compile once to <a href="about//book/vnext/engine/compile.html">AST</a> for repeated evaluations.</p>
</li>
<li>
<p>Scripts are <a href="about//book/vnext/engine/optimize/index.html">optimized</a> (useful for template-based machine-generated scripts).</p>
</li>
</ul>
<h2><a class="header" href="#dynamic" id="dynamic">Dynamic</a></h2>
<ul>
<li>
<p><a href="about//book/vnext/language/overload.html">Function overloading</a>.</p>
</li>
<li>
<p><a href="about//book/vnext/rust/operators.html">Operator overloading</a>.</p>
</li>
<li>
<p>Organize code base with dynamically-loadable <a href="about//book/vnext/rust/modules/index.html">modules</a>, optionally overriding the
<a href="about//book/vnext/rust/modules/resolvers.html">resolution</a> process.</p>
</li>
<li>
<p>Dynamic dispatch via <a href="about//book/vnext/language/fn-ptr.html">function pointers</a> with additional support for <a href="about//book/vnext/language/fn-curry.html">currying</a>.</p>
</li>
<li>
<p><a href="about//book/vnext/language/fn-closure.html">Closures</a> that can capture shared variables.</p>
</li>
<li>
<p>Some support for <a href="about//book/vnext/patterns/oop.html">object-oriented programming (OOP)</a>.</p>
</li>
<li>
<p>Hook into variables access via <a href="about//book/vnext/engine/var.html">variable resolver</a>.</p>
</li>
</ul>
<h2><a class="header" href="#safe" id="safe">Safe</a></h2>
<ul>
<li>
<p>Relatively little <code>unsafe</code> code (yes there are some for performance reasons).</p>
</li>
<li>
<p>Sand-boxed – the scripting <a href="about//book/vnext/engine/hello-world.html"><code>Engine</code></a>, if declared immutable, cannot mutate the containing
environment unless <a href="about//book/vnext/patterns/control.html">explicitly permitted</a>.</p>
</li>
</ul>
<h2><a class="header" href="#rugged" id="rugged">Rugged</a></h2>
<ul>
<li>
<p>Protected against malicious attacks (such as <a href="about//book/vnext/safety/max-call-stack.html">stack-overflow</a>,
<a href="about//book/vnext/safety/max-string-size.html">over-sized data</a>, and <a href="about//book/vnext/safety/max-operations.html">runaway scripts</a>
etc.) that may come from untrusted third-party user-land scripts.</p>
</li>
<li>
<p>Track script evaluation <a href="about//book/vnext/safety/progress.html">progress</a> and manually terminate a script run.</p>
</li>
</ul>
<h2><a class="header" href="#flexible" id="flexible">Flexible</a></h2>
<ul>
<li>
<p>Re-entrant scripting <a href="about//book/vnext/engine/hello-world.html"><code>Engine</code></a> can be made <code>Send + Sync</code> (via the <a href="about//book/vnext/start/features.html"><code>sync</code></a> feature).</p>
</li>
<li>
<p>Serialization/deserialization support via <a href="https://crates.io/crates/serde"><code>serde</code></a>.</p>
</li>
<li>
<p>Support for <a href="about//book/vnext/start/builds/minimal.html">minimal builds</a> by excluding unneeded language <a href="about//book/vnext/start/features.html">features</a>.</p>
</li>
<li>
<p>Supports <a href="about/targets.html">most build targets</a> including <code>no-std</code> and <a href="about//book/vnext/start/builds/wasm.html">WASM</a>.</p>
</li>
<li>
<p>Surgically <a href="about//book/vnext/engine/disable.html">disable keywords and operators</a> to restrict the language.</p>
</li>
<li>
<p>Use as a <a href="about//book/vnext/engine/dsl.html">DSL</a> by defining <a href="about//book/vnext/engine/custom-op.html">custom operators</a> and/or extending the language with <a href="about//book/vnext/engine/custom-syntax.html">custom syntax</a>.</p>
</li>
</ul>
<h1><a class="header" href="#supported-targets-and-builds" id="supported-targets-and-builds">Supported Targets and Builds</a></h1>
<p>The following targets and builds are support by Rhai:</p>
<ul>
<li>
<p>All common CPU targets for Windows, Linux and MacOS.</p>
</li>
<li>
<p>WebAssembly (<a href="about//book/vnext/start/builds/wasm.html">WASM</a>)</p>
</li>
<li>
<p><a href="about//book/vnext/start/builds/no-std.html"><code>no-std</code></a></p>
</li>
</ul>
<h2><a class="header" href="#minimum-rust-version" id="minimum-rust-version">Minimum Rust Version</a></h2>
<p>The minimum version of Rust required to compile Rhai is <code>1.45.0</code>.</p>
<h1><a class="header" href="#what-rhai-isnt" id="what-rhai-isnt">What Rhai Isn’t</a></h1>
<p>Rhai’s purpose is to provide a dynamic layer over Rust code, in the same spirit of <em>zero cost abstractions</em>.
It doesn’t attempt to be a new language. For example:</p>
<ul>
<li>
<p><strong>No classes</strong>.  Well, Rust doesn’t either. On the other hand...</p>
</li>
<li>
<p><strong>No traits</strong>...  so it is also not Rust. Do your Rusty stuff in Rust.</p>
</li>
<li>
<p><strong>No structures/records/tuples</strong> – define your types in Rust instead; Rhai can seamlessly work with <em>any Rust type</em>.</p>
<p>There is, however, a built-in <a href="about//book/vnext/language/object-maps.html">object map</a> type which is adequate for most uses.
It is possible to simulate <a href="about//book/vnext/patterns/oop.html">object-oriented programming (OOP)</a> by storing <a href="about//book/vnext/language/fn-ptr.html">function pointers</a>
or <a href="about//book/vnext/language/fn-closure.html">closures</a> in <a href="about//book/vnext/language/object-maps.html">object map</a> properties, turning them into <em>methods</em>.</p>
</li>
<li>
<p><strong>No first-class functions</strong> – Code your functions in Rust instead, and register them with Rhai.</p>
<p>There is, however, support for simple <a href="about//book/vnext/language/fn-ptr.html">function pointers</a> to allow runtime dispatch by function name.</p>
</li>
<li>
<p><strong>No garbage collection</strong> – this should be expected, so...</p>
</li>
<li>
<p><strong>No first-class closures</strong> – do your closure magic in Rust instead: <a href="about//book/vnext/engine/call-fn.html">turn a Rhai scripted function into a Rust closure</a>.</p>
<p>There is, however, support for simulated <a href="about//book/vnext/language/fn-closure.html">closures</a> via <a href="about//book/vnext/language/fn-curry.html">currying</a> a <a href="about//book/vnext/language/fn-ptr.html">function pointer</a> with
captured shared variables.</p>
</li>
<li>
<p><strong>No byte-codes/JIT</strong> – Rhai has an optimized AST-walking interpreter which is fast enough for most casual
usage scenarios. Essential AST data structures are packed and kept together to maximize cache friendliness.</p>
<p>Functions are dispatched based on pre-calculated hashes and accessing variables are mostly through pre-calculated
offsets to the variables file (a <a href="about//book/vnext/engine/scope.html"><code>Scope</code></a>), so it is seldom necessary to look something up by text name.</p>
<p>In addition, Rhai’s design deliberately avoids maintaining a <em>scope chain</em> so function scopes do not
pay any speed penalty.  This particular design also allows variables data to be kept together in a contiguous
block, avoiding allocations and fragmentation while being cache-friendly. In a typical script evaluation run,
no data is shared and nothing is locked.</p>
<p>Still, the purpose of Rhai is not to be super <em>fast</em>, but to make it as easy and versatile as possible to
integrate with native Rust applications.</p>
</li>
<li>
<p><strong>No formal language grammar</strong> – Rhai uses a hand-coded lexer, a hand-coded top-down recursive-descent parser
for statements, and a hand-coded Pratt parser for expressions.</p>
<p>This lack of formalism allows the <em>tokenizer</em> and <em>parser</em> themselves to be exposed as services in order
to support <a href="about//book/vnext/engine/disable.html">disabling keywords/operators</a>, adding <a href="about//book/vnext/engine/custom-op.html">custom operators</a>,
and defining <a href="about//book/vnext/engine/custom-syntax.html">custom syntax</a>.</p>
</li>
</ul>
<h2><a class="header" href="#do-not-write-the-next-4d-vr-game-in-rhai" id="do-not-write-the-next-4d-vr-game-in-rhai">Do Not Write The Next 4D VR Game in Rhai</a></h2>
<p>Due to this intended usage, Rhai deliberately keeps the language simple and small by omitting
advanced language features such as classes, inheritance, interfaces, generics,
first-class functions/closures, pattern matching, concurrency, byte-codes VM, JIT etc.
Focus is on <em>flexibility</em> and <em>ease of use</em> instead of raw speed.</p>
<p>Avoid the temptation to write full-fledge application logic entirely in Rhai -
that use case is best fulfilled by more complete languages such as JavaScript or Lua.</p>
<h2><a class="header" href="#thin-dynamic-wrapper-layer-over-rust-code" id="thin-dynamic-wrapper-layer-over-rust-code">Thin Dynamic Wrapper Layer Over Rust Code</a></h2>
<p>In actual practice, it is usually best to expose a Rust API into Rhai for scripts to call.</p>
<p>All the core functionalities should be written in Rust, with Rhai being the dynamic <em>control</em> layer.</p>
<p>This is similar to some dynamic languages where most of the core functionalities reside in a C/C++
standard library.</p>
<p>Another similar scenario is a web front-end driving back-end services written in a systems language.
In this case, JavaScript takes the role of Rhai while the back-end language, well... it can actually also be Rust.
Except that Rhai integrates with Rust <em>much</em> more tightly, removing the need for interfaces such
as XHR calls and payload encoding such as JSON.</p>
<h1><a class="header" href="#licensing" id="licensing">Licensing</a></h1>
<p>Rhai is licensed under either of the following, at your choice:</p>
<ul>
<li>
<p><a href="https://github.com/rhaiscript/rhai/blob/master/LICENSE-APACHE.txt">Apache License, Version 2.0</a>, or</p>
</li>
<li>
<p><a href="https://github.com/rhaiscript/rhai/blob/master/LICENSE-MIT.txt">MIT license</a>.</p>
</li>
</ul>
<p>Unless explicitly stated otherwise, any contribution intentionally submitted for inclusion in this crate,
as defined in the Apache-2.0 license, shall be dual-licensed as above,
without any additional terms or conditions.</p>
<h1><a class="header" href="#related-resources" id="related-resources">Related Resources</a></h1>
<h2><a class="header" href="#online-resources-for-rhai" id="online-resources-for-rhai">Online Resources for Rhai</a></h2>
<ul>
<li>
<p><a href="https://github.com/rhaiscript/rhai">GitHub</a> – Home repository</p>
</li>
<li>
<p><a href="https://crates.io/crates/rhai"><code>crates.io</code></a> – Rhai crate</p>
</li>
<li>
<p><a href="https://docs.rs/rhai"><code>DOCS.RS</code></a> – Rhai API documentation</p>
</li>
<li>
<p><a href="https://lib.rs/crates/rhai"><code>LIB.RS</code></a> – Rhai library info</p>
</li>
<li>
<p><a href="https://discord.gg/HquqbYFcZ9">Discord Chat</a> – Rhai channel</p>
</li>
<li>
<p><a href="https://www.reddit.com/r/Rhai">Reddit</a> – Rhai community</p>
</li>
</ul>
<h2><a class="header" href="#external-tools" id="external-tools">External Tools</a></h2>
<ul>
<li>
<p><a href="https://rhai.rs/playground">Online Playground</a> – Run Rhai scripts directly from an editor in the browser</p>
</li>
<li>
<p><a href="https://github.com/rhaiscript/rhai-doc"><code>rhai-doc</code></a> – Rhai script documentation tool</p>
</li>
</ul>
<h2><a class="header" href="#other-cool-projects" id="other-cool-projects">Other Cool Projects</a></h2>
<ul>
<li>
<p><a href="http://chaiscript.com">ChaiScript</a> – A strong inspiration for Rhai.  An embedded scripting language for C++.</p>
</li>
<li>
<p>Check out the list of <a href="https://github.com/rust-unofficial/awesome-rust#scripting">scripting languages for Rust</a> on <a href="https://github.com/rust-unofficial/awesome-rust">awesome-rust</a></p>
</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>This section shows how to install the Rhai crate into a Rust application.</p>
<h1><a class="header" href="#online-playground" id="online-playground">Online Playground</a></h1>
<p>Rhai provides an <a href="https://rhai.rs/playground">online playground</a> to try out its language and engine features
without having to install anything.</p>
<p>The playground provides a syntax-highlighting script editor with example snippets.
Scripts can be evaluated directly from the editor.</p>
<h1><a class="header" href="#install-the-rhai-crate" id="install-the-rhai-crate">Install the Rhai Crate</a></h1>
<p>In order to use Rhai in a project, the Rhai crate must first be made a dependency.</p>
<p>The easiest way is to install the Rhai crate from <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a>,
starting by looking up the latest version and adding this line under <code>dependencies</code> in the project’s <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
rhai = &quot;0.19.11&quot;    # assuming 0.19.11 is the latest version
</code></pre>
<p>Or to automatically use the latest released crate version on <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a>:</p>
<pre><code class="language-toml">[dependencies]
rhai = &quot;*&quot;
</code></pre>
<p>Crate versions are released on <a href="https:/crates.io/crates/rhai/"><code>crates.io</code></a> infrequently,
so to track the latest features, enhancements and bug fixes, pull directly from
<a href="https://github.com/rhaiscript/rhai">GitHub</a>:</p>
<pre><code class="language-toml">[dependencies]
rhai = { git = &quot;https://github.com/rhaiscript/rhai&quot; }
</code></pre>
<h1><a class="header" href="#optional-features" id="optional-features">Optional Features</a></h1>
<p>By default, Rhai includes all the standard functionalities in a small, tight package.</p>
<p>Most features are here to opt-<strong>out</strong> of certain functionalities that are not needed.
Notice that this deviates from Rust norm where features are <em>additive</em>.</p>
<p>Excluding unneeded functionalities can result in smaller, faster builds as well as
more control over what a script can (or cannot) do.</p>
<h2><a class="header" href="#features-that-enable-special-functionalities" id="features-that-enable-special-functionalities">Features that Enable Special Functionalities</a></h2>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>sync</code></td><td align="center">no</td><td>restricts all values types to those that are <code>Send + Sync</code>; under this feature, all Rhai types, including <a href="start//book/vnext/engine/hello-world.html"><code>Engine</code></a>, <a href="start//book/vnext/engine/scope.html"><code>Scope</code></a> and <a href="start//book/vnext/engine/compile.html"><code>AST</code></a>, are all <code>Send + Sync</code></td></tr>
<tr><td><code>unicode-xid-ident</code></td><td align="center">no</td><td>allows <a href="http://www.unicode.org/reports/tr31/">Unicode Standard Annex #31</a> as identifiers</td></tr>
<tr><td><code>serde</code></td><td align="center">yes</td><td>enables serialization/deserialization via <code>serde</code> (requires the <a href="https://crates.io/crates/serde"><code>serde</code></a> crate)</td></tr>
<tr><td><code>metadata</code></td><td align="center">yes</td><td>enables exporting <a href="start//book/vnext/engine/metadata/index.html">functions metadata</a> to <a href="start//book/vnext/engine/metadata/export_to_json.html">JSON format</a> (implies <code>serde</code> and additionally pulls in <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a>)</td></tr>
<tr><td><code>internals</code></td><td align="center">yes</td><td>exposes internal data structures (e.g. <a href="start//book/vnext/engine/compile.html"><code>AST</code></a> nodes); beware that Rhai internals are volatile and may change from version to version</td></tr>
</tbody></table>
<h2><a class="header" href="#features-that-disable-certain-language-features" id="features-that-disable-certain-language-features">Features that Disable Certain Language Features</a></h2>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>no_float</code></td><td align="center">no</td><td>disables floating-point numbers and math</td></tr>
<tr><td><code>no_index</code></td><td align="center">no</td><td>disables <a href="start//book/vnext/language/arrays.html">arrays</a> and indexing features</td></tr>
<tr><td><code>no_object</code></td><td align="center">no</td><td>disables support for <a href="start//book/vnext/rust/custom.html">custom types</a> and <a href="start//book/vnext/language/object-maps.html">object maps</a></td></tr>
<tr><td><code>no_function</code></td><td align="center">no</td><td>disables script-defined <a href="start//book/vnext/language/functions.html">functions</a> (implies <code>no_closure</code>)</td></tr>
<tr><td><code>no_module</code></td><td align="center">no</td><td>disables loading external <a href="start//book/vnext/rust/modules/index.html">modules</a></td></tr>
<tr><td><code>no_closure</code></td><td align="center">no</td><td>disables <a href="start//book/vnext/language/fn-closure.html">capturing</a> external variables in <a href="start//book/vnext/language/fn-anon.html">anonymous functions</a> to simulate <em>closures</em>, or <a href="start//book/vnext/language/fn-capture.html">capturing the calling scope</a> in function calls</td></tr>
</tbody></table>
<h2><a class="header" href="#features-that-disable-certain-engine-features" id="features-that-disable-certain-engine-features">Features that Disable Certain Engine Features</a></h2>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>unchecked</code></td><td align="center">no</td><td>disables arithmetic checking (such as over-flows and division by zero), call stack depth limit, operations count limit and modules loading limit.<br/>Beware that a bad script may panic the entire system!</td></tr>
<tr><td><code>no_optimize</code></td><td align="center">no</td><td>disables <a href="start//book/vnext/engine/optimize/index.html">script optimization</a></td></tr>
</tbody></table>
<h2><a class="header" href="#features-that-configure-the-engine" id="features-that-configure-the-engine">Features that Configure the Engine</a></h2>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>f32_float</code></td><td align="center">no</td><td>sets the system floating-point type to <code>f32</code> instead of <code>f64</code>; <code>FLOAT</code> is set to <code>f32</code></td></tr>
<tr><td><code>only_i32</code></td><td align="center">no</td><td>sets the system integer type to <code>i32</code> and disable all other integer types; <code>INT</code> is set to <code>i32</code></td></tr>
<tr><td><code>only_i64</code></td><td align="center">no</td><td>sets the system integer type to <code>i64</code> and disable all other integer types; <code>INT</code> is set to <code>i64</code></td></tr>
</tbody></table>
<h2><a class="header" href="#features-for-no-std-builds" id="features-for-no-std-builds">Features for <code>no-std</code> Builds</a></h2>
<p>The following features are provided exclusively for <a href="start//book/vnext/start/builds/no-std.html"><code>no-std</code></a> targets.
Do not use them when not compiling for <a href="start//book/vnext/start/builds/no-std.html"><code>no-std</code></a>.</p>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>no_std</code></td><td align="center">no</td><td>builds for <a href="start//book/vnext/start/builds/no-std.html"><code>no-std</code></a> (implies <code>no_closure</code>); notice that additional dependencies will be pulled in to replace <code>std</code> features</td></tr>
</tbody></table>
<h2><a class="header" href="#features-for-webassembly-wasm-builds" id="features-for-webassembly-wasm-builds">Features for WebAssembly (WASM) Builds</a></h2>
<p>The following features are provided exclusively for <a href="start//book/vnext/start/builds/wasm.html">WASM</a> targets.
Do not use them for non-<a href="start//book/vnext/start/builds/wasm.html">WASM</a> targets.</p>
<table><thead><tr><th>Feature</th><th align="center">Additive?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>wasm-bindgen</code></td><td align="center">no</td><td>uses <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> to compile for <a href="start//book/vnext/start/builds/wasm.html">WASM</a></td></tr>
<tr><td><code>stdweb</code></td><td align="center">no</td><td>uses <a href="https://crates.io/crates/stdweb"><code>stdweb</code></a> to compile for <a href="start//book/vnext/start/builds/wasm.html">WASM</a></td></tr>
</tbody></table>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>The <code>Cargo.toml</code> configuration below turns on these six features:</p>
<ul>
<li><code>sync</code> (everything <code>Send + Sync</code>)</li>
<li><code>unchecked</code> (disable all checking – should not be used with untrusted user scripts)</li>
<li><code>only_i32</code> (only 32-bit signed integers)</li>
<li><code>no_float</code> (no floating point numbers)</li>
<li><code>no_module</code> (no loading external <a href="start//book/vnext/rust/modules/index.html">modules</a>)</li>
<li><code>no_function</code> (no defining <a href="start//book/vnext/language/functions.html">functions</a>)</li>
</ul>
<pre><code class="language-toml">[dependencies]
rhai = { version = &quot;0.19.11&quot;, features = [ &quot;sync&quot;, &quot;unchecked&quot;, &quot;only_i32&quot;, &quot;no_float&quot;, &quot;no_module&quot;, &quot;no_function&quot; ] }
</code></pre>
<p>The resulting scripting engine supports only the <code>i32</code> integer numeral type (and no others like <code>u32</code>, <code>i16</code> or <code>i64</code>),
no floating-point, is <code>Send + Sync</code> (so it can be safely used across threads), and does not support defining <a href="start//book/vnext/language/functions.html">functions</a>
nor loading external <a href="start//book/vnext/rust/modules/index.html">modules</a>.</p>
<p>This configuration is perfect for an expression parser in a 32-bit embedded system without floating-point hardware.</p>
<h2><a class="header" href="#caveat--features-are-not-additive" id="caveat--features-are-not-additive">Caveat – Features Are Not Additive</a></h2>
<p>Most Rhai features are not strictly <em>additive</em> – i.e. they do not only add optional functionalities.</p>
<p>In fact, most features are <em>subtractive</em> – i.e. they <em>remove</em> functionalities.</p>
<p>There is a reason for this design, because the <em>lack</em> of a language feature by itself is a feature.</p>
<p>See <a href="start//book/vnext/patterns/multiple.html">here</a> for more details.</p>
<h1><a class="header" href="#special-builds" id="special-builds">Special Builds</a></h1>
<p>It is possible to mix-and-match various <a href="start/builds//book/vnext/start/features.html">features</a> of the Rhai crate to make
specialized builds with specific characteristics and behaviors.</p>
<h1><a class="header" href="#performance-build" id="performance-build">Performance Build</a></h1>
<p>Some features are for performance.  For example, using <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a> or <a href="start/builds//book/vnext/start/features.html"><code>only_i64</code></a> disables all other integer types (such as <code>u16</code>).</p>
<h2><a class="header" href="#use-only-one-integer-type" id="use-only-one-integer-type">Use Only One Integer Type</a></h2>
<p>If only a single integer type is needed in scripts – most of the time this is the case – it is best to avoid registering
lots of functions related to other integer types that will never be used.  As a result, <a href="start/builds//book/vnext/engine/hello-world.html"><code>Engine</code></a> creation will be faster
because fewer functions need to be loaded.</p>
<p>The <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a> and <a href="start/builds//book/vnext/start/features.html"><code>only_i64</code></a> features disable all integer types except <code>i32</code> or <code>i64</code> respectively.</p>
<h2><a class="header" href="#use-only-32-bit-numbers" id="use-only-32-bit-numbers">Use Only 32-Bit Numbers</a></h2>
<p>If only 32-bit integers are needed – again, most of the time this is the case – turn on <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a>.
Under this feature, only <code>i32</code> is supported as a built-in integer type and no others.</p>
<p>On 64-bit targets this may not gain much, but on certain 32-bit targets this improves performance
due to 64-bit arithmetic requiring more CPU cycles to complete.</p>
<h2><a class="header" href="#minimize-size-of-dynamic" id="minimize-size-of-dynamic">Minimize Size of <code>Dynamic</code></a></h2>
<p>Turning on <a href="start/builds//book/vnext/start/features.html"><code>no_float</code></a> or <a href="start/builds//book/vnext/start/features.html"><code>f32_float</code></a> and <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a> on 32-bit targets makes the critical <a href="start/builds//book/vnext/language/dynamic.html"><code>Dynamic</code></a>
data type only 8 bytes long.
Normally <a href="start/builds//book/vnext/language/dynamic.html"><code>Dynamic</code></a> can be up to 12-16 bytes in order to hold an <code>i64</code> or <code>f64</code>.</p>
<p>A small <a href="start/builds//book/vnext/language/dynamic.html"><code>Dynamic</code></a> helps performance due to better cache efficiency.</p>
<h2><a class="header" href="#use-immutablestring" id="use-immutablestring">Use <code>ImmutableString</code></a></h2>
<p>Internally, Rhai uses <em>immutable</em> <a href="start/builds//book/vnext/language/strings-chars.html">strings</a> instead of the Rust <code>String</code> type.  This is mainly to avoid excessive
cloning when passing function arguments.</p>
<p>Rhai’s internal string type is <code>ImmutableString</code> (basically <code>Rc&lt;String&gt;</code> or <code>Arc&lt;String&gt;</code> depending on the <a href="start/builds//book/vnext/start/features.html"><code>sync</code></a> feature).
It is cheap to clone, but expensive to modify (a new copy of the string must be made in order to change it).</p>
<p>Therefore, functions taking <code>String</code> parameters should use <code>ImmutableString</code> or <code>&amp;str</code> (both map to <code>ImmutableString</code>)
for the best performance with Rhai.</p>
<h2><a class="header" href="#disable-closures" id="disable-closures">Disable Closures</a></h2>
<p>Support for <a href="start/builds//book/vnext/language/fn-closure.html">closures</a> that capture shared variables adds material overhead to script evaluation.</p>
<p>This is because every data access must be checked whether it is a shared value and, if so, take a read
lock before reading it.</p>
<p>Use <a href="start/builds//book/vnext/start/features.html"><code>no_closure</code></a> to disable closure and capturing support to optimize the hot path
because there is no need to take locks for shared data.</p>
<h1><a class="header" href="#minimal-build" id="minimal-build">Minimal Build</a></h1>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>In order to compile a <em>minimal</em> build – i.e. a build optimized for size – perhaps for <code>no-std</code> embedded targets or for
compiling to <a href="start/builds//book/vnext/start/builds/wasm.html">WASM</a>, it is essential that the correct linker flags are used in <code>cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
lto = &quot;fat&quot;         # turn on Link-Time Optimizations
codegen-units = 1   # trade compile time with maximum optimization
opt-level = &quot;z&quot;     # optimize for size
</code></pre>
<h2><a class="header" href="#use-i32-only" id="use-i32-only">Use <code>i32</code> Only</a></h2>
<p>For embedded systems that must optimize for code size, the architecture is commonly 32-bit.
Use <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a> to prune away large sections of code implementing functions for other numeric types
(including <code>i64</code>).</p>
<p>If, for some reason, 64-bit long integers must be supported, use <a href="start/builds//book/vnext/start/features.html"><code>only_i64</code></a> instead of <a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a>.</p>
<h2><a class="header" href="#opt-out-of-features" id="opt-out-of-features">Opt-Out of Features</a></h2>
<p>Opt out of as many features as possible, if they are not needed, to reduce code size because, remember, by default
all code is compiled into the final binary since what a script requires cannot be predicted.
If a language feature will never be needed, omitting it is a prudent strategy to optimize the build for size.</p>
<p>Omitting arrays (<a href="start/builds//book/vnext/start/features.html"><code>no_index</code></a>) yields the most code-size savings, followed by floating-point support
(<a href="start/builds//book/vnext/start/features.html"><code>no_float</code></a>), checked arithmetic/script resource limits (<a href="start/builds//book/vnext/start/features.html"><code>unchecked</code></a>) and finally object maps and custom types (<a href="start/builds//book/vnext/start/features.html"><code>no_object</code></a>).</p>
<p>Where the usage scenario does not call for loading externally-defined modules, use <a href="start/builds//book/vnext/start/features.html"><code>no_module</code></a> to save some bytes.
Disable script-defined functions (<a href="start/builds//book/vnext/start/features.html"><code>no_function</code></a>) and possibly closures (<a href="start/builds//book/vnext/start/features.html"><code>no_closure</code></a>) when the features are not needed.
Both of these have some code size savings but not much.</p>
<h2><a class="header" href="#use-a-raw-a-hrefstartbuildsbookvnextenginehello-worldhtmlenginea" id="use-a-raw-a-hrefstartbuildsbookvnextenginehello-worldhtmlenginea">Use a Raw <a href="start/builds//book/vnext/engine/hello-world.html"><code>Engine</code></a></a></h2>
<p><a href="start/builds//book/vnext/engine/raw.html"><code>Engine::new_raw</code></a> creates a <em>raw</em> engine.
A <em>raw</em> engine supports, out of the box, only a very <a href="start/builds//book/vnext/engine/raw.html#built-in-operators">restricted set</a>
of basic arithmetic and logical operators.</p>
<p>Selectively include other necessary functionalities by picking specific <a href="start/builds//book/vnext/rust/packages/index.html">packages</a> to minimize the footprint.</p>
<p>Packages are shared (even across threads via the <a href="start/builds//book/vnext/start/features.html"><code>sync</code></a> feature), so they only have to be created once.</p>
<h1><a class="header" href="#no-std-build" id="no-std-build"><code>no-std</code> Build</a></h1>
<p>The feature <a href="start/builds//book/vnext/start/features.html"><code>no_std</code></a> automatically converts the scripting engine into a <code>no-std</code> build.</p>
<p>Usually, a <code>no-std</code> build goes hand-in-hand with <a href="start/builds//book/vnext/start/builds/minimal.html">minimal builds</a> because typical embedded
hardware (the primary target for <code>no-std</code>) has limited storage.</p>
<h2><a class="header" href="#nightly-required" id="nightly-required">Nightly Required</a></h2>
<p>Currently, <a href="start/builds//book/vnext/start/features.html"><code>no_std</code></a> requires the nightly compiler due to the crates that it uses.</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<p>Rhai allocates, so the first thing that must be included in any <code>no-std</code> project is
an allocator crate, such as <a href="https://crates.io/crates/wee_alloc"><code>wee_alloc</code></a>.</p>
<p>Then there is the need to set up proper error/panic handlers.
The following example uses <code>panic = &quot;abort&quot;</code> and <code>wee_alloc</code> as the allocator.</p>
<pre><pre class="playground"><code class="language-rust">// Set up for no-std.
#![no_std]

// The following no-std features are usually needed.
#![feature(alloc_error_handler, start, core_intrinsics, lang_items, link_cfg)]

// Set up the global allocator.
extern crate alloc;
extern crate wee_alloc;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// Rust needs a CRT runtime on Windows when compiled with MSVC.
#[cfg(all(windows, target_env = &quot;msvc&quot;))]
#[link(name = &quot;msvcrt&quot;)]
#[link(name = &quot;libcmt&quot;)]
extern {}

// Set up panic and error handlers
#[alloc_error_handler]
fn err_handler(_: core::alloc::Layout) -&gt; ! {
    core::intrinsics::abort();
}

#[panic_handler]
#[lang = &quot;panic_impl&quot;]
extern &quot;C&quot; fn rust_begin_panic(_: &amp;core::panic::PanicInfo) -&gt; ! {
    core::intrinsics::abort();
}

#[lang = &quot;eh_personality&quot;]
extern &quot;C&quot; fn eh_personality() {}

#[no_mangle]
extern &quot;C&quot; fn rust_eh_register_frames() {}

#[no_mangle]
extern &quot;C&quot; fn rust_eh_unregister_frames() {}

#[start]
fn main(_argc: isize, _argv: *const *const u8) -&gt; isize {
    // ... main program ...
}
</code></pre></pre>
<h2><a class="header" href="#samples" id="samples">Samples</a></h2>
<p>Check out the <a href="start/builds/../examples/rust.html#no-std-samples"><code>no-std</code> sample applications</a>
for different operating environments.</p>
<h1><a class="header" href="#building-to-webassembly-wasm" id="building-to-webassembly-wasm">Building to WebAssembly (WASM)</a></h1>
<p>It is possible to use Rhai when compiling to WebAssembly (WASM).
This yields a scripting engine (and language) that can be run in a standard web browser.</p>
<p>Why you would <em>want</em> to is another matter... as there is already a nice, fast, complete scripting language
for the the common WASM environment (i.e. a browser) – and it is called JavaScript.</p>
<p>But anyhow, do it because you <em>can</em>!</p>
<p>When building for WASM, certain features will not be available,
such as the script file API’s and loading modules from external script files.</p>
<h2><a class="header" href="#javascript-interop" id="javascript-interop">JavaScript Interop</a></h2>
<p>Specify either of the <a href="start/builds//book/vnext/start/features.html"><code>wasm-bindgen</code></a> or <a href="start/builds//book/vnext/start/features.html"><code>stdweb</code></a> features when building for WASM.
This selects the appropriate JavaScript interop layer to use.</p>
<p>It is still possible to compile for WASM without either <a href="start/builds//book/vnext/start/features.html"><code>wasm-bindgen</code></a> or <a href="start/builds//book/vnext/start/features.html"><code>stdweb</code></a>,
but then the interop code must be explicitly provided.</p>
<h2><a class="header" href="#size" id="size">Size</a></h2>
<p>Also look into <a href="start/builds//book/vnext/start/builds/minimal.html">minimal builds</a> to reduce generated WASM size.</p>
<p>As of this version, a typical, full-featured Rhai scripting engine compiles to a single WASM file
less than 200KB gzipped.</p>
<p>When excluding features that are marginal in WASM environment, the gzipped payload can be
further shrunk to 160KB.</p>
<h2><a class="header" href="#speed" id="speed">Speed</a></h2>
<p>In benchmark tests, a WASM build runs scripts roughly 1.7-2.2x slower than a native optimized release build.</p>
<h2><a class="header" href="#common-features" id="common-features">Common Features</a></h2>
<p>Some Rhai functionalities are not necessary in a WASM environment, so the following features
are typically used for a WASM build:</p>
<table><thead><tr><th align="center">Feature</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>wasm-bindgen</code></a> or <a href="start/builds//book/vnext/start/features.html"><code>stdweb</code></a></td><td>use <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> or <a href="https://crates.io/crates/stdweb"><code>stdweb</code></a> as the JavaScript interop layer, omit if using custom interop code</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>unchecked</code></a></td><td>when a WASM module panics, it doesn’t crash the entire web app; however this also disables <a href="start/builds//book/vnext/safety/max-operations.html">maximum number of operations</a> and <a href="start/builds//book/vnext/safety/progress.html">progress</a> tracking so a script can still run indefinitely – the web app must terminate it itself</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>only_i32</code></a></td><td>WASM supports 32-bit and 64-bit integers, but most scripts will only need 32-bit</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>f32_float</code></a></td><td>WASM supports 32-bit single-precision and 64-bit double-precision floating-point numbers, but single-precision is usually fine for most uses</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>no_module</code></a></td><td>a WASM module cannot load modules from the file system, so usually this is not needed, but the savings are minimal; alternatively, a custom <a href="start/builds//book/vnext/rust/modules/resolvers.html">module resolver</a> can be provided that loads other Rhai scripts</td></tr>
</tbody></table>
<p>The following features are typically <em>not</em> used because they don’t make sense in a WASM build:</p>
<table><thead><tr><th align="center">Feature</th><th>Why unnecessary</th></tr></thead><tbody>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>sync</code></a></td><td>WASM is single-threaded</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>no_std</code></a></td><td><code>std</code> lib works fine with WASM</td></tr>
<tr><td align="center"><a href="start/builds//book/vnext/start/features.html"><code>internals</code></a></td><td>WASM usually doesn’t need to access Rhai internal data structures, unless you are walking the <a href="start/builds//book/vnext/engine/compile.html"><code>AST</code></a></td></tr>
</tbody></table>
<h1><a class="header" href="#packaged-utilities" id="packaged-utilities">Packaged Utilities</a></h1>
<p>A number of Rhai-driven utility programs can be found in the <code>src/bin</code> directory:</p>
<table><thead><tr><th align="center">Utility program</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><a href="https://github.com/rhaiscript/rhai/blob/master/src/bin/rhai-repl.rs"><code>rhai-repl</code></a></td><td>a simple REPL, interactively evaluate statements from stdin</td></tr>
<tr><td align="center"><a href="https://github.com/rhaiscript/rhai/blob/master/src/bin/rhai-run.rs"><code>rhai-run</code></a></td><td>runs each filename passed to it as a Rhai script</td></tr>
</tbody></table>
<h2><a class="header" href="#rhai-repl--the-rhai-repl-tool" id="rhai-repl--the-rhai-repl-tool"><code>rhai-repl</code> – The Rhai REPL Tool</a></h2>
<p><code>rhai-repl</code> is a particularly useful utility program – it allows one to interactively
try out Rhai’s language features in a standard REPL (<strong>R</strong>ead-<strong>E</strong>val-<strong>P</strong>rint <strong>L</strong>oop).</p>
<p>Filenames passed to it as command line arguments are run and loaded before the REPL starts.</p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>The following command first runs three scripts – <code>init1.rhai</code>, <code>init2.rhai</code> and
<code>init3.rhai</code> – loading the functions defined in each script into the <em>global</em>
namespace.</p>
<p>Then it enters an REPL, which can call the above functions freely.</p>
<pre><code class="language-bash">rhai-repl init1.rhai init2.rhai init3.rhai
</code></pre>
<h2><a class="header" href="#rhai-run--the-rhai-runner" id="rhai-run--the-rhai-runner"><code>rhai-run</code> – The Rhai Runner</a></h2>
<p>Use <code>rhai-run</code> to run Rhai scripts.</p>
<p>Filenames passed to it as command line arguments are run in sequence.</p>
<h3><a class="header" href="#example-2" id="example-2">Example</a></h3>
<p>The following command runs the scripts <code>script1.rhai</code>, <code>script2.rhai</code> and <code>script3.rhai</code>
in order.</p>
<pre><code class="language-bash">rhai-run script1.rhai script2.rhai script3.rhai
</code></pre>
<h2><a class="header" href="#running-a-utility-program" id="running-a-utility-program">Running a Utility Program</a></h2>
<p>Utilities can be run with the following command:</p>
<pre><code class="language-bash">cargo run --bin {program_name}
</code></pre>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>Rhai comes with a number of examples showing how to integrate the scripting <a href="start/examples//book/vnext/engine/hello-world.html"><code>Engine</code></a> within
a Rust application, as well as a number of sample scripts that showcase different Rhai language features.</p>
<h1><a class="header" href="#rust-examples" id="rust-examples">Rust Examples</a></h1>
<p>A number of examples can be found in the <code>examples</code> directory:</p>
<table><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/arrays_and_structs.rs"><code>arrays_and_structs</code></a></td><td>shows how to register a custom Rust type and using <a href="start/examples//book/vnext/language/arrays.html">arrays</a> on it</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/custom_types_and_methods.rs"><code>custom_types_and_methods</code></a></td><td>shows how to register a custom Rust type and methods for it</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/hello.rs"><code>hello</code></a></td><td>simple example that evaluates an expression and prints the result</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/reuse_scope.rs"><code>reuse_scope</code></a></td><td>evaluates two pieces of code in separate runs, but using a common <a href="start/examples//book/vnext/engine/scope.html"><code>Scope</code></a></td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/serde.rs"><code>serde</code></a></td><td>example to serialize and deserialize Rust types with <a href="https://crates.io/crates/serde"><code>serde</code></a>.<br/>The <a href="start/examples//book/vnext/rust/serde.html"><code>serde</code></a> feature is required to run</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/simple_fn.rs"><code>simple_fn</code></a></td><td>shows how to register a simple function</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/strings.rs"><code>strings</code></a></td><td>shows different ways to register functions taking string arguments</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/examples/threading.rs"><code>threading</code></a></td><td>shows to communication to an <a href="start/examples//book/vnext/engine/hello-world.html"><code>Engine</code></a> running in a separate thread via an MPSC channel</td></tr>
</tbody></table>
<h2><a class="header" href="#running-examples" id="running-examples">Running Examples</a></h2>
<p>Examples can be run with the following command:</p>
<pre><code class="language-bash">cargo run --example {example_name}
</code></pre>
<h2><a class="header" href="#no-std-samples" id="no-std-samples"><code>no-std</code> Samples</a></h2>
<p>To illustrate <code>no-std</code> builds, a number of sample applications are available under the <code>no_std</code> directory:</p>
<table><thead><tr><th>Sample</th><th>Description</th><th align="center">Optimization</th><th align="center">Allocator</th><th align="center">Panics</th></tr></thead><tbody>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/no_std/no_std_test"><code>no_std_test</code></a></td><td>bare-bones test application that evaluates a Rhai expression and sets the result as the return value</td><td align="center">size</td><td align="center"><a href="https://crates.io/crates/wee_alloc"><code>wee_alloc</code></a></td><td align="center">abort</td></tr>
</tbody></table>
<p><code>cargo run</code> cannot be used to run a <code>no-std</code> sample.  It must first be built:</p>
<pre><code class="language-bash">cd no_std/no_std_test

cargo +nightly build --release

./target/release/no_std_test
</code></pre>
<h1><a class="header" href="#example-scripts" id="example-scripts">Example Scripts</a></h1>
<h2><a class="header" href="#language-feature-scripts" id="language-feature-scripts">Language Feature Scripts</a></h2>
<p>There are also a number of examples scripts that showcase Rhai’s features, all in the <code>scripts</code> directory:</p>
<table><thead><tr><th>Script</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/array.rhai"><code>array.rhai</code></a></td><td><a href="start/examples//book/vnext/language/arrays.html">arrays</a></td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/assignment.rhai"><code>assignment.rhai</code></a></td><td>variable declarations</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/comments.rhai"><code>comments.rhai</code></a></td><td>just comments</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/for1.rhai"><code>for1.rhai</code></a></td><td><a href="start/examples//book/vnext/language/for.html"><code>for</code></a> loops</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/for2.rhai"><code>for2.rhai</code></a></td><td><a href="start/examples//book/vnext/language/for.html"><code>for</code></a> loops on <a href="start/examples//book/vnext/language/arrays.html">arrays</a></td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/function_decl1.rhai"><code>function_decl1.rhai</code></a></td><td>a <a href="start/examples//book/vnext/language/functions.html">function</a> without parameters</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/function_decl2.rhai"><code>function_decl2.rhai</code></a></td><td>a <a href="start/examples//book/vnext/language/functions.html">function</a> with two parameters</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/function_decl3.rhai"><code>function_decl3.rhai</code></a></td><td>a <a href="start/examples//book/vnext/language/functions.html">function</a> with many parameters</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/if1.rhai"><code>if1.rhai</code></a></td><td><a href="start/examples//book/vnext/language/if.html"><code>if</code></a> example</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/loop.rhai"><code>loop.rhai</code></a></td><td>count-down <a href="start/examples//book/vnext/language/loop.html"><code>loop</code></a> in Rhai, emulating a <code>do</code> .. <code>while</code> loop</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/module.rhai"><code>module.rhai</code></a></td><td>import a script file as a module</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/oop.rhai"><code>oop.rhai</code></a></td><td>simulate <a href="start/examples//book/vnext/patterns/oop.html">object-oriented programming (OOP)</a> with <a href="start/examples//book/vnext/language/fn-closure.html">closures</a></td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/op1.rhai"><code>op1.rhai</code></a></td><td>just simple addition</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/op2.rhai"><code>op2.rhai</code></a></td><td>simple addition and multiplication</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/op3.rhai"><code>op3.rhai</code></a></td><td>change evaluation order with parenthesis</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/string.rhai"><code>string.rhai</code></a></td><td><a href="start/examples//book/vnext/language/strings-chars.html">string</a> operations</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/strings_map.rhai"><code>strings_map.rhai</code></a></td><td><a href="start/examples//book/vnext/language/strings-chars.html">string</a> and <a href="start/examples//book/vnext/language/object-maps.html">object map</a> operations</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/while.rhai"><code>while.rhai</code></a></td><td><a href="start/examples//book/vnext/language/while.html"><code>while</code></a> loop</td></tr>
</tbody></table>
<h2><a class="header" href="#benchmark-scripts" id="benchmark-scripts">Benchmark Scripts</a></h2>
<p>The following scripts are for benchmarking the speed of Rhai:</p>
<table><thead><tr><th>Scripts</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/speed_test.rhai"><code>speed_test.rhai</code></a></td><td>a simple application to measure the speed of Rhai’s interpreter (1 million iterations)</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/primes.rhai"><code>primes.rhai</code></a></td><td>use Sieve of Eratosthenes to find all primes smaller than a limit</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/fibonacci.rhai"><code>fibonacci.rhai</code></a></td><td>calculate the n-th Fibonacci number using a really dumb algorithm</td></tr>
<tr><td><a href="https://github.com/rhaiscript/rhai/blob/master/scripts/mat_mul.rhai"><code>mat_mul.rhai</code></a></td><td>matrix multiplication test to measure the speed of multi-dimensional array access</td></tr>
</tbody></table>
<h2><a class="header" href="#running-example-scripts" id="running-example-scripts">Running Example Scripts</a></h2>
<p>The <a href="start/examples/../bin.html"><code>rhai-run</code></a> utility can be used to run Rhai scripts:</p>
<pre><code class="language-bash">cargo run --bin rhai-run scripts/any_script.rhai
</code></pre>
<h1><a class="header" href="#using-the-engine" id="using-the-engine">Using the Engine</a></h1>
<p>Rhai’s interpreter resides in the <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a> type under the master <code>rhai</code> namespace.</p>
<p>This section shows how to set up, configure and use this scripting engine.</p>
<h1><a class="header" href="#hello-world-in-rhai" id="hello-world-in-rhai">Hello World in Rhai</a></h1>
<p>To get going with Rhai is as simple as creating an instance of the scripting engine <code>rhai::Engine</code> via
<code>Engine::new</code>, then calling the <code>eval</code> method:</p>
<pre><pre class="playground"><code class="language-rust">use rhai::{Engine, EvalAltResult};

fn main() -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;
{
    let engine = Engine::new();

    let result = engine.eval::&lt;i64&gt;(&quot;40 + 2&quot;)?;
    //                      ^^^^^^^ cast the result to an 'i64', this is required

    println!(&quot;Answer: {}&quot;, result);             // prints 42

    Ok(())
}
</code></pre></pre>
<p>Evaluate a script file directly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 'eval_file' takes a 'PathBuf'
let result = engine.eval_file::&lt;i64&gt;(&quot;hello_world.rhai&quot;.into())?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#error-type" id="error-type">Error Type</a></h2>
<p><code>rhai::EvalAltResult</code> is the standard Rhai error type, which is a Rust <code>enum</code> containing all errors encountered
during the parsing or evaluation process.</p>
<h2><a class="header" href="#return-type" id="return-type">Return Type</a></h2>
<p>The type parameter for <code>Engine::eval</code> is used to specify the type of the return value,
which <em>must</em> match the actual type or an error is returned. Rhai is very strict here.</p>
<p>There are two ways to specify the return type – <em>turbofish</em> notation, or type inference.</p>
<p>Use <a href="engine//book/vnext/language/dynamic.html"><code>Dynamic</code></a> for uncertain return types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = engine.eval::&lt;i64&gt;(&quot;40 + 2&quot;)?;     // return type is i64, specified using 'turbofish' notation

let result: i64 = engine.eval(&quot;40 + 2&quot;)?;       // return type is inferred to be i64

result.is::&lt;i64&gt;() == true;

let result: Dynamic = engine.eval(&quot;boo()&quot;)?;    // use 'Dynamic' if you're not sure what type it'll be!

let result = engine.eval::&lt;String&gt;(&quot;40 + 2&quot;)?;  // returns an error because the actual return type is i64, not String
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#compile-a-script-to-ast" id="compile-a-script-to-ast">Compile a Script (to AST)</a></h1>
<p>To repeatedly evaluate a script, <em>compile</em> it first with <code>Engine::compile</code> into an <code>AST</code>
(abstract syntax tree) form.</p>
<p><code>Engine::eval_ast</code> evaluates a pre-compiled <code>AST</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile to an AST and store it for later evaluations
let ast = engine.compile(&quot;40 + 2&quot;)?;

for _ in 0..42 {
    let result: i64 = engine.eval_ast(&amp;ast)?;

    println!(&quot;Answer #{}: {}&quot;, i, result);      // prints 42
}
<span class="boring">}
</span></code></pre></pre>
<p>Compiling a script file is also supported with <code>Engine::compile_file</code>
(not available under <a href="engine//book/vnext/start/features.html"><code>no_std</code></a> or in <a href="engine//book/vnext/start/builds/wasm.html">WASM</a> builds):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ast = engine.compile_file(&quot;hello_world.rhai&quot;.into())?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#calling-rhai-functions-from-rust" id="calling-rhai-functions-from-rust">Calling Rhai Functions from Rust</a></h1>
<p>Rhai also allows working <em>backwards</em> from the other direction – i.e. calling a Rhai-scripted function
from Rust via <code>Engine::call_fn</code>.</p>
<p>Functions declared with <code>private</code> are hidden and cannot be called from Rust (see also <a href="engine//book/vnext/rust/modules/index.html">modules</a>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define functions in a script.
let ast = engine.compile(true,
    r#&quot;
        // a function with two parameters: string and i64
        fn hello(x, y) {
            x.len + y
        }

        // functions can be overloaded: this one takes only one parameter
        fn hello(x) {
            x * 2
        }

        // this one takes no parameters
        fn hello() {
            42
        }

        // this one is private and cannot be called by 'call_fn'
        private hidden() {
            throw &quot;you shouldn't see me!&quot;;
        }
    &quot;#)?;

// A custom scope can also contain any variables/constants available to the functions
let mut scope = Scope::new();

// Evaluate a function defined in the script, passing arguments into the script as a tuple.
// Beware, arguments must be of the correct types because Rhai does not have built-in type conversions.
// If arguments of the wrong types are passed, the Engine will not find the function.

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, ( String::from(&quot;abc&quot;), 123_i64 ) )?;
//          ^^^                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//        return type must be specified                          put arguments in a tuple

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, (123_i64,) )?;
//                                                          ^^^^^^^^^^ tuple of one

let result: i64 = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hello&quot;, () )?;
//                                                          ^^ unit = tuple of zero

// The following call will return a function-not-found error because
// 'hidden' is declared with 'private'.
let result: () = engine.call_fn(&amp;mut scope, &amp;ast, &quot;hidden&quot;, ())?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#low-level-api--enginecall_fn_dynamic" id="low-level-api--enginecall_fn_dynamic">Low-Level API – <code>Engine::call_fn_dynamic</code></a></h2>
<p>For more control, construct all arguments as <code>Dynamic</code> values and use <code>Engine::call_fn_dynamic</code>, passing it
anything that implements <code>AsMut&lt;Dynamic&gt;</code> (such as a simple array or a <code>Vec&lt;Dynamic&gt;</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = engine.call_fn_dynamic(
                        &amp;mut scope,         // scope to use
                        &amp;ast,               // AST containing the functions
                        &quot;hello&quot;,            // function entry-point
                        None,               // 'this' pointer, if any
                        [ String::from(&quot;abc&quot;).into(), 123_i64.into() ]      // arguments
             )?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#binding-the-this-pointer" id="binding-the-this-pointer">Binding the <code>this</code> Pointer</a></h2>
<p><code>Engine::call_fn_dynamic</code> can also bind a value to the <code>this</code> pointer of a script-defined function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ast = engine.compile(&quot;fn action(x) { this += x; }&quot;)?;

let mut value: Dynamic = 1_i64.into();

let result = engine.call_fn_dynamic(
                        &amp;mut scope,
                        &amp;ast,
                        &quot;action&quot;,
                        Some(&amp;mut value),   // binding the 'this' pointer
                        [ 41_i64.into() ]
             )?;

assert_eq!(value.as_int()?, 42);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-rust-closure-from-a-rhai-function" id="create-a-rust-closure-from-a-rhai-function">Create a Rust Closure from a Rhai Function</a></h1>
<p>It is possible to further encapsulate a script in Rust such that it becomes a normal Rust function.</p>
<p>Such a <em>closure</em> is very useful as call-back functions.</p>
<p>Creating them is accomplished via the <code>Func</code> trait which contains <code>create_from_script</code>
(as well as its companion method <code>create_from_ast</code>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Func};                   // use 'Func' for 'create_from_script'

let engine = Engine::new();                 // create a new 'Engine' just for this

let script = &quot;fn calc(x, y) { x + y.len &lt; 42 }&quot;;

// Func takes two type parameters:
//   1) a tuple made up of the types of the script function's parameters
//   2) the return type of the script function
//
// 'func' will have type Box&lt;dyn Fn(i64, String) -&gt; Result&lt;bool, Box&lt;EvalAltResult&gt;&gt;&gt; and is callable!
let func = Func::&lt;(i64, String), bool&gt;::create_from_script(
//                ^^^^^^^^^^^^^ function parameter types in tuple

                engine,                     // the 'Engine' is consumed into the closure
                script,                     // the script, notice number of parameters must match
                &quot;calc&quot;                      // the entry-point function name
)?;

func(123, &quot;hello&quot;.to_string())? == false;   // call the closure

schedule_callback(func);                    // pass it as a callback to another function

// Although there is nothing you can't do by manually writing out the closure yourself...
let engine = Engine::new();
let ast = engine.compile(script)?;
schedule_callback(Box::new(move |x: i64, y: String| -&gt; Result&lt;bool, Box&lt;EvalAltResult&gt;&gt; {
    engine.call_fn(&amp;mut Scope::new(), &amp;ast, &quot;calc&quot;, (x, y))
}));
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#evaluate-expressions-only" id="evaluate-expressions-only">Evaluate Expressions Only</a></h1>
<p>Sometimes a use case does not require a full-blown scripting <em>language</em>, but only needs to evaluate <em>expressions</em>.</p>
<p>In these cases, use the <code>Engine::compile_expression</code> and <code>Engine::eval_expression</code> methods or their <code>_with_scope</code> variants.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = engine.eval_expression::&lt;i64&gt;(&quot;2 + (10 + 10) * 2&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<p>When evaluating <em>expressions</em>, no full-blown statement (e.g. <code>if</code>, <code>while</code>, <code>for</code>, <code>fn</code>) – not even variable assignment –
is supported and will be considered parse errors when encountered.</p>
<p><a href="engine//book/vnext/language/fn-closure.html">Closures</a> and <a href="engine//book/vnext/language/fn-anon.html">anonymous functions</a> are also not supported because in the background they compile to functions.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following are all syntax errors because the script is not an expression.

engine.eval_expression::&lt;()&gt;(&quot;x = 42&quot;)?;

let ast = engine.compile_expression(&quot;let x = 42&quot;)?;

let result = engine.eval_expression_with_scope::&lt;i64&gt;(&amp;mut scope, &quot;if x { 42 } else { 123 }&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#raw-engine" id="raw-engine">Raw <code>Engine</code></a></h1>
<p><code>Engine::new</code> creates a scripting <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a> with common functionalities (e.g. printing to the console via <code>print</code>).</p>
<p>In many controlled embedded environments, however, these may not be needed and unnecessarily occupy
application code storage space.</p>
<p>Use <code>Engine::new_raw</code> to create a <em>raw</em> <code>Engine</code>, in which only a minimal set of
basic arithmetic and logical operators are supported (see below).</p>
<p>To add more functionalities to a <em>raw</em> <code>Engine</code>, load <a href="engine//book/vnext/rust/packages/index.html">packages</a> into it.</p>
<h2><a class="header" href="#built-in-operators" id="built-in-operators">Built-in Operators</a></h2>
<table><thead><tr><th>Operators</th><th>Assignment operators</th><th>Supported for types<br/>(see <a href="engine//book/vnext/language/values-and-types.html">standard types</a>)</th></tr></thead><tbody>
<tr><td><code>+</code>,</td><td><code>+=</code></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//book/vnext/start/features.html"><code>no_float</code></a>), <code>char</code>, <code>ImmutableString</code></td></tr>
<tr><td><code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>~</code>,</td><td><code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>~=</code></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//book/vnext/start/features.html"><code>no_float</code></a>)</td></tr>
<tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code></td><td><code>INT</code></td></tr>
<tr><td><code>&amp;</code>, <code>|</code>, <code>^</code></td><td><code>&amp;=</code>, <code>|=</code>, <code>^=</code></td><td><code>INT</code>, <code>bool</code></td></tr>
<tr><td><code>&amp;&amp;</code>, <code>||</code></td><td></td><td><code>bool</code></td></tr>
<tr><td><code>==</code>, <code>!=</code></td><td></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//book/vnext/start/features.html"><code>no_float</code></a>), <code>bool</code>, <code>char</code>, <code>()</code>, <code>ImmutableString</code></td></tr>
<tr><td><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></td><td></td><td><code>INT</code>, <code>FLOAT</code> (if not <a href="engine//book/vnext/start/features.html"><code>no_float</code></a>), <code>char</code>, <code>()</code>, <code>ImmutableString</code></td></tr>
</tbody></table>
<h1><a class="header" href="#scope--initializing-and-maintaining-state" id="scope--initializing-and-maintaining-state"><code>Scope</code> – Initializing and Maintaining State</a></h1>
<p>By default, Rhai treats each <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a> invocation as a fresh one, persisting only the functions that have been defined
but no global state. This gives each evaluation a clean starting slate.</p>
<p>In order to continue using the same global state from one invocation to the next,
such a state must be manually created and passed in.</p>
<p>All <code>Scope</code> variables are <a href="engine//book/vnext/language/dynamic.html"><code>Dynamic</code></a>, meaning they can store values of any type.</p>
<p>Under <a href="engine//book/vnext/start/features.html"><code>sync</code></a>, however, only types that are <code>Send + Sync</code> are supported, and the entire <code>Scope</code> itself
will also be <code>Send + Sync</code>. This is extremely useful in multi-threaded applications.</p>
<p>In this example, a global state object (a <code>Scope</code>) is created with a few initialized variables,
then the same state is threaded through multiple invocations:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, EvalAltResult};

let engine = Engine::new();

// First create the state
let mut scope = Scope::new();

// Then push (i.e. add) some initialized variables into the state.
// Remember the system number types in Rhai are i64 (i32 if 'only_i32') ond f64.
// Better stick to them or it gets hard working with the script.
scope
    .push(&quot;y&quot;, 42_i64)
    .push(&quot;z&quot;, 999_i64)
    .push_constant(&quot;MY_NUMBER&quot;, 123_i64)            // constants can also be added
    .set_value(&quot;s&quot;, &quot;hello, world!&quot;.to_string());   //'set_value' adds a variable when one doesn't exist
                                                    //   remember to use 'String', not '&amp;str'

// First invocation
engine.eval_with_scope::&lt;()&gt;(&amp;mut scope, r&quot;
    let x = 4 + 5 &amp;ndash; y + z + MY_NUMBER + s.len;
    y = 1;
&quot;)?;

// Second invocation using the same state
let result = engine.eval_with_scope::&lt;i64&gt;(&amp;mut scope, &quot;x&quot;)?;

println!(&quot;result: {}&quot;, result);                     // prints 1102

// Variable y is changed in the script &amp;ndash; read it with 'get_value'
assert_eq!(scope.get_value::&lt;i64&gt;(&quot;y&quot;).expect(&quot;variable y should exist&quot;), 1);

// We can modify scope variables directly with 'set_value'
scope.set_value(&quot;y&quot;, 42_i64);
assert_eq!(scope.get_value::&lt;i64&gt;(&quot;y&quot;).expect(&quot;variable y should exist&quot;), 42);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#engine-configuration-options" id="engine-configuration-options">Engine Configuration Options</a></h1>
<p>A number of other configuration options are available from the <code>Engine</code> to fine-tune behavior and safeguards.</p>
<table><thead><tr><th>Method</th><th>Not available under</th><th>Description</th></tr></thead><tbody>
<tr><td><code>set_doc_comments</code></td><td></td><td>enables/disables <a href="engine//book/vnext/language/doc-comments.html">doc-comments</a></td></tr>
<tr><td><code>set_optimization_level</code></td><td><a href="engine//book/vnext/start/features.html"><code>no_optimize</code></a></td><td>sets the amount of script <em>optimizations</em> performedSee <a href="engine//book/vnext/engine/optimize/index.html">script optimization</a></td></tr>
<tr><td><code>set_max_expr_depths</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a></td><td>sets the maximum nesting levels of an expression/statementSee <a href="engine//book/vnext/safety/max-stmt-depth.html">maximum statement depth</a></td></tr>
<tr><td><code>set_max_call_levels</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a></td><td>sets the maximum number of function call levels (default 50) to avoid infinite recursionSee <a href="engine//book/vnext/safety/max-call-stack.html">maximum call stack depth</a></td></tr>
<tr><td><code>set_max_operations</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a></td><td>sets the maximum number of <em>operations</em> that a script is allowed to consumeSee <a href="engine//book/vnext/safety/max-operations.html">maximum number of operations</a></td></tr>
<tr><td><code>set_max_modules</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a></td><td>sets the maximum number of <a href="engine//book/vnext/rust/modules/index.html">modules</a> that a script is allowed to loadSee <a href="engine//book/vnext/safety/max-modules.html">maximum number of modules</a></td></tr>
<tr><td><code>set_max_string_size</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a></td><td>sets the maximum length (in UTF-8 bytes) for <a href="engine//book/vnext/language/strings-chars.html">strings</a>See <a href="engine//book/vnext/safety/max-string-size.html">maximum length of strings</a></td></tr>
<tr><td><code>set_max_array_size</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a>, <a href="engine//book/vnext/start/features.html"><code>no_index</code></a></td><td>sets the maximum size for <a href="engine//book/vnext/language/arrays.html">arrays</a>See <a href="engine//book/vnext/safety/max-array-size.html">maximum size of arrays</a></td></tr>
<tr><td><code>set_max_map_size</code></td><td><a href="engine//book/vnext/start/features.html"><code>unchecked</code></a>, <a href="engine//book/vnext/start/features.html"><code>no_object</code></a></td><td>sets the maximum number of properties for <a href="engine//book/vnext/language/object-maps.html">object maps</a>See <a href="engine//book/vnext/safety/max-map-size.html">maximum size of object maps</a></td></tr>
<tr><td><code>disable_symbol</code></td><td></td><td>disables a certain keyword or operatorSee <a href="engine//book/vnext/engine/disable.html">disable keywords and operators</a></td></tr>
</tbody></table>
<h1><a class="header" href="#extend-rhai-with-rust" id="extend-rhai-with-rust">Extend Rhai with Rust</a></h1>
<p>Most features and functionalities required by a Rhai script should actually be coded in Rust,
which leverages the superior native run-time speed.</p>
<p>This section discusses how to extend Rhai with functionalities written in Rust.</p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<p>A number of traits, under the <code>rhai::</code> module namespace, provide additional functionalities.</p>
<table><thead><tr><th>Trait</th><th>Description</th><th>Methods</th></tr></thead><tbody>
<tr><td><code>RegisterFn</code></td><td>trait for registering functions</td><td><code>register_fn</code></td></tr>
<tr><td><code>RegisterResultFn</code></td><td>trait for registering <a href="rust//book/vnext/rust/fallible.html">fallible functions</a></td><td><code>register_result_fn</code></td></tr>
<tr><td><code>Func</code></td><td>trait for creating Rust closures from script</td><td><code>create_from_ast</code>, <code>create_from_script</code></td></tr>
<tr><td><code>ModuleResolver</code></td><td>trait implemented by <a href="rust//book/vnext/rust/modules/resolvers.html">module resolution</a> services</td><td><code>resolve</code>, <code>resolve_ast</code></td></tr>
<tr><td><code>plugin::PluginFunction</code></td><td>trait implemented by <a href="rust//book/vnext/plugins/index.html">plugin</a> functions</td><td><code>call</code>, <code>is_method_call</code>, <code>is_variadic</code>, <code>clone_boxed</code>, <code>input_names</code>, <code>input_types</code>, <code>return_type</code></td></tr>
</tbody></table>
<h1><a class="header" href="#register-a-rust-function" id="register-a-rust-function">Register a Rust Function</a></h1>
<p>Rhai’s scripting engine is very lightweight.  It gets most of its abilities from functions.</p>
<p>To call these functions, they need to be <em>registered</em> with the <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a> using <code>Engine::register_fn</code>
(in the <code>RegisterFn</code> trait) and <code>Engine::register_result_fn</code> (in the <code>RegisterResultFn</code> trait,
see <a href="rust//book/vnext/rust/fallible.html">fallible functions</a>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Engine, EvalAltResult, ImmutableString};
use rhai::RegisterFn;                       // use 'RegisterFn' trait for 'register_fn'
use rhai::RegisterResultFn;                 // use 'RegisterResultFn' trait for 'register_result_fn'

// Normal function that returns a standard type
// Remember to use 'ImmutableString' and not 'String'
fn add_len(x: i64, s: ImmutableString) -&gt; i64 {
    x + s.len()
}
// Alternatively, '&amp;str' maps directly to 'ImmutableString'
fn add_len_str(x: i64, s: &amp;str) -&gt; i64 {
    x + s.len()
}

// Function that returns a 'Dynamic' value - must return a 'Result'
fn get_any_value() -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    Ok((42_i64).into())                     // standard types can use 'into()'
}

let mut engine = Engine::new();

engine
    .register_fn(&quot;add&quot;, add_len)
    .register_fn(&quot;add_str&quot;, add_len_str);

let result = engine.eval::&lt;i64&gt;(r#&quot;add(40, &quot;xx&quot;)&quot;#)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42

let result = engine.eval::&lt;i64&gt;(r#&quot;add_str(40, &quot;xx&quot;)&quot;#)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42

// Functions that return Dynamic values must use register_result_fn()
engine.register_result_fn(&quot;get_any_value&quot;, get_any_value);

let result = engine.eval::&lt;i64&gt;(&quot;get_any_value()&quot;)?;

println!(&quot;Answer: {}&quot;, result);             // prints 42
<span class="boring">}
</span></code></pre></pre>
<p>To create a <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> value, use the <code>Dynamic::from</code> method.
<a href="rust//book/vnext/language/values-and-types.html">Standard types</a> in Rhai can also use <code>into()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::Dynamic;

let x = (42_i64).into();                        // 'into()' works for standard types

let y = Dynamic::from(&quot;hello!&quot;.to_string());    // remember &amp;str is not supported by Rhai
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#function-overloading" id="function-overloading">Function Overloading</a></h2>
<p>Functions registered with the <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a> can be <em>overloaded</em> as long as the <em>signature</em> is unique,
i.e. different functions can have the same name as long as their parameters are of different types
or different number.</p>
<p>New definitions <em>overwrite</em> previous definitions of the same name and same number/types of parameters.</p>
<h1><a class="header" href="#string-parameters-in-rust-functions" id="string-parameters-in-rust-functions"><code>String</code> Parameters in Rust Functions</a></h1>
<h2><a class="header" href="#avoid-string" id="avoid-string">Avoid <code>String</code></a></h2>
<p>As must as possible, avoid using <code>String</code> parameters in functions.</p>
<p>Each <code>String</code> argument is cloned during every single call to that function – and the copy
immediately thrown away right after the call.</p>
<p>Needless to say, it is <em>extremely</em> inefficient to use <code>String</code> parameters.</p>
<h2><a class="header" href="#str-maps-to-immutablestring" id="str-maps-to-immutablestring"><code>&amp;str</code> Maps to <code>ImmutableString</code></a></h2>
<p>Rust functions accepting parameters of <code>String</code> should use <code>&amp;str</code> instead because it maps directly to
<a href="rust//book/vnext/language/strings-chars.html"><code>ImmutableString</code></a> which is the type that Rhai uses to represent <a href="rust//book/vnext/language/strings-chars.html">strings</a> internally.</p>
<p>The parameter type <code>String</code> involves always converting an <a href="rust//book/vnext/language/strings-chars.html"><code>ImmutableString</code></a> into a <code>String</code>
which mandates cloning it.</p>
<p>Using <code>ImmutableString</code> or <code>&amp;str</code> is much more efficient.
A common mistake made by novice Rhai users is to register functions with <code>String</code> parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_len1(s: String) -&gt; i64 { s.len() as i64 }            // &lt;- Very inefficient!!!
fn get_len2(s: &amp;str) -&gt; i64 { s.len() as i64 }              // &lt;- This is better
fn get_len3(s: ImmutableString) -&gt; i64 { s.len() as i64 }   // &lt;- the above is equivalent to this

engine
    .register_fn(&quot;len1&quot;, get_len1)
    .register_fn(&quot;len2&quot;, get_len2)
    .register_fn(&quot;len3&quot;, get_len3);

let len = engine.eval::&lt;i64&gt;(&quot;x.len1()&quot;)?;                  // 'x' is cloned, very inefficient!
let len = engine.eval::&lt;i64&gt;(&quot;x.len2()&quot;)?;                  // 'x' is shared
let len = engine.eval::&lt;i64&gt;(&quot;x.len3()&quot;)?;                  // 'x' is shared
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#register-a-generic-rust-function" id="register-a-generic-rust-function">Register a Generic Rust Function</a></h1>
<p>Rust generic functions can be used in Rhai, but separate instances for each concrete type must be registered separately.</p>
<p>This essentially <em>overloads</em> the function with different parameter types as Rhai does not natively support generics
but Rhai does support <em>function overloading</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

use rhai::{Engine, RegisterFn};

fn show_it&lt;T: Display&gt;(x: &amp;mut T) {
    println!(&quot;put up a good show: {}!&quot;, x)
}

let mut engine = Engine::new();

engine
    .register_fn(&quot;print&quot;, show_it::&lt;i64&gt;)
    .register_fn(&quot;print&quot;, show_it::&lt;bool&gt;)
    .register_fn(&quot;print&quot;, show_it::&lt;ImmutableString&gt;);
<span class="boring">}
</span></code></pre></pre>
<p>The above example shows how to register multiple functions
(or, in this case, multiple overloaded versions of the same function)
under the same name.</p>
<h1><a class="header" href="#register-a-fallible-rust-function" id="register-a-fallible-rust-function">Register a Fallible Rust Function</a></h1>
<p>If a function is <em>fallible</em> (i.e. it returns a <code>Result&lt;_, Error&gt;</code>), it can be registered with <code>register_result_fn</code>
(using the <code>RegisterResultFn</code> trait).</p>
<p>The function must return <code>Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult, Position};
use rhai::RegisterResultFn;                     // use 'RegisterResultFn' trait for 'register_result_fn'

// Function that may fail - the result type must be 'Dynamic'
fn safe_divide(x: i64, y: i64) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    if y == 0 {
        // Return an error if y is zero
        Err(&quot;Division by zero!&quot;.into())         // shortcut to create Box&lt;EvalAltResult::ErrorRuntime&gt;
    } else {
        Ok((x / y).into())                      // convert result into 'Dynamic'
    }
}

let mut engine = Engine::new();

// Fallible functions that return Result values must use register_result_fn()
engine.register_result_fn(&quot;divide&quot;, safe_divide);

if let Err(error) = engine.eval::&lt;i64&gt;(&quot;divide(40, 0)&quot;) {
    println!(&quot;Error: {:?}&quot;, *error);         // prints ErrorRuntime(&quot;Division by zero detected!&quot;, (1, 1)&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#create-a-boxevalaltresult" id="create-a-boxevalaltresult">Create a <code>Box&lt;EvalAltResult&gt;</code></a></h2>
<p><code>Box&lt;EvalAltResult&gt;</code> implements <code>From&lt;&amp;str&gt;</code> and <code>From&lt;String&gt;</code> etc.
and the error text gets converted into <code>Box&lt;EvalAltResult::ErrorRuntime&gt;</code>.</p>
<p>The error values are <code>Box</code>-ed in order to reduce memory footprint of the error path, which should be hit rarely.</p>
<h1><a class="header" href="#override-a-built-in-function" id="override-a-built-in-function">Override a Built-in Function</a></h1>
<p>Any similarly-named function defined in a script <em>overrides</em> any built-in or registered
native Rust function of the same name and number of parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Override the built-in function 'to_float' when called as a method
fn to_float() {
    print(&quot;Ha! Gotcha! &quot; + this);
    42.0
}

let x = 123.to_float();

print(x);       // what happens?
<span class="boring">}
</span></code></pre></pre>
<p>A registered native Rust function, in turn, overrides any built-in function of the
same name, number and types of parameters.</p>
<h1><a class="header" href="#operator-overloading" id="operator-overloading">Operator Overloading</a></h1>
<p>In Rhai, a lot of functionalities are actually implemented as functions, including basic operations
such as arithmetic calculations.</p>
<p>For example, in the expression “<code>a + b</code>“, the <code>+</code> operator calls a function named “<code>+</code>“!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = a + b;

let x = +(a, b);        // &lt;- the above is equivalent to this function call
<span class="boring">}
</span></code></pre></pre>
<p>Similarly, comparison operators including <code>==</code>, <code>!=</code> etc. are all implemented as functions,
with the stark exception of <code>&amp;&amp;</code> and <code>||</code>.</p>
<h2><a class="header" href="#and--cannot-be-overloaded" id="and--cannot-be-overloaded"><code>&amp;&amp;</code> and <code>||</code> Cannot Be Overloaded</a></h2>
<p>Because they <a href="rust//book/vnext/language/logic.html#boolean-operators"><em>short-circuit</em></a>, <code>&amp;&amp;</code> and <code>||</code> are
handled specially and <em>not</em> via a function; as a result, overriding them has no effect at all.</p>
<h2><a class="header" href="#overload-operator-via-rust-function" id="overload-operator-via-rust-function">Overload Operator via Rust Function</a></h2>
<p>Operator functions cannot be defined as a script function (because operators syntax are not valid function names).</p>
<p>However, operator functions <em>can</em> be registered to the <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a> via the methods
<code>Engine::register_fn</code>, <code>Engine::register_result_fn</code> etc.</p>
<p>When a custom operator function is registered with the same name as an operator, it <em>overrides</em> the built-in version.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult, RegisterFn};

let mut engine = Engine::new();

fn strange_add(a: i64, b: i64) -&gt; i64 { (a + b) * 42 }

engine.register_fn(&quot;+&quot;, strange_add);               // overload '+' operator for two integers!

let result: i64 = engine.eval(&quot;1 + 0&quot;);             // the overloading version is used

result == 42;

let result: f64 = engine.eval(&quot;1.0 + 0.0&quot;);         // '+' operator for two floats not overloaded

result == 1.0;

fn mixed_add(a: i64, b: f64) -&gt; f64 { (a as f64) + b }

engine.register_fn(&quot;+&quot;, mixed_add);                 // register '+' operator for an integer and a float

let result: i64 = engine.eval(&quot;1 + 1.0&quot;);           // &lt;- normally an error...

result == 2.0;                                      //    ... but not now
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#considerations" id="considerations">Considerations</a></h2>
<p>Normally, use operator overloading for <a href="rust//book/vnext/rust/custom.html">custom types</a> only.</p>
<p>Be very careful when overriding built-in operators because script authors expect standard operators to behave in a
consistent and predictable manner, and will be annoyed if a calculation for ‘<code>+</code>‘ turns into a subtraction, for example.</p>
<p>Operator overloading also impacts script optimization when using <a href="rust//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>.
See the [script-optimization] for more details.</p>
<h1><a class="header" href="#register-any-rust-type-and-its-methods" id="register-any-rust-type-and-its-methods">Register any Rust Type and its Methods</a></h1>
<h2><a class="header" href="#free-typing" id="free-typing">Free Typing</a></h2>
<p>Rhai works seamlessly with <em>any</em> Rust type.  The type can be <em>anything</em>; it does not
have any prerequisites other than being <code>Clone</code>.  It does not need to implement
any other trait or use any custom <code>#[derive]</code>.</p>
<p>This allows Rhai to be integrated into an existing Rust code base with as little plumbing
as possible, usually silently and seamlessly.  External types that are not defined
within the same crate (and thus cannot implement special Rhai traits or
use special <code>#[derive]</code>) can also be used easily with Rhai.</p>
<p>The reason why it is termed a <em>custom</em> type throughout this documentation is that
Rhai natively supports a number of data types with fast, internal treatment (see
the list of <a href="rust//book/vnext/language/values-and-types.html">standard types</a>).  Any type outside of this list is considered <em>custom</em>.</p>
<p>Any type not supported natively by Rhai is stored as a Rust <em>trait object</em>, with no
restrictions other than being <code>Clone</code> (plus <code>Send + Sync</code> under the <a href="rust//book/vnext/start/features.html"><code>sync</code></a> feature).
It runs slightly slower than natively-supported types as it does not have built-in,
optimized implementations for commonly-used functions, but for all other purposes has
no difference.</p>
<p>Support for custom types can be turned off via the <a href="rust//book/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<h2><a class="header" href="#register-a-custom-type-and-its-methods" id="register-a-custom-type-and-its-methods">Register a Custom Type and its Methods</a></h2>
<p>Any custom type must implement the <code>Clone</code> trait as this allows the <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a> to pass by value.</p>
<p>If the <a href="rust//book/vnext/start/features.html"><code>sync</code></a> feature is used, it must also be <code>Send + Sync</code>.</p>
<p>Notice that the custom type needs to be <em>registered</em> using <code>Engine::register_type</code>
or <code>Engine::register_type_with_name</code>.</p>
<p>To use native methods on custom types in Rhai scripts, it is common to register an API
for the type using one of the <code>Engine::register_XXX</code> functions.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, EvalAltResult};
use rhai::RegisterFn;                   // remember 'RegisterFn' is needed

#[derive(Clone)]
struct TestStruct {
    field: i64
}

impl TestStruct {
    fn new() -&gt; Self {
        Self { field: 1 }
    }

    fn update(&amp;mut self, x: i64) {      // methods take &amp;mut as first parameter
        self.field += x;
    }
}

let mut engine = Engine::new();

// Most Engine API's can be chained up.
engine
    .register_type::&lt;TestStruct&gt;()      // register custom type
    .register_fn(&quot;new_ts&quot;, TestStruct::new)
    .register_fn(&quot;update&quot;, TestStruct::update);

// Cast result back to custom type.
let result = engine.eval::&lt;TestStruct&gt;(
    r&quot;
        let x = new_ts();               // calls 'TestStruct::new'
        x.update(41);                   // calls 'TestStruct::update'
        x                               // 'x' holds a 'TestStruct'
    &quot;
)?;

println!(&quot;result: {}&quot;, result.field);   // prints 42
<span class="boring">}
</span></code></pre></pre>
<p>Rhai follows the convention that methods of custom types take a <code>&amp;mut</code> first parameter
to that type, so that invoking methods can always update it.</p>
<p>All other parameters in Rhai are passed by value (i.e. clones).</p>
<p><strong>IMPORTANT: Rhai does NOT support normal references (i.e. <code>&amp;T</code>) as parameters.</strong></p>
<h2><a class="header" href="#method-call-style-vs-function-call-style" id="method-call-style-vs-function-call-style">Method-Call Style vs. Function-Call Style</a></h2>
<p>Any function with a first argument that is a <code>&amp;mut</code> reference can be used
as method calls because internally they are the same thing: methods on a type is
implemented as a functions taking a <code>&amp;mut</code> first argument.</p>
<p>This design is similar to Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl TestStruct {
    fn foo(&amp;mut self) -&gt; i64 {
        self.field
    }
}

engine.register_fn(&quot;foo&quot;, TestStruct::foo);

let result = engine.eval::&lt;i64&gt;(
    r&quot;
        let x = new_ts();
        foo(x);                         // normal call to 'foo'
        x.foo()                         // 'foo' can also be called like a method on 'x'
    &quot;
)?;

println!(&quot;result: {}&quot;, result);         // prints 1
<span class="boring">}
</span></code></pre></pre>
<p>Under <a href="rust//book/vnext/start/features.html"><code>no_object</code></a>, however, the <em>method</em> style of function calls
(i.e. calling a function as an object-method) is no longer supported.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Below is a syntax error under 'no_object'.
let result = engine.eval(&quot;let x = [1, 2, 3]; x.clear();&quot;)?;
                                            // ^ cannot call in method style under 'no_object'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#type_of-a-custom-type" id="type_of-a-custom-type"><code>type_of()</code> a Custom Type</a></h2>
<p><a href="rust//book/vnext/language/type-of.html"><code>type_of()</code></a> works fine with custom types and returns the name of the type.</p>
<p>If <code>Engine::register_type_with_name</code> is used to register the custom type
with a special “pretty-print” name, <a href="rust//book/vnext/language/type-of.html"><code>type_of()</code></a> will return that name instead.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .register_type::&lt;TestStruct1&gt;()
    .register_fn(&quot;new_ts1&quot;, TestStruct1::new)
    .register_type_with_name::&lt;TestStruct2&gt;(&quot;TestStruct&quot;)
    .register_fn(&quot;new_ts2&quot;, TestStruct2::new);

let ts1_type = engine.eval::&lt;String&gt;(r#&quot;let x = new_ts1(); x.type_of()&quot;#)?;
let ts2_type = engine.eval::&lt;String&gt;(r#&quot;let x = new_ts2(); x.type_of()&quot;#)?;

println!(&quot;{}&quot;, ts1_type);               // prints 'path::to::TestStruct'
println!(&quot;{}&quot;, ts1_type);               // prints 'TestStruct'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-the-custom-type-with-arrays" id="use-the-custom-type-with-arrays">Use the Custom Type With Arrays</a></h2>
<p>The <code>push</code>, <code>insert</code>, <code>pad</code> functions, as well as the <code>+=</code> operator, for <a href="rust//book/vnext/language/arrays.html">arrays</a> are only
defined for standard built-in types. For custom types, type-specific versions must be registered:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .register_fn(&quot;push&quot;, |list: &amp;mut Array, item: TestStruct| {
        list.push(Dynamic::from(item));
    }).register_fn(&quot;+=&quot;, |list: &amp;mut Array, item: TestStruct| {
        list.push(Dynamic::from(item));
    }).register_fn(&quot;insert&quot;, |list: &amp;mut Array, position: i64, item: TestStruct| {
        if position &lt;= 0 {
            list.insert(0, Dynamic::from(item));
        } else if (position as usize) &gt;= list.len() - 1 {
            list.push(item);
        } else {
            list.insert(position as usize, Dynamic::from(item));
        }
    }).register_fn(&quot;pad&quot;, |list: &amp;mut Array, len: i64, item: TestStruct| {
        if len as usize &gt; list.len() {
            list.resize(len as usize, item);
        }
    });
<span class="boring">}
</span></code></pre></pre>
<p>In particular, in order to use the <code>in</code> operator with a custom type for an <a href="rust//book/vnext/language/arrays.html">array</a>,
the <code>==</code> operator must be registered for the custom type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assume 'TestStruct' implements `PartialEq`
engine.register_fn(&quot;==&quot;,
    |item1: &amp;mut TestStruct, item2: TestStruct| item1 == &amp;item2
);

// Then this works in Rhai:
let item = new_ts();        // construct a new 'TestStruct'
item in array;              // 'in' operator uses '=='
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#working-with-enums" id="working-with-enums">Working With Enums</a></h2>
<p>It is quite easy to use Rust enums with Rhai.
See <a href="rust//book/vnext/patterns/enums.html">this chapter</a> for more details.</p>
<h1><a class="header" href="#custom-type-property-getters-and-setters" id="custom-type-property-getters-and-setters">Custom Type Property Getters and Setters</a></h1>
<p>A <a href="rust//book/vnext/rust/custom.html">custom type</a> can also expose properties by registering <code>get</code> and/or <code>set</code> functions.</p>
<p>Getters and setters each take a <code>&amp;mut</code> reference to the first parameter.</p>
<p>Getters and setters are disabled when the <a href="rust//book/vnext/start/features.html"><code>no_object</code></a> feature is used.</p>
<table><thead><tr><th><code>Engine</code> API</th><th>Function signature(s)<br/>(<code>T: Clone</code> = custom type,<br/><code>V: Clone</code> = data type)</th><th align="center">Can mutate <code>T</code>?</th></tr></thead><tbody>
<tr><td><code>register_get</code></td><td><code>Fn(&amp;mut T) -&gt; V</code></td><td align="center">yes, but not advised</td></tr>
<tr><td><code>register_set</code></td><td><code>Fn(&amp;mut T, V)</code></td><td align="center">yes</td></tr>
<tr><td><code>register_get_set</code></td><td>getter: <code>Fn(&amp;mut T) -&gt; V</code></br>setter: <code>Fn(&amp;mut T, V)</code></td><td align="center">yes, but not advised in getter</td></tr>
<tr><td><code>register_get_result</code></td><td><code>Fn(&amp;mut T) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></td><td align="center">yes, but not advised</td></tr>
<tr><td><code>register_set_result</code></td><td><code>Fn(&amp;mut T, V) -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;</code></td><td align="center">yes</td></tr>
</tbody></table>
<p>By convention, property getters are not supposed to mutate the <a href="rust//book/vnext/rust/custom.html">custom type</a>, although there is nothing
that prevents this mutation.</p>
<h2><a class="header" href="#cannot-override-object-maps" id="cannot-override-object-maps">Cannot Override Object Maps</a></h2>
<p>Property getters and setters are mainly intended for <a href="rust//book/vnext/rust/custom.html">custom types</a>.</p>
<p>Any getter or setter function registered for <a href="rust//book/vnext/language/object-maps.html">object maps</a> is simply <em>ignored</em> because
the get/set calls will be interpreted as properties on the <a href="rust//book/vnext/language/object-maps.html">object maps</a>.</p>
<h2><a class="header" href="#examples-1" id="examples-1">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct TestStruct {
    field: String
}

impl TestStruct {
    // Remember &amp;mut must be used even for getters
    fn get_field(&amp;mut self) -&gt; String {
        self.field.clone()
    }

    fn set_field(&amp;mut self, new_val: &amp;str) {
        self.field = new_val.to_string();
    }

    fn new() -&gt; Self {
        Self { field: &quot;hello&quot; }
    }
}

let mut engine = Engine::new();

engine
    .register_type::&lt;TestStruct&gt;()
    .register_get_set(&quot;xyz&quot;, TestStruct::get_field, TestStruct::set_field)
    .register_fn(&quot;new_ts&quot;, TestStruct::new);

let result = engine.eval::&lt;String&gt;(r#&quot;let a = new_ts(); a.xyz = &quot;42&quot;; a.xyz&quot;#)?;

println!(&quot;Answer: {}&quot;, result);                     // prints 42
<span class="boring">}
</span></code></pre></pre>
<p><strong>IMPORTANT: Rhai does NOT support normal references (i.e. <code>&amp;T</code>) as parameters.</strong></p>
<h1><a class="header" href="#custom-type-indexers" id="custom-type-indexers">Custom Type Indexers</a></h1>
<p>A <a href="rust//book/vnext/rust/custom.html">custom type</a> can also expose an <em>indexer</em> by registering an indexer function.</p>
<p>A <a href="rust//book/vnext/rust/custom.html">custom type</a> with an indexer function defined can use the bracket notation to get a property value:</p>
<blockquote>
<p><em>object</em> <code>[</code> <em>index</em> <code>]</code></p>
</blockquote>
<p>Like property <a href="rust//book/vnext/rust/getters-setters.html">getters/setters</a>, indexers take a <code>&amp;mut</code> reference to the first parameter.</p>
<p>They also take an additional parameter of any type that serves as the <em>index</em> within brackets.</p>
<p>Indexers are disabled when the <a href="rust//book/vnext/start/features.html"><code>no_index</code></a> feature is used.</p>
<table><thead><tr><th><code>Engine</code> API</th><th>Function signature(s)<br/>(<code>T: Clone</code> = custom type,<br/><code>X: Clone</code> = index type,<br/><code>V: Clone</code> = data type)</th><th align="center">Can mutate <code>T</code>?</th></tr></thead><tbody>
<tr><td><code>register_indexer_get</code></td><td><code>Fn(&amp;mut T, X) -&gt; V</code></td><td align="center">yes, but not advised</td></tr>
<tr><td><code>register_indexer_set</code></td><td><code>Fn(&amp;mut T, X, V)</code></td><td align="center">yes</td></tr>
<tr><td><code>register_indexer_get_set</code></td><td>getter: <code>Fn(&amp;mut T, X) -&gt; V</code><br/>setter: <code>Fn(&amp;mut T, X, V)</code></td><td align="center">yes, but not advised in getter</td></tr>
<tr><td><code>register_indexer_get_result</code></td><td><code>Fn(&amp;mut T, X) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></td><td align="center">yes, but not advised</td></tr>
<tr><td><code>register_indexer_set_result</code></td><td><code>Fn(&amp;mut T, X, V) -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt;</code></td><td align="center">yes</td></tr>
</tbody></table>
<p>By convention, index getters are not supposed to mutate the <a href="rust//book/vnext/rust/custom.html">custom type</a>, although there is nothing
that prevents this mutation.</p>
<p><strong>IMPORTANT: Rhai does NOT support normal references (i.e. <code>&amp;T</code>) as parameters.</strong></p>
<h2><a class="header" href="#cannot-override-arrays-object-maps-and-strings" id="cannot-override-arrays-object-maps-and-strings">Cannot Override Arrays, Object Maps and Strings</a></h2>
<p>For efficiency reasons, indexers <strong>cannot</strong> be used to overload (i.e. override)
built-in indexing operations for <a href="rust//book/vnext/language/arrays.html">arrays</a>, <a href="rust//book/vnext/language/object-maps.html">object maps</a> and <a href="rust//book/vnext/language/strings-chars.html">strings</a>.</p>
<p>Attempting to register indexers for an <a href="rust//book/vnext/language/arrays.html">array</a>, <a href="rust//book/vnext/language/object-maps.html">object map</a> or <a href="rust//book/vnext/language/strings-chars.html">string</a> panics.</p>
<h2><a class="header" href="#examples-2" id="examples-2">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct TestStruct {
    fields: Vec&lt;i64&gt;
}

impl TestStruct {
    // Remember &amp;mut must be used even for getters
    fn get_field(&amp;mut self, index: String) -&gt; i64 {
        self.fields[index.len()]
    }
    fn set_field(&amp;mut self, index: String, value: i64) {
        self.fields[index.len()] = value
    }

    fn new() -&gt; Self {
        Self { fields: vec![1, 2, 3, 4, 5] }
    }
}

let mut engine = Engine::new();

engine
    .register_type::&lt;TestStruct&gt;()
    .register_fn(&quot;new_ts&quot;, TestStruct::new)
    // Short-hand: .register_indexer_get_set(TestStruct::get_field, TestStruct::set_field);
    .register_indexer_get(TestStruct::get_field)
    .register_indexer_set(TestStruct::set_field);

let result = engine.eval::&lt;i64&gt;(
                r#&quot;
                    let a = new_ts();
                    a[&quot;xyz&quot;] = 42;                  // these indexers use strings
                    a[&quot;xyz&quot;]                        // as the index type
                &quot;#
)?;

println!(&quot;Answer: {}&quot;, result);                     // prints 42
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#disable-custom-types" id="disable-custom-types">Disable Custom Types</a></h1>
<h2><a class="header" href="#no_object-feature" id="no_object-feature"><code>no_object</code> Feature</a></h2>
<p>The custom types API <code>register_type</code>, <code>register_type_with_name</code>, <code>register_get</code>, <code>register_get_result</code>,
<code>register_set</code>, <code>register_set_result</code> and <code>register_get_set</code> are not available under <a href="rust//book/vnext/start/features.html"><code>no_object</code></a>.</p>
<h2><a class="header" href="#no_index-feature" id="no_index-feature"><code>no_index</code> Feature</a></h2>
<p>The indexers API <code>register_indexer_get</code>, <code>register_indexer_get_result</code>, <code>register_indexer_set</code>,
<code>register_indexer_set_result</code>, and <code>register_indexer_get_set</code> are also not available under <a href="rust//book/vnext/start/features.html"><code>no_index</code></a>.</p>
<h1><a class="header" href="#printing-for-custom-types" id="printing-for-custom-types">Printing for Custom Types</a></h1>
<p>To use custom types for <a href="rust//book/vnext/language/print-debug.html"><code>print</code></a> and <a href="rust//book/vnext/language/print-debug.html"><code>debug</code></a>, or convert its value into a <a href="rust//book/vnext/language/strings-chars.html">string</a>,
it is necessary that the following functions be registered (assuming the custom type
is <code>T: Display + Debug</code>):</p>
<table><thead><tr><th>Function</th><th>Signature</th><th>Typical implementation</th><th>Usage</th></tr></thead><tbody>
<tr><td><code>to_string</code></td><td><code>|x: &amp;mut T| -&gt; String</code></td><td><code>x.to_string()</code></td><td>converts the custom type into a <a href="rust//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><code>print</code></td><td><code>|x: &amp;mut T| -&gt; String</code></td><td><code>x.to_string()</code></td><td>converts the custom type into a <a href="rust//book/vnext/language/strings-chars.html">string</a> for the <a href="rust//book/vnext/language/print-debug.html"><code>print</code></a> statement</td></tr>
<tr><td><code>to_debug</code></td><td><code>|x: &amp;mut T| -&gt; String</code></td><td><code>format!(&quot;{:?}&quot;, x)</code></td><td>converts the custom type into a <a href="rust//book/vnext/language/strings-chars.html">string</a> in debug format</td></tr>
<tr><td><code>debug</code></td><td><code>|x: &amp;mut T| -&gt; String</code></td><td><code>format!(&quot;{:?}&quot;, x)</code></td><td>converts the custom type into a <a href="rust//book/vnext/language/strings-chars.html">string</a> for the <a href="rust//book/vnext/language/print-debug.html"><code>debug</code></a> statement</td></tr>
<tr><td><code>+</code></td><td><code>|s: &amp;str, x: T| -&gt; String</code></td><td><code>format!(&quot;{}{}&quot;, s, x)</code></td><td>concatenates the custom type with another <a href="rust//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><code>+</code></td><td><code>|x: &amp;mut T, s: &amp;str| -&gt; String</code></td><td><code>x.to_string().push_str(s);</code></td><td>concatenates another <a href="rust//book/vnext/language/strings-chars.html">string</a> with the custom type</td></tr>
<tr><td><code>+=</code></td><td><code>|s: &amp;mut ImmutableString, x: T|</code></td><td><code>s += x.to_string()</code></td><td>appends the custom type to an existing <a href="rust//book/vnext/language/strings-chars.html">string</a></td></tr>
</tbody></table>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>Rhai allows organizing functionalities (functions, both Rust-based or script-based, and variables)
into independent <em>modules</em>. Modules can be disabled via the <a href="rust/modules//book/vnext/start/features.html"><code>no_module</code></a> feature.</p>
<p>A module is of the type <code>Module</code> and holds a collection of functions, variables,
<a href="rust/modules//book/vnext/language/iterator.html">type iterators</a> and sub-modules.</p>
<p>It may be created entirely from Rust functions, or it may encapsulate a Rhai script together
with the functions and variables defined by that script.</p>
<p>Other scripts can then load this module and use the functions and variables exported
as if they were defined inside the same script.</p>
<p>Alternatively, modules can be registered directly into an <a href="rust/modules//book/vnext/engine/hello-world.html"><code>Engine</code></a> and made available
to scripts either globally or under individual static module <a href="rust/modules//book/vnext/language/fn-namespaces.html"><em>namespaces</em></a>.</p>
<h2><a class="header" href="#usage-patterns" id="usage-patterns">Usage Patterns</a></h2>
<table><thead><tr><th>Usage</th><th align="center">API</th><th align="center">Lookup</th><th align="center">Sub-modules?</th><th align="center">Variables?</th></tr></thead><tbody>
<tr><td>Global module</td><td align="center"><code>Engine:: register_global_module</code></td><td align="center">simple name</td><td align="center">ignored</td><td align="center">ignored</td></tr>
<tr><td>Static module</td><td align="center"><code>Engine:: register_static_module</code></td><td align="center">namespace-qualified name</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td>Dynamic module</td><td align="center"><a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statement</td><td align="center">namespace-qualified name</td><td align="center">yes</td><td align="center">yes</td></tr>
</tbody></table>
<h1><a class="header" href="#create-a-module-from-rust" id="create-a-module-from-rust">Create a Module from Rust</a></h1>
<h2><a class="header" href="#create-via-plugin" id="create-via-plugin">Create via Plugin</a></h2>
<p>By far the simplest way to create a <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> is via a <a href="rust/modules//book/vnext/plugins/module.html">plugin module</a>
which converts a normal Rust module into a Rhai <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> via procedural macros.</p>
<h2><a class="header" href="#create-via-module-api" id="create-via-module-api">Create via <code>Module</code> API</a></h2>
<p>Manually creating a <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> is possible via the <code>Module</code> API.</p>
<p>For the complete <code>Module</code> API, refer to the <a href="https://docs.rs/rhai/0.19.11/rhai/struct.Module.html">documentation</a> online.</p>
<h2><a class="header" href="#use-case-1--make-the-module-globally-available" id="use-case-1--make-the-module-globally-available">Use Case 1 – Make the <code>Module</code> Globally Available</a></h2>
<p><code>Engine::register_global_module</code> registers a shared <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> into the <em>global</em> namespace.</p>
<p>All <a href="rust/modules//book/vnext/language/functions.html">functions</a> and <a href="rust/modules//book/vnext/language/iterator.html">type iterators</a> can be accessed without <em>namespace qualifiers</em>.
Variables and sub-modules are <strong>ignored</strong>.</p>
<p>This is by far the easiest way to expose a module’s functionalities to Rhai.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module};

let mut module = Module::new();             // new module

// Use the 'Module::set_fn_XXX' API to add functions.
let hash = module.set_fn_1(&quot;inc&quot;, |x: i64| Ok(x + 1));

// Remember to update the parameter names/types and return type metadata.
// 'Module::set_fn_XXX' by default does not set function metadata.
module.update_fn_metadata(hash, [&quot;x: i64&quot;, &quot;i64&quot;]);

// Register the module into the global namespace of the Engine.
let mut engine = Engine::new();
engine.register_global_module(module.into());

engine.eval::&lt;i64&gt;(&quot;inc(41)&quot;)? == 42;       // no need to import module
<span class="boring">}
</span></code></pre></pre>
<p>Registering a <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> via <code>Engine::register_global_module</code> is essentially the <em>same</em>
as calling <code>Engine::register_fn</code> (or any of the <code>Engine::register_XXX</code> API) individually
on each top-level function within that <a href="rust/modules//book/vnext/rust/modules/index.html">module</a>.  In fact, the actual implementation of
<code>Engine::register_fn</code> etc. simply adds the function to an internal <a href="rust/modules//book/vnext/rust/modules/index.html">module</a>!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The above is essentially the same as:
let mut engine = Engine::new();

engine.register_fn(&quot;inc&quot;, |x: i64| x + 1);

engine.eval::&lt;i64&gt;(&quot;inc(41)&quot;)? == 42;       // no need to import module
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-case-2--make-the-module-a-static-module" id="use-case-2--make-the-module-a-static-module">Use Case 2 – Make the <code>Module</code> a Static Module</a></h2>
<p><code>Engine::register_static_module</code> registers a <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> and under a specific module namespace.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module};

let mut module = Module::new();             // new module

// Use the 'Module::set_fn_XXX' API to add functions.
let hash = module.set_fn_1(&quot;inc&quot;, |x: i64| Ok(x + 1));

// Remember to update the parameter names/types and return type metadata.
// 'Module::set_fn_XXX' by default does not set function metadata.
module.update_fn_metadata(hash, [&quot;x: i64&quot;, &quot;i64&quot;]);

// Register the module into the Engine as the static module namespace path
// 'services::calc'
let mut engine = Engine::new();
engine.register_static_module(&quot;services::calc&quot;, module.into());

// refer to the 'services::calc' module
engine.eval::&lt;i64&gt;(&quot;services::calc::inc(41)&quot;)? == 42;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#expose-functions-to-the-global-namespace" id="expose-functions-to-the-global-namespace">Expose Functions to the Global Namespace</a></h3>
<p>The <code>Module::set_fn_XXX_mut</code> API methods can optionally expose functions in the <a href="rust/modules//book/vnext/rust/modules/index.html">module</a>
to the <em>global</em> namespace by setting the <code>namespace</code> parameter to <code>FnNamespace::Global</code>,
so <a href="rust/modules//book/vnext/rust/getters-setters.html">getters/setters</a> and <a href="rust/modules//book/vnext/rust/indexers.html">indexers</a> for <a href="rust/modules//book/vnext/rust/custom.html">custom types</a> can work as expected.</p>
<p><a href="rust/modules//book/vnext/language/iterator.html">Type iterators</a>, because of their special nature, are <em>always</em> exposed to the <em>global</em> namespace.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module, FnNamespace};

let mut module = Module::new();             // new module

// Expose method 'inc' to the global namespace (default is 'FnNamespace::Internal')
let hash = module.set_fn_1_mut(&quot;inc&quot;, FnNamespace::Global, |x: &amp;mut i64| Ok(x + 1));

// Remember to update the parameter names/types and return type metadata.
// 'Module::set_fn_XXX_mut' by default does not set function metadata.
module.update_fn_metadata(hash, [&quot;x: &amp;mut i64&quot;, &quot;i64&quot;]);

// Register the module into the Engine as a static module namespace 'calc'
let mut engine = Engine::new();
engine.register_static_module(&quot;calc&quot;, module.into());

// 'inc' works when qualified by the namespace
engine.eval::&lt;i64&gt;(&quot;calc::inc(41)&quot;)? == 42;

// 'inc' also works without a namespace qualifier
// because it is exposed to the global namespace
engine.eval::&lt;i64&gt;(&quot;let x = 41; x.inc()&quot;)? == 42;
engine.eval::&lt;i64&gt;(&quot;let x = 41; inc(x)&quot;)? == 42;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-case-3--make-the-module-dynamically-loadable" id="use-case-3--make-the-module-dynamically-loadable">Use Case 3 – Make the <code>Module</code> Dynamically Loadable</a></h2>
<p>In order to dynamically load a custom module, there must be a <a href="rust/modules//book/vnext/rust/modules/resolvers.html">module resolver</a> which serves
the module when loaded via <code>import</code> statements.</p>
<p>The easiest way is to use, for example, the <a href="rust/modules//book/vnext/rust/modules/resolvers.html"><code>StaticModuleResolver</code></a> to hold such
a custom module.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, Module};
use rhai::module_resolvers::StaticModuleResolver;

let mut module = Module::new();             // new module
module.set_var(&quot;answer&quot;, 41_i64);           // variable 'answer' under module
module.set_fn_1(&quot;inc&quot;, |x: i64| Ok(x + 1)); // use the 'set_fn_XXX' API to add functions

// Create the module resolver
let mut resolver = StaticModuleResolver::new();

// Add the module into the module resolver under the name 'question'
// They module can then be accessed via: 'import &quot;question&quot; as q;'
resolver.insert(&quot;question&quot;, module);

// Set the module resolver into the 'Engine'
let mut engine = Engine::new();
engine.set_module_resolver(resolver);

// Use namespace-qualified variables
engine.eval::&lt;i64&gt;(r#&quot;import &quot;question&quot; as q; q::answer + 1&quot;#)? == 42;

// Call namespace-qualified functions
engine.eval::&lt;i64&gt;(r#&quot;import &quot;question&quot; as q; q::inc(q::answer)&quot;#)? == 42;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-module-from-an-ast" id="create-a-module-from-an-ast">Create a Module from an AST</a></h1>
<h2><a class="header" href="#moduleeval_ast_as_new" id="moduleeval_ast_as_new"><code>Module::eval_ast_as_new</code></a></h2>
<p>A <a href="rust/modules//book/vnext/rust/modules/index.html">module</a> can be created from a single script (or pre-compiled <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a>) containing global variables,
functions and sub-modules via the <code>Module::eval_ast_as_new</code> method.</p>
<p>See the section on <a href="rust/modules//book/vnext/language/modules/export.html"><em>Exporting Variables, Functions and Sub-Modules</em></a> for details on how to
prepare a Rhai script for this purpose as well as to control which functions/variables to export.</p>
<p>When given an <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a>, it is first evaluated, then the following items are exposed as members of the
new <a href="rust/modules//book/vnext/rust/modules/index.html">module</a>:</p>
<ul>
<li>
<p>Global variables – all variables exported via the <code>export</code> statement (those not exported remain hidden).</p>
</li>
<li>
<p>Functions not specifically marked <code>private</code>.</p>
</li>
<li>
<p>Global modules that remain in the <a href="rust/modules//book/vnext/engine/scope.html"><code>Scope</code></a> at the end of a script run (become sub-modules).</p>
</li>
</ul>
<p><code>Module::eval_ast_as_new</code> encapsulates the entire <code>AST</code> into each function call, merging the
module namespace with the global namespace.  Therefore, functions defined within the same module
script can cross-call each other.</p>
<h2><a class="header" href="#examples-3" id="examples-3">Examples</a></h2>
<p>Don’t forget the <a href="rust/modules//book/vnext/language/modules/export.html"><code>export</code></a> statement, otherwise there will be no variables exposed by the module
other than non-<a href="rust/modules//book/vnext/engine/call-fn.html"><code>private</code></a> functions (unless that’s intentional).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module};

let engine = Engine::new();

// Compile a script into an 'AST'
let ast = engine.compile(r#&quot;
    // Functions become module functions
    fn calc(x) {
        x + 1
    }
    fn add_len(x, y) {
        x + y.len
    }

    // Imported modules can become sub-modules
    import &quot;another module&quot; as extra;

    // Variables defined at global level can become module variables
    const x = 123;
    let foo = 41;
    let hello;

    // Variable values become constant module variable values
    foo = calc(foo);
    hello = &quot;hello, &quot; + foo + &quot; worlds!&quot;;

    // Finally, export the variables and modules
    export
        x as abc,           // aliased variable name
        foo,
        hello,
        extra as foobar;    // export sub-module
&quot;#)?;

// Convert the 'AST' into a module, using the 'Engine' to evaluate it first
// A copy of the entire 'AST' is encapsulated into each function,
// allowing functions in the module script to cross-call each other.
let module = Module::eval_ast_as_new(Scope::new(), &amp;ast, &amp;engine)?;

// 'module' now contains:
//   - sub-module: 'foobar' (renamed from 'extra')
//   - functions: 'calc', 'add_len'
//   - constants: 'abc' (renamed from 'x'), 'foo', 'hello'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#module-resolvers" id="module-resolvers">Module Resolvers</a></h1>
<p>When encountering an <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statement, Rhai attempts to <em>resolve</em> the module based on the path string.</p>
<p>See the section on <a href="rust/modules//book/vnext/language/modules/import.html"><em>Importing Modules</em></a> for more details.</p>
<p><em>Module Resolvers</em> are service types that implement the <a href="rust/modules//book/vnext/rust/traits.html"><code>ModuleResolver</code></a> trait.</p>
<h2><a class="header" href="#built-in-module-resolvers" id="built-in-module-resolvers">Built-In Module Resolvers</a></h2>
<p>There are a number of standard resolvers built into Rhai, the default being the <code>FileModuleResolver</code>
which simply loads a script file based on the path (with <code>.rhai</code> extension attached)
and execute it to form a module.</p>
<p>Built-in module resolvers are grouped under the <code>rhai::module_resolvers</code> module namespace.</p>
<h2><a class="header" href="#filemoduleresolver-default" id="filemoduleresolver-default"><code>FileModuleResolver</code> (default)</a></h2>
<p>The <em>default</em> module resolution service, not available for <a href="rust/modules//book/vnext/start/features.html"><code>no_std</code></a> or <a href="rust/modules//book/vnext/start/builds/wasm.html">WASM</a> builds.
Loads a script file (based off the current directory) with <code>.rhai</code> extension.</p>
<p>All functions in the <em>global</em> namespace, plus all those defined in the same module,
are <em>merged</em> into a <em>unified</em> namespace.</p>
<p>All modules imported at <em>global</em> level via <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statements become sub-modules,
which are also available to functions defined within the same script file.</p>
<p>Modules are also <em>cached</em> so a script file is only evaluated <em>once</em>, even when repeatedly imported.</p>
<pre><pre class="playground"><code class="language-rust">------------------
| my_module.rhai |
------------------

// This function overrides any in the main script.
private fn inner_message() { &quot;hello! from module!&quot; }

fn greet() {
    print(inner_message());     // call function in module script
}

fn greet_main() {
    print(main_message());      // call function not in module script
}

-------------
| main.rhai |
-------------

// This function is overridden by the module script.
fn inner_message() { &quot;hi! from main!&quot; }

// This function is found by the module script.
fn main_message() { &quot;main here!&quot; }

import &quot;my_module&quot; as m;

m::greet();                     // prints &quot;hello! from module!&quot;

m::greet_main();                // prints &quot;main here!&quot;
</code></pre></pre>
<h3><a class="header" href="#simulating-virtual-functions" id="simulating-virtual-functions">Simulating virtual functions</a></h3>
<p>When calling a namespace-qualified function defined within a module, other functions defined within
the same module script override any similar-named functions (with the same number of parameters)
defined in the global namespace.  This is to ensure that a module acts as a self-contained unit and
functions defined in the calling script do not override module code.</p>
<p>In some situations, however, it is actually beneficial to do it in reverse: have module code call functions
defined in the calling script (i.e. in the global namespace) if they exist, and only call those defined
in the module script if none are found.</p>
<p>One such situation is the need to provide a <em>default implementation</em> to a simulated <em>virtual</em> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>------------------
| my_module.rhai |
------------------

// Do not do this (it will override the main script):
// fn message() { &quot;hello! from module!&quot; }

// This function acts as the default implementation.
private fn default_message() { &quot;hello! from module!&quot; }

// This function depends on a 'virtual' function 'message'
// which is not defined in the module script.
fn greet() {
    if is_def_fn(&quot;message&quot;, 0) {    // 'is_def_fn' detects if 'message' is defined.
        print(message());
    } else {
        print(default_message());
    }
}

-------------
| main.rhai |
-------------

// The main script defines 'message' which is needed by the module script.
fn message() { &quot;hi! from main!&quot; }

import &quot;my_module&quot; as m;

m::greet();                         // prints &quot;hi! from main!&quot;

--------------
| main2.rhai |
--------------

// The main script does not define 'message' which is needed by the module script.

import &quot;my_module&quot; as m;

m::greet();                         // prints &quot;hello! from module!&quot;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#changing-the-base-directory" id="changing-the-base-directory">Changing the base directory</a></h3>
<p>The base directory can be changed via the <code>FileModuleResolver::new_with_path</code> constructor function.</p>
<h2><a class="header" href="#staticmoduleresolver" id="staticmoduleresolver"><code>StaticModuleResolver</code></a></h2>
<p>Loads modules that are statically added. This can be used under <a href="rust/modules//book/vnext/start/features.html"><code>no_std</code></a>.</p>
<p>Functions are searched in the <em>global</em> namespace by default.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Module, module_resolvers::StaticModuleResolver};

let module: Module = create_a_module();

let mut resolver = StaticModuleResolver::new();
resolver.insert(&quot;my_module&quot;, module);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#moduleresolverscollection" id="moduleresolverscollection"><code>ModuleResolversCollection</code></a></h2>
<p>A collection of module resolvers. Modules will be resolved from each resolver in sequential order.</p>
<p>This is useful when multiple types of modules are needed simultaneously.</p>
<h2><a class="header" href="#dummyresolverscollection" id="dummyresolverscollection"><code>DummyResolversCollection</code></a></h2>
<p>This module resolver acts as a <em>dummy</em> and always fails all module resolution calls.</p>
<h2><a class="header" href="#set-into-engine" id="set-into-engine">Set into <code>Engine</code></a></h2>
<p>An <a href="rust/modules//book/vnext/engine/hello-world.html"><code>Engine</code></a>‘s module resolver is set via a call to <code>Engine::set_module_resolver</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::module_resolvers::{DummyModuleResolver, StaticModuleResolver};

// Create a module resolver
let resolver = StaticModuleResolver::new();

// Register functions into 'resolver'...

// Use the module resolver
engine.set_module_resolver(resolver);

// Effectively disable 'import' statements by setting module resolver to
// the 'DummyModuleResolver' which acts as... well... a dummy.
engine.set_module_resolver(DummyModuleResolver::new());
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#implement-a-custom-module-resolver" id="implement-a-custom-module-resolver">Implement a Custom Module Resolver</a></h1>
<p>For many applications in which Rhai is embedded, it is necessary to customize the way that modules
are resolved.  For instance, modules may need to be loaded from script texts stored in a database,
not in the file system.</p>
<p>A module resolver must implement the trait <a href="rust/modules//book/vnext/rust/traits.html"><code>rhai::ModuleResolver</code></a>,
which contains only one required function: <code>resolve</code>.</p>
<p>When Rhai prepares to load a module, <code>ModuleResolver::resolve</code> is called with the name
of the <em>module path</em> (i.e. the path specified in the <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statement).</p>
<ul>
<li>
<p>Upon success, it should return an <a href="rust/modules//book/vnext/rust/modules/index.html"><code>Rc&lt;Module&gt;</code></a> (or <a href="rust/modules//book/vnext/rust/modules/index.html"><code>Arc&lt;Module&gt;</code></a> under <a href="rust/modules//book/vnext/start/features.html"><code>sync</code></a>).</p>
<p>The module should call <code>Module::build_index</code> on the target module before returning.
This method flattens the entire module tree and <em>indexes</em> it for fast function name resolution.
If the module is already indexed, calling this method has no effect.</p>
</li>
<li>
<p>If the path does not resolve to a valid module, return <code>EvalAltResult::ErrorModuleNotFound</code>.</p>
</li>
<li>
<p>If the module failed to load, return <code>EvalAltResult::ErrorInModule</code>.</p>
</li>
</ul>
<h2><a class="header" href="#example-of-a-custom-module-resolver" id="example-of-a-custom-module-resolver">Example of a Custom Module Resolver</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{ModuleResolver, Module, Engine, EvalAltResult};

// Define a custom module resolver.
struct MyModuleResolver {}

// Implement the 'ModuleResolver' trait.
impl ModuleResolver for MyModuleResolver {
    // Only required function.
    fn resolve(
        &amp;self,
        engine: &amp;Engine,    // reference to the current 'Engine'
        path: &amp;str,         // the module path
        pos: Position,      // position of the 'import' statement
    ) -&gt; Result&lt;Rc&lt;Module&gt;, Box&lt;EvalAltResult&gt;&gt; {
        // Check module path.
        if is_valid_module_path(path) {
            let mut my_module =
                load_secret_module(path)        // load the custom module
                    .map_err(|err|
                        // Return EvalAltResult::ErrorInModule upon loading error
                        EvalAltResult::ErrorInModule(path.into(), Box::new(err), pos).into()
                    )?;
            my_module.build_index();            // index it
            Rc::new(my_module)                  // make it shared
        } else {
            // Return EvalAltResult::ErrorModuleNotFound if the path is invalid
            Err(EvalAltResult::ErrorModuleNotFound(path.into(), pos).into())
        }
    }
}

let mut engine = Engine::new();

// Set the custom module resolver into the 'Engine'.
engine.set_module_resolver(MyModuleResolver {});

engine.consume(r#&quot;
    import &quot;hello&quot; as foo;  // this 'import' statement will call
                            // 'MyModuleResolver::resolve' with &quot;hello&quot; as 'path'
    foo:bar();
&quot;#)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implementing-moduleresolverresolve_ast" id="implementing-moduleresolverresolve_ast">Implementing <code>ModuleResolver::resolve_ast</code></a></h2>
<p>There is another function in the <a href="rust/modules//book/vnext/rust/traits.html"><code>ModuleResolver</code></a> trait, <code>resolve_ast</code>, which is a
low-level API intended for advanced usage scenarios.</p>
<p><code>ModuleResolver::resolve_ast</code> has a default implementation that simply returns <code>None</code>,
which indicates that this API is not supported by the <a href="rust/modules//book/vnext/rust/modules/resolvers.html">module resolver</a>.</p>
<p>Any <a href="rust/modules//book/vnext/rust/modules/resolvers.html">module resolver</a> that serves <a href="rust/modules//book/vnext/rust/modules/index.html">modules</a> based on Rhai scripts should implement
<code>ModuleResolver::resolve_ast</code>. When called, the compiled <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a> of the script should be returned.</p>
<p><code>ModuleResolver::resolve_ast</code> should not return an error if <code>ModuleResolver::resolve</code> will not.
On the other hand, the same error should be returned if <code>ModuleResolver::resolve</code> will return one.</p>
<h1><a class="header" href="#compile-to-a-self-contained-ast" id="compile-to-a-self-contained-ast">Compile to a Self-Contained <code>AST</code></a></h1>
<p>When a script <a href="rust/modules//book/vnext/language/modules/import.html">imports</a> external <a href="rust/modules//book/vnext/rust/modules/index.html">modules</a> that may not be available later on,
it is possible to eagerly <a href="rust/modules//book/vnext/rust/modules/resolvers.html"><em>pre-resolve</em></a> these imports and embed them
directly into a self-contained <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a>.</p>
<p>For instance, a system may periodically connect to a central source (e.g. a database) to load
scripts and compile them to <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a> form. Afterwards, in order to conserve bandwidth (or due to
other physical limitations), it is disconnected from the central source for self-contained
operation.</p>
<p>Compile a script into a <em>self-contained</em> <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a> via the <code>Engine::compile_into_self_contained</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

// Compile script into self-contained AST using the current
// module resolver (default to `FileModuleResolver`) to pre-resolve
// 'import' statements.
let ast = engine.compile_into_self_contained(&amp;mut scope, script)?;

// Make sure we can no longer resolve any module!
engine.set_module_resolver(DummyModuleResolver::new());

// The AST still evaluates fine, even with 'import' statements!
engine.consume(&amp;ast)?;
<span class="boring">}
</span></code></pre></pre>
<p>When such an <a href="rust/modules//book/vnext/engine/compile.html"><code>AST</code></a> is evaluated, <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statements within are provided the <em>pre-resolved</em>
<a href="rust/modules//book/vnext/rust/modules/index.html">modules</a> without going through the normal <a href="rust/modules//book/vnext/rust/modules/resolvers.html">module resolution</a> process.</p>
<h2><a class="header" href="#only-static-paths" id="only-static-paths">Only Static Paths</a></h2>
<p><code>Engine::compile_into_self_contained</code> only pre-resolves <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statements in the script
that are <em>static</em>, i.e. with a path that is a <a href="rust/modules//book/vnext/language/strings-chars.html">string</a> literal.</p>
<p>It does not matter where the <a href="rust/modules//book/vnext/language/modules/import.html"><code>import</code></a> statement occurs (e.g. deep within statement blocks,
within function bodies).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following import is pre-resolved.
import &quot;hello&quot; as h;

if some_event() {
    // The following import is pre-resolved.
    import &quot;hello&quot; as h;
}

fn foo() {
    // The following import is pre-resolved.
    import &quot;hello&quot; as h;
}

// The following import is also pre-resolved because the expression
// is usually optimized into a single string during compilation.
import &quot;he&quot; + &quot;llo&quot; as h;

let module_name = &quot;hello&quot;;

// The following import is NOT pre-resolved.
import module_name as h;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#plugins" id="plugins">Plugins</a></h1>
<p>Rhai contains a robust <em>plugin</em> system that greatly simplifies registration of custom
functionality.</p>
<p>Instead of using the large <code>Engine::register_XXX</code> API or the parallel <code>Module::set_fn_XXX</code> API,
a <em>plugin</em> simplifies the work of creating and registering new functionality in an <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
<p>Plugins are processed via a set of procedural macros under the <code>rhai::plugin</code> module. These
allow registering Rust functions directly in the Engine, or adding Rust modules as packages.</p>
<h1><a class="header" href="#export-a-rust-module-to-rhai" id="export-a-rust-module-to-rhai">Export a Rust Module to Rhai</a></h1>
<h2><a class="header" href="#prelude" id="prelude">Prelude</a></h2>
<p>When using the plugins system, the entire <code>rhai::plugin</code> module must be imported as a prelude
because code generated will need these imports.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#export_module" id="export_module"><code>#[export_module]</code></a></h2>
<p>When applied to a Rust module, the <code>#[export_module]</code> attribute generates the necessary
code and metadata to allow Rhai access to its public (i.e. marked <code>pub</code>) functions, constants
and sub-modules.</p>
<p>This code is exactly what would need to be written by hand to achieve the same goal,
and is custom fit to each exported item.</p>
<p>All <code>pub</code> functions become registered functions, all <code>pub</code> constants become <a href="plugins//book/vnext/rust/modules/index.html">module</a> constant variables,
and all sub-modules become Rhai sub-modules.</p>
<p>This Rust module can then be registered into an <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a> as a normal <a href="plugins//book/vnext/rust/modules/index.html">module</a>.
This is done via the <code>exported_module!</code> macro.</p>
<p>The macro <code>combine_with_exported_module!</code> can be used to <em>combine</em> all the functions
and variables into an existing <a href="plugins//book/vnext/rust/modules/index.html">module</a>, <em>flattening</em> the namespace – i.e. all sub-modules
are eliminated and their contents promoted to the top level.  This is typical for
developing <a href="plugins//book/vnext/rust/packages/create.html">custom packages</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This constant will be registered as the constant variable 'MY_NUMBER'.
    // Ignored when registered as a global module.
    pub const MY_NUMBER: i64 = 42;

    // This function will be registered as 'greet'.
    pub fn greet(name: &amp;str) -&gt; String {
        format!(&quot;hello, {}!&quot;, name)
    }
    // This function will be registered as 'get_num'.
    pub fn get_num() -&gt; i64 {
        mystic_number()
    }
    // This function will be registered as 'increment'.
    // It will also be exposed to the global namespace since 'global' is set.
    #[rhai_fn(global)]
    pub fn increment(num: &amp;mut i64) {
        *num += 1;
    }
    // This function is not 'pub', so NOT registered.
    fn mystic_number() -&gt; i64 {
        42
    }

    // Sub-modules are ignored when the module is registered globally.
    pub mod my_sub_module {
        // This function is ignored when registered globally.
        // Otherwise it is a valid registered function under a sub-module.
        pub fn get_info() -&gt; String {
            &quot;hello&quot;.to_string()
        }
    }

    // Sub-modules are commonly used to put feature gates on a group of
    // functions because feature gates cannot be put on function definitions.
    // This is currently a limitation of the plugin procedural macros.
    #[cfg(feature = &quot;advanced_functions&quot;)]
    pub mod advanced {
        // This function is ignored when registered globally.
        // Otherwise it is a valid registered function under a sub-module
        // which only exists when the 'advanced_functions' feature is used.
        pub fn advanced_calc(input: i64) -&gt; i64 {
            input * 2
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#use-engineregister_global_module" id="use-engineregister_global_module">Use <code>Engine::register_global_module</code></a></h3>
<p>The simplest way to register this into an <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a> is to first use the <code>exported_module!</code> macro
to turn it into a normal Rhai <a href="plugins//book/vnext/rust/modules/index.html">module</a>, then use the <code>Engine::register_global_module</code> method on it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut engine = Engine::new();

    // The macro call creates a Rhai module from the plugin module.
    let module = exported_module!(my_module);

    // A module can simply be registered into the global namespace.
    engine.register_global_module(module.into());
}
</code></pre></pre>
<p>The functions contained within the module definition (i.e. <code>greet</code>, <code>get_num</code> and <code>increment</code>)
are automatically registered into the <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a> when <code>Engine::register_global_module</code> is called.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = greet(&quot;world&quot;);
x == &quot;hello, world!&quot;;

let x = greet(get_num().to_string());
x == &quot;hello, 42!&quot;;

let x = get_num();
x == 42;

increment(x);
x == 43;
<span class="boring">}
</span></code></pre></pre>
<p>Notice that, when using a <a href="plugins//book/vnext/rust/modules/index.html">module</a> as a <a href="plugins//book/vnext/rust/packages/index.html">package</a>, only functions registered at the <em>top level</em>
can be accessed.</p>
<p>Variables as well as sub-modules are <strong>ignored</strong>.</p>
<h3><a class="header" href="#use-engineregister_static_module" id="use-engineregister_static_module">Use <code>Engine::register_static_module</code></a></h3>
<p>Another simple way to register this into an <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a> is, again, to use the <code>exported_module!</code> macro
to turn it into a normal Rhai <a href="plugins//book/vnext/rust/modules/index.html">module</a>, then use the <code>Engine::register_static_module</code> method on it:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut engine = Engine::new();

    // The macro call creates a Rhai module from the plugin module.
    let module = exported_module!(my_module);

    // A module can simply be registered as a static module namespace.
    engine.register_static_module(&quot;service&quot;, module.into());
}
</code></pre></pre>
<p>The functions contained within the module definition (i.e. <code>greet</code>, <code>get_num</code> and <code>increment</code>),
plus the constant <code>MY_NUMBER</code>, are automatically registered under the module namespace <code>service</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = service::greet(&quot;world&quot;);
x == &quot;hello, world!&quot;;

service::MY_NUMBER == 42;

let x = service::greet(service::get_num().to_string());
x == &quot;hello, 42!&quot;;

let x = service::get_num();
x == 42;

service::increment(x);
x == 43;
<span class="boring">}
</span></code></pre></pre>
<p>All functions (usually <em>methods</em>) defined in the module and marked with <code>#[rhai_fn(global)]</code>,
as well as all <a href="plugins//book/vnext/language/iterator.html">type iterators</a>, are automatically exposed to the <em>global</em> namespace, so
<a href="plugins//book/vnext/language/for.html">iteration</a>, <a href="plugins//book/vnext/rust/getters-setters.html">getters/setters</a> and <a href="plugins//book/vnext/rust/indexers.html">indexers</a> for <a href="plugins//book/vnext/rust/custom.html">custom types</a>
can work as expected.</p>
<p>In fact, the default for all <a href="plugins//book/vnext/rust/getters-setters.html">getters/setters</a> and <a href="plugins//book/vnext/rust/indexers.html">indexers</a> defined in a plugin module
is <code>#[rhai_fn(global)]</code> unless specifically overridden by <code>#[rhai_fn(internal)]</code>.</p>
<p>Therefore, in the example above, the <code>increment</code> method (defined with <code>#[rhai_fn(global)]</code>)
works fine when called in method-call style:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
x.increment();
x == 43;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#use-dynamically" id="use-dynamically">Use Dynamically</a></h3>
<p>Using this directly as a dynamically-loadable Rhai <a href="plugins//book/vnext/rust/modules/index.html">module</a> is almost the same, except that a
<a href="plugins//book/vnext/rust/modules/resolvers.html">module resolver</a> must be used to serve the module, and the module is loaded via <code>import</code> statements.</p>
<p>See the <a href="plugins//book/vnext/rust/modules/index.html">module</a> section for more information.</p>
<h3><a class="header" href="#combine-into-custom-package" id="combine-into-custom-package">Combine into Custom Package</a></h3>
<p>Finally the plugin module can also be used to develop a <a href="plugins//book/vnext/rust/packages/create.html">custom package</a>,
using <code>combine_with_exported_module!</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>def_package!(rhai:MyPackage:&quot;My own personal super package&quot;, module, {
    combine_with_exported_module!(module, &quot;my_module_ID&quot;, my_module));
});
<span class="boring">}
</span></code></pre></pre>
<p><code>combine_with_exported_module!</code> automatically <em>flattens</em> the module namespace so that all
functions in sub-modules are promoted to the top level.  This is convenient for <a href="plugins//book/vnext/rust/packages/create.html">custom packages</a>.</p>
<h2><a class="header" href="#sub-modules-and-feature-gates" id="sub-modules-and-feature-gates">Sub-Modules and Feature Gates</a></h2>
<p>Sub-modules in a plugin module definition are turned into valid sub-modules in the resultant
Rhai <code>Module</code>.</p>
<p>They are also commonly used to put <em>feature gates</em> or <em>compile-time gates</em> on a group of functions,
because currently attributes do not work on individual function definitions due to a limitation of
the procedural macros system.</p>
<p>This is especially convenient when using the <code>combine_with_exported_module!</code> macro to develop
<a href="plugins//book/vnext/rust/packages/create.html">custom packages</a> because selected groups of functions can easily be included or excluded based on
different combinations of feature flags instead of having to manually include/exclude every
single function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_module]
mod my_module {
    // Always available
    pub fn func0() {}

    // The following sub-module is only available under 'feature1'
    #[cfg(feature = &quot;feature1&quot;)]
    pub mod feature1 {
        fn func1() {}
        fn func2() {}
        fn func3() {}
    }

    // The following sub-module is only available under 'feature2'
    #[cfg(feature = &quot;feature2&quot;)]
    pub mod feature2 {
        fn func4() {}
        fn func5() {}
        fn func6() {}
    }
}

// Registered functions:
//   func0 - always available
//   func1 - available under 'feature1'
//   func2 - available under 'feature1'
//   func3 - available under 'feature1'
//   func4 - available under 'feature2'
//   func5 - available under 'feature2'
//   func6 - available under 'feature2'
combine_with_exported_module!(module, &quot;my_module_ID&quot;, my_module);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#function-overloading-and-operators" id="function-overloading-and-operators">Function Overloading and Operators</a></h2>
<p>Operators and overloaded functions can be specified via applying the <code>#[rhai_fn(name = &quot;...&quot;)]</code>
attribute to individual functions.</p>
<p>The text string given as the <code>name</code> parameter to <code>#[rhai_fn]</code> is used to register the function with
the <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a>, disregarding the actual name of the function.</p>
<p>With <code>#[rhai_fn(name = &quot;...&quot;)]</code>, multiple functions may be registered under the same name in Rhai,
so long as they have different parameters.</p>
<p>Operators (which require function names that are not valid for Rust) can also be registered this way.</p>
<p>Registering the same function name with the same parameter types will cause a parsing error.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This is the '+' operator for 'TestStruct'.
    #[rhai_fn(name = &quot;+&quot;)]
    pub fn add(obj: &amp;mut TestStruct, value: i64) {
        obj.prop += value;
    }
    // This function is 'calc (i64)'.
    #[rhai_fn(name = &quot;calc&quot;)]
    pub fn calc_with_default(num: i64) -&gt; i64 {
        ...
    }
    // This function is 'calc (i64, bool)'.
    #[rhai_fn(name = &quot;calc&quot;)]
    pub fn calc_with_option(num: i64, option: bool) -&gt; i64 {
        ...
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#getters-setters-and-indexers" id="getters-setters-and-indexers">Getters, Setters and Indexers</a></h2>
<p>Functions can be marked as <a href="plugins//book/vnext/rust/getters-setters.html">getters/setters</a> and <a href="plugins//book/vnext/rust/indexers.html">indexers</a> for <a href="plugins//book/vnext/rust/custom.html">custom types</a> via the <code>#[rhai_fn]</code>
attribute, which is applied on a function level.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This is a normal function 'greet'.
    pub fn greet(name: &amp;str) -&gt; String {
        format!(&quot;hello, {}!&quot;, name)
    }
    // This is a getter for 'TestStruct::prop'.
    #[rhai_fn(get = &quot;prop&quot;)]
    pub fn get_prop(obj: &amp;mut TestStruct) -&gt; i64 {
        obj.prop
    }
    // This is a setter for 'TestStruct::prop'.
    #[rhai_fn(set = &quot;prop&quot;)]
    pub fn set_prop(obj: &amp;mut TestStruct, value: i64) {
        obj.prop = value;
    }
    // This is an index getter for 'TestStruct'.
    #[rhai_fn(index_get)]
    pub fn get_index(obj: &amp;mut TestStruct, index: i64) -&gt; bool {
        obj.list[index]
    }
    // This is an index setter for 'TestStruct'.
    #[rhai_fn(index_set)]
    pub fn get_index(obj: &amp;mut TestStruct, index: i64, state: bool) {
        obj.list[index] = state;
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#multiple-registrations" id="multiple-registrations">Multiple Registrations</a></h2>
<p>Parameters to the <code>#[rhai_fn(...)]</code> attribute can be applied multiple times.</p>
<p>This is especially useful for the <code>name = &quot;...&quot;</code>, <code>get = &quot;...&quot;</code> and <code>set = &quot;...&quot;</code> parameters
to give multiple alternative names to the same function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This function can be called in five ways
    #[rhai_fn(name = &quot;get_prop_value&quot;, name = &quot;prop&quot;, name = &quot;+&quot;, set = &quot;prop&quot;, index_get)]
    pub fn prop_function(obj: &amp;mut TestStruct, index: i64) -&gt; i64 {
        obj.prop[index]
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The above function can be called in five ways:</p>
<table><thead><tr><th>Parameter for <code>#[rhai_fn(...)]</code></th><th align="center">Type</th><th>Call style</th></tr></thead><tbody>
<tr><td><code>name = &quot;get_prop_value&quot;</code></td><td align="center">method function</td><td><code>get_prop_value(x, 0)</code>, <code>x.get_prop_value(0)</code></td></tr>
<tr><td><code>name = &quot;prop&quot;</code></td><td align="center">method function</td><td><code>prop(x, 0)</code>, <code>x.prop(0)</code></td></tr>
<tr><td><code>name = &quot;+&quot;</code></td><td align="center">operator</td><td><code>x + 42</code></td></tr>
<tr><td><code>set = &quot;prop&quot;</code></td><td align="center">setter</td><td><code>x.prop = 42</code></td></tr>
<tr><td><code>index_get</code></td><td align="center">index getter</td><td><code>x[0]</code></td></tr>
</tbody></table>
<h2><a class="header" href="#fallible-functions" id="fallible-functions">Fallible Functions</a></h2>
<p>To register <a href="plugins//book/vnext/rust/fallible.html">fallible functions</a> (i.e. functions that may return errors), apply the
<code>#[rhai_fn(return_raw)]</code> attribute on functions that return <code>Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code>.</p>
<p>A syntax error is generated if the function with <code>#[rhai_fn(return_raw)]</code> does not
have the appropriate return type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This overloads the '/' operator for i64.
    #[rhai_fn(name = &quot;/&quot;, return_raw)]
    pub fn double_and_divide(x: i64, y: i64) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
        if y == 0 {
            Err(&quot;Division by zero!&quot;.into())
        } else {
            let result = (x * 2) / y;
            Ok(result.into())
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#nativecallcontext-parameter" id="nativecallcontext-parameter"><code>NativeCallContext</code> Parameter</a></h2>
<p>If the <em>first</em> parameter of a function is of type <code>rhai::NativeCallContext</code>, then it is treated
specially by the plugins system.</p>
<p><code>NativeCallContext</code> is a type that encapsulates the current <em>native call context</em> and exposes the following:</p>
<table><thead><tr><th>Field</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>the current <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a>, with all configurations and settings.<br/>This is sometimes useful for calling a script-defined function within the same evaluation context using <a href="plugins//book/vnext/engine/call-fn.html"><code>Engine::call_fn</code></a>, or calling a <a href="plugins//book/vnext/language/fn-ptr.html">function pointer</a>.</td></tr>
<tr><td><code>fn_name()</code></td><td align="center"><code>&amp;str</code></td><td>name of the function called (useful when the same Rust function is mapped to multiple Rhai-callable function names)</td></tr>
<tr><td><code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td><code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="plugins//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td><code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="plugins//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="plugins//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td><code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="plugins//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td><code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="plugins//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="plugins//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
</tbody></table>
<p>This first parameter, if exists, will be stripped before all other processing.  It is <em>virtual</em>.
Most importantly, it does <em>not</em> count as a parameter to the function and there is no need to provide
this argument when calling the function in Rhai.</p>
<p>The native call context can be used to call a <a href="plugins//book/vnext/language/fn-ptr.html">function pointer</a> or <a href="plugins//book/vnext/language/fn-closure.html">closure</a> that has been passed
as a parameter to the function, thereby implementing a <em>callback</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, FnPtr, NativeCallContext, EvalAltResult};
use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    #[rhai_fn(return_raw)]
    pub fn greet(context: NativeCallContext, callback: FnPtr)
                                -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
    {
        // Call the callback closure with the current context
        // to obtain the name to greet!
        let name = callback.call_dynamic(context, None, [])?;
        Ok(format!(&quot;hello, {}!&quot;, name).into())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The native call context is also useful in another scenario: protecting a function from malicious scripts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Array, NativeCallContext, EvalAltResult, Position};
use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_module]
mod my_module {
    // This function builds an array of arbitrary size, but is protected
    // against attacks by first checking with the allowed limit set
    // into the 'Engine'.
    #[rhai_fn(return_raw)]
    pub fn grow(context: NativeCallContext, size: i64)
                                -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
    {
        // Make sure the function does not generate a
        // data structure larger than the allowed limit
        // for the Engine!
        if size as usize &gt; context.engine().max_array_size()
        {
            return EvalAltResult::ErrorDataTooLarge(
                &quot;Size to grow&quot;.to_string(),
                context.engine().max_array_size(),
                size as usize,
                Position::NONE,
            ).into();
        }

        let array = Array::new();

        for x in 0..size {
            array.push(x.into());
        }

        OK(array.into())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#export_module-parameters" id="export_module-parameters"><code>#[export_module]</code> Parameters</a></h2>
<p>Parameters can be applied to the <code>#[export_module]</code> attribute to override its default behavior.</p>
<table><thead><tr><th>Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td><em>none</em></td><td>exports only public (i.e. <code>pub</code>) functions</td></tr>
<tr><td><code>export_all</code></td><td>exports all functions (including private, non-<code>pub</code> functions); use <code>#[rhai_fn(skip)]</code> on individual functions to avoid export</td></tr>
<tr><td><code>export_prefix = &quot;...&quot;</code></td><td>exports functions (including private, non-<code>pub</code> functions) with names starting with a specific prefix</td></tr>
</tbody></table>
<h2><a class="header" href="#inner-attributes" id="inner-attributes">Inner Attributes</a></h2>
<p>Inner attributes can be applied to the inner items of a module to tweak the export process.</p>
<p><code>#[rhai_fn]</code> is applied to functions, while <code>#[rhai_mod]</code> is applied to sub-modules.</p>
<p>Parameters should be set on inner attributes to specify the desired behavior.</p>
<table><thead><tr><th>Attribute Parameter</th><th>Use with</th><th>Apply to</th><th>Description</th></tr></thead><tbody>
<tr><td><code>skip</code></td><td><code>#[rhai_fn]</code>, <code>#[rhai_mod]</code></td><td>function or sub-module</td><td>do not export this function/sub-module</td></tr>
<tr><td><code>global</code></td><td><code>#[rhai_fn]</code></td><td>function</td><td>expose this function to the global namespace</td></tr>
<tr><td><code>internal</code></td><td><code>#[rhai_fn]</code></td><td>function</td><td>keep this function within the internal module namespace</td></tr>
<tr><td><code>name = &quot;...&quot;</code></td><td><code>#[rhai_fn]</code>, <code>#[rhai_mod]</code></td><td>function or sub-module</td><td>registers function/sub-module under the specified name</td></tr>
<tr><td><code>get = &quot;...&quot;</code></td><td><code>#[rhai_fn]</code></td><td><code>pub fn (&amp;mut Type) -&gt; Value</code></td><td>registers a getter for the named property</td></tr>
<tr><td><code>set = &quot;...&quot;</code></td><td><code>#[rhai_fn]</code></td><td><code>pub fn (&amp;mut Type, Value)</code></td><td>registers a setter for the named property</td></tr>
<tr><td><code>index_get</code></td><td><code>#[rhai_fn]</code></td><td><code>pub fn (&amp;mut Type, INT) -&gt; Value</code></td><td>registers an index getter</td></tr>
<tr><td><code>index_set</code></td><td><code>#[rhai_fn]</code></td><td><code>pub fn (&amp;mut Type, INT, Value)</code></td><td>registers an index setter</td></tr>
<tr><td><code>return_raw</code></td><td><code>#[rhai_fn]</code></td><td><code>pub fn (...) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></td><td>marks this as a <a href="plugins//book/vnext/rust/fallible.html">fallible function</a></td></tr>
</tbody></table>
<h1><a class="header" href="#export-a-rust-function-to-rhai" id="export-a-rust-function-to-rhai">Export a Rust Function to Rhai</a></h1>
<p>Sometimes only a few ad hoc functions are required and it is simpler to register
individual functions instead of a full-blown <a href="plugins//book/vnext/plugins/module.html">plugin module</a>.</p>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<table><thead><tr><th>Macro</th><th>Signature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>#[export_fn]</code></td><td>apply to rust function defined in a Rust module</td><td>exports the function</td></tr>
<tr><td><code>register_exported_fn!</code></td><td><code>register_exported_fn!(&amp;mut </code><em>engine</em><code>, &quot;</code><em>name</em><code>&quot;, </code><em>function</em><code>)</code></td><td>registers the function into an <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a> under a specific name</td></tr>
<tr><td><code>set_exported_fn!</code></td><td><code>set_exported_fn!(&amp;mut </code><em>module</em><code>, &quot;</code><em>name</em><code>&quot;, </code><em>function</em><code>)</code></td><td>registers the function into a <a href="plugins//book/vnext/rust/modules/index.html"><code>Module</code></a> under a specific name</td></tr>
<tr><td><code>set_exported_global_fn!</code></td><td><code>set_exported_global_fn!(&amp;mut </code><em>module</em><code>, &quot;</code><em>name</em><code>&quot;, </code><em>function</em><code>)</code></td><td>registers the function into a <a href="plugins//book/vnext/rust/modules/index.html"><code>Module</code></a> under a specific name, exposing it to the global namespace</td></tr>
</tbody></table>
<h2><a class="header" href="#export_fn-and-register_exported_fn" id="export_fn-and-register_exported_fn"><code>#[export_fn]</code> and <code>register_exported_fn!</code></a></h2>
<p>Apply <code>#[export_fn]</code> onto a function defined at <em>module level</em> to convert it into a Rhai plugin function.</p>
<p>The function cannot be nested inside another function – it can only be defined directly under a module.</p>
<p>To register the plugin function, simply call <code>register_exported_fn!</code>.  The name of the function can be
any text string, so it is possible to register <em>overloaded</em> functions as well as operators.</p>
<pre><pre class="playground"><code class="language-rust">use rhai::plugin::*;        // import macros

#[export_fn]
fn increment(num: &amp;mut i64) {
    *num += 1;
}

fn main() {
    let mut engine = Engine::new();

    // 'register_exported_fn!' registers the function as 'inc' with the Engine.
    register_exported_fn!(engine, &quot;inc&quot;, increment);
}
</code></pre></pre>
<h2><a class="header" href="#fallible-functions-1" id="fallible-functions-1">Fallible Functions</a></h2>
<p>To register <a href="plugins//book/vnext/rust/fallible.html">fallible functions</a> (i.e. functions that may return errors), apply the
<code>#[rhai_fn(return_raw)]</code> attribute on plugin functions that return <code>Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code>.</p>
<p>A syntax error is generated if the function with <code>#[rhai_fn(return_raw)]</code> does not
have the appropriate return type.</p>
<pre><pre class="playground"><code class="language-rust">use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_fn]
#[rhai_fn(return_raw)]
pub fn double_and_divide(x: i64, y: i64) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    if y == 0 {
        Err(&quot;Division by zero!&quot;.into())
    } else {
        let result = (x * 2) / y;
        Ok(result.into())
    }
}

fn main() {
    let mut engine = Engine::new();

    // Overloads the operator '+' with the Engine.
    register_exported_fn!(engine, &quot;+&quot;, double_and_divide);
}
</code></pre></pre>
<h2><a class="header" href="#nativecallcontext-parameter-1" id="nativecallcontext-parameter-1"><code>NativeCallContext</code> Parameter</a></h2>
<p>If the <em>first</em> parameter of a function is of type <code>rhai::NativeCallContext</code>, then it is treated
specially by the plugins system.</p>
<p><code>NativeCallContext</code> is a type that encapsulates the current <em>native call context</em> and exposes the following:</p>
<table><thead><tr><th>Field</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>the current <a href="plugins//book/vnext/engine/hello-world.html"><code>Engine</code></a>, with all configurations and settings.<br/>This is sometimes useful for calling a script-defined function within the same evaluation context using <a href="plugins//book/vnext/engine/call-fn.html"><code>Engine::call_fn</code></a>, or calling a <a href="plugins//book/vnext/language/fn-ptr.html">function pointer</a>.</td></tr>
<tr><td><code>fn_name()</code></td><td align="center"><code>&amp;str</code></td><td>name of the function called (useful when the same Rust function is mapped to multiple Rhai-callable function names)</td></tr>
<tr><td><code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td><code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="plugins//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td><code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="plugins//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="plugins//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td><code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="plugins//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td><code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="plugins//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="plugins//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
</tbody></table>
<p>This first parameter, if exists, will be stripped before all other processing.  It is <em>virtual</em>.
Most importantly, it does <em>not</em> count as a parameter to the function and there is no need to provide
this argument when calling the function in Rhai.</p>
<p>The native call context can be used to call a <a href="plugins//book/vnext/language/fn-ptr.html">function pointer</a> or <a href="plugins//book/vnext/language/fn-closure.html">closure</a> that has been passed
as a parameter to the function, thereby implementing a <em>callback</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, FnPtr, NativeCallContext, EvalAltResult};
use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

#[export_fn]
#[rhai_fn(return_raw)]
pub fn greet(context: NativeCallContext, callback: FnPtr)
                            -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
{
    // Call the callback closure with the current context
    // to obtain the name to greet!
    let name = callback.call_dynamic(context, None, [])?;
    Ok(format!(&quot;hello, {}!&quot;, name).into())
}
<span class="boring">}
</span></code></pre></pre>
<p>The native call context is also useful in another scenario: protecting a function from malicious scripts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Array, NativeCallContext, EvalAltResult, Position};
use rhai::plugin::*;        // a &quot;prelude&quot; import for macros

// This function builds an array of arbitrary size, but is protected
// against attacks by first checking with the allowed limit set
// into the 'Engine'.
#[export_fn]
#[rhai_fn(return_raw)]
pub fn grow(context: NativeCallContext, size: i64)
                            -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
{
    // Make sure the function does not generate a
    // data structure larger than the allowed limit
    // for the Engine!
    if size as usize &gt; context.engine().max_array_size()
    {
        return EvalAltResult::ErrorDataTooLarge(
            &quot;Size to grow&quot;.to_string(),
            context.engine().max_array_size(),
            size as usize,
            Position::NONE,
        ).into();
    }

    let array = Array::new();

    for x in 0..size {
        array.push(x.into());
    }

    OK(array.into())
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#packages" id="packages">Packages</a></h1>
<p>The built-in library of Rhai is provided as various <em>packages</em> that can be
turned into <em>shared</em> <a href="rust/packages//book/vnext/rust/modules/index.html">modules</a>, which in turn can be registered into the
<em>global namespace</em> of an <a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a> via <code>Engine::register_global_module</code>.</p>
<p>Packages reside under <code>rhai::packages::*</code> and the trait <code>rhai::packages::Package</code>
must be loaded in order for packages to be used.</p>
<h3><a class="header" href="#packages-are-modules" id="packages-are-modules">Packages <em>are</em> Modules</a></h3>
<p>Internally, a <em>package</em> is a <em>newtype</em> wrapping a pre-defined <a href="rust/packages//book/vnext/rust/modules/index.html">module</a>,
with some conveniences to make it easier to define and use as a standard
<em>library</em> for an <a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
<p>Packages typically contain Rust functions that are callable within a Rhai script.
All <em>top-level</em> functions in a package are available under the <em>global namespace</em>
(i.e. they’re available without namespace qualifiers).</p>
<p>Sub-modules and variables are ignored in packages.</p>
<h2><a class="header" href="#share-a-package-among-multiple-engines" id="share-a-package-among-multiple-engines">Share a Package Among Multiple <code>Engine</code>‘s</a></h2>
<p><code>Engine::register_global_module</code> and <code>Engine::register_static_module</code> both require <em>shared</em> <a href="rust/packages//book/vnext/rust/modules/index.html">modules</a>.</p>
<p>Once a package is created (e.g. via <code>Package::new</code>), it can create <em>shared</em> <a href="rust/packages//book/vnext/rust/modules/index.html">modules</a>
(via <code>Package::as_shared_module</code>) and register them into multiple instances of <a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a>,
even across threads (under the <a href="rust/packages//book/vnext/start/features.html"><code>sync</code></a> feature).</p>
<p>Therefore, a package only has to be created <em>once</em> and essentially shared among multiple
<a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a> instances.  This is particular useful when spawning large number of <a href="rust/packages//book/vnext/engine/raw.html">raw <code>Engine</code>‘s</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;
use rhai::packages::Package         // load the 'Package' trait to use packages
use rhai::packages::CorePackage;    // the 'core' package contains basic functionalities (e.g. arithmetic)

// Create a package - can be shared among multiple 'Engine' instances
let package = CorePackage::new();

let mut engines_collection: Vec&lt;Engine&gt; = Vec::new();

// Create 100 'raw' Engines
for _ in 0..100 {
    let mut engine = Engine::new_raw();

    // Register the package into the global namespace.
    // 'Package::as_shared_module' converts the package into a shared module.
    engine.register_global_module(package.as_shared_module());

    engines_collection.push(engine);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#built-in-packages" id="built-in-packages">Built-In Packages</a></h1>
<p><code>Engine::new</code> creates an <a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a> with the <code>StandardPackage</code> loaded.</p>
<p><code>Engine::new_raw</code> creates an <a href="rust/packages//book/vnext/engine/hello-world.html"><code>Engine</code></a> with <em>no</em> package loaded.</p>
<table><thead><tr><th>Package</th><th>Description</th><th align="center">In <code>Core</code></th><th align="center">In <code>Standard</code></th></tr></thead><tbody>
<tr><td><code>ArithmeticPackage</code></td><td>arithmetic operators (e.g. <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) for numeric types that are not built in (e.g. <code>u16</code>)</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>BasicIteratorPackage</code></td><td>numeric ranges (e.g. <code>range(1, 10)</code>)</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>LogicPackage</code></td><td>logical and comparison operators (e.g. <code>==</code>, <code>&gt;</code>) for numeric types that are not built in (e.g. <code>u16</code>)</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>BasicStringPackage</code></td><td>basic string functions (e.g. <code>print</code>, <code>debug</code>, <code>len</code>) that are not built in</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>BasicTimePackage</code></td><td>basic time functions (e.g. <a href="rust/packages//book/vnext/language/timestamps.html">timestamps</a>)</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>MoreStringPackage</code></td><td>additional string functions, including converting common types to string</td><td align="center">no</td><td align="center">yes</td></tr>
<tr><td><code>BasicMathPackage</code></td><td>basic math functions (e.g. <code>sin</code>, <code>sqrt</code>)</td><td align="center">no</td><td align="center">yes</td></tr>
<tr><td><code>BasicArrayPackage</code></td><td>basic <a href="rust/packages//book/vnext/language/arrays.html">array</a> functions (not available under <code>no_index</code>)</td><td align="center">no</td><td align="center">yes</td></tr>
<tr><td><code>BasicMapPackage</code></td><td>basic <a href="rust/packages//book/vnext/language/object-maps.html">object map</a> functions (not available under <code>no_object</code>)</td><td align="center">no</td><td align="center">yes</td></tr>
<tr><td><code>BasicFnPackage</code></td><td>basic methods for <a href="rust/packages//book/vnext/language/fn-ptr.html">function pointers</a>.</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>CorePackage</code></td><td>basic essentials</td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td><code>StandardPackage</code></td><td>standard library (default for <code>Engine::new</code>)</td><td align="center">no</td><td align="center">yes</td></tr>
</tbody></table>
<h2><a class="header" href="#corepackage" id="corepackage"><code>CorePackage</code></a></h2>
<p>If only minimal functionalities are required, register the <code>CorePackage</code> instead:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;
use rhai::packages::{Package, CorePackage};

let mut engine = Engine::new_raw();
let package = CorePackage::new();

// Register the package into the 'Engine' by converting it into a shared module.
engine.register_global_module(package.as_shared_module());
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#create-a-custom-package" id="create-a-custom-package">Create a Custom Package</a></h1>
<p>The macro <code>def_package!</code> can be used to create a custom <a href="rust/packages//book/vnext/rust/packages/index.html">package</a>.</p>
<p>A custom package can aggregate many other packages into a single self-contained unit.
More functions can be added on top of others.</p>
<h2><a class="header" href="#def_package" id="def_package"><code>def_package!</code></a></h2>
<blockquote>
<p><code>def_package!(root:package_name:description, variable, block)</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th align="center">Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><code>root</code></td><td>root namespace, usually <code>rhai</code></td></tr>
<tr><td align="center"><code>package_name</code></td><td>name of the package, usually ending in <code>...Package</code></td></tr>
<tr><td align="center"><code>description</code></td><td>doc-comment for the package</td></tr>
<tr><td align="center"><code>variable</code></td><td>a variable name holding a reference to the <a href="rust/packages//book/vnext/rust/modules/index.html">module</a> (<code>&amp;mut Module</code>) that is to form the package</td></tr>
<tr><td align="center"><code>block</code></td><td>a code block that initializes the package</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-4" id="examples-4">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import necessary types and traits.
use rhai::{
    def_package,            // 'def_package!' macro
    packages::Package,      // 'Package' trait
    packages::{             // pre-defined packages
        ArithmeticPackage, BasicArrayPackage, BasicMapPackage, LogicPackage
    }
};

// Define the package 'MyPackage'.
def_package!(rhai:MyPackage:&quot;My own personal super package&quot;, module, {
    // Aggregate other packages simply by calling 'init' on each.
    ArithmeticPackage::init(module);
    LogicPackage::init(module);
    BasicArrayPackage::init(module);
    BasicMapPackage::init(module);

    // Register additional Rust functions using the standard 'set_fn_XXX' module API.
    let hash = module.set_fn_1(&quot;foo&quot;, |s: ImmutableString| {
        Ok(foo(s.into_owned()))
    });

    // Remember to update the parameter names/types and return type metadata.
    // 'set_fn_XXX' by default does not set function metadata.
    module.update_fn_metadata(hash, [&quot;s: ImmutableString&quot;, &quot;i64&quot;]);
});
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#create-a-custom-package-from-a-plugin-module" id="create-a-custom-package-from-a-plugin-module">Create a Custom Package from a Plugin Module</a></h2>
<p>By far the easiest way to create a custom module is to call <code>plugin::combine_with_exported_module!</code>
from within <code>def_package!</code> which simply merges in all the functions defined within a <a href="rust/packages//book/vnext/plugins/module.html">plugin module</a>.</p>
<p>In fact, this exactly is how Rhai’s built-in packages, such as <code>BasicMathPackage</code>, are implemented.</p>
<p>Due to specific requirements of a <a href="rust/packages//book/vnext/rust/packages/index.html">package</a>, <code>plugin::combine_with_exported_module!</code>
<em>flattens</em> all sub-modules (i.e. all functions and <a href="rust/packages//book/vnext/language/iterator.html">type iterators</a> defined within sub-modules
are pulled up to the top level instead) and so there will not be any sub-modules added to the package.</p>
<p>Variables in the <a href="rust/packages//book/vnext/plugins/module.html">plugin module</a> are ignored.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import necessary types and traits.
use rhai::{
    def_package,
    packages::Package,
    packages::{ArithmeticPackage, BasicArrayPackage, BasicMapPackage, LogicPackage}
};
use rhai::plugin::*;

// Define plugin module.
#[export_module]
mod my_module {
    pub const MY_NUMBER: i64 = 42;

    pub fn greet(name: &amp;str) -&gt; String {
        format!(&quot;hello, {}!&quot;, name)
    }
    pub fn get_num() -&gt; i64 {
        42
    }

    // This is a sub-module, but if using combine_with_exported_module!, it will
    // be flattened and all functions registered at the top level.
    pub mod my_sub_module {
        pub fn get_sub_num() -&gt; i64 {
            0
        }
    }
}

// Define the package 'MyPackage'.
def_package!(rhai:MyPackage:&quot;My own personal super package&quot;, module, {
    // Aggregate other packages simply by calling 'init' on each.
    ArithmeticPackage::init(module);
    LogicPackage::init(module);
    BasicArrayPackage::init(module);
    BasicMapPackage::init(module);

    // Merge all registered functions and constants from the plugin module into the custom package.
    //
    // The sub-module 'my_sub_module' is flattened and its functions registered at the top level.
    //
    // The text string name in the second parameter can be anything and is reserved for future use;
    // it is recommended to be an ID string that uniquely identifies the plugin module.
    //
    // The constant variable, 'MY_NUMBER', is ignored.
    //
    // This call ends up registering three functions at the top level of the package:
    //   1) greet
    //   2) get_num
    //   3) get_sub_num (pulled up from 'my_sub_module')
    //
    combine_with_exported_module!(module, &quot;my-functions&quot;, my_module));
});
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#rhai-language-reference" id="rhai-language-reference">Rhai Language Reference</a></h1>
<p>This section outlines the Rhai language.</p>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>Comments are C-style, including ‘<code>/*</code> ... <code>*/</code>‘ pairs for block comments
and ‘<code>//</code>‘ for comments to the end of the line.</p>
<p>Comments can be nested.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let /* intruder comment */ name = &quot;Bob&quot;;

// This is a very important one-line comment

/* This comment spans
   multiple lines, so it
   only makes sense that
   it is even more important */

/* Fear not, Rhai satisfies all nesting needs with nested comments:
   /*/*/*/*/**/*/*/*/*/
*/
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#doc-comments" id="doc-comments">Doc-Comments</a></h1>
<p>Similar to Rust, comments starting with <code>///</code> (three slashes) or <code>/**</code> (two asterisks) are
<em>doc-comments</em>.</p>
<p>Doc-comments can only appear in front of <a href="language//book/vnext/language/functions.html">function</a> definitions, not any other elements:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// This is a valid one-line doc-comment
fn foo() {}

/** This is a
 ** valid block
 ** doc-comment
 **/
fn bar(x) {
   /// Syntax error - this doc-comment is invalid
   x + 1
}

/** Syntax error - this doc-comment is invalid */
let x = 42;

/// Syntax error - this doc-comment is also invalid
{
   let x = 42;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#special-cases" id="special-cases">Special Cases</a></h2>
<p>Long streams of <code>//////...</code> and <code>/*****...</code>  do <em>NOT</em> form doc-comments.
This is consistent with popular comment block styles for C-like languages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///////////////////////////////  &lt;- this is not a doc-comment
// This is not a doc-comment //  &lt;- this is a normal comment
///////////////////////////////  &lt;- this is not a doc-comment

// However, watch out for comment lines starting with '///'

//////////////////////////////////////////  &lt;- this is not a doc-comment
/// This, however, IS a doc-comment!!! ///  &lt;- this starts with '///'
//////////////////////////////////////////  &lt;- this is not a doc-comment

/****************************************
 *                                      *
 * This is also not a doc-comment block *
 * so we don't have to put this in      *
 * front of a function.                 *
 *                                      *
 ****************************************/
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#using-doc-comments" id="using-doc-comments">Using Doc-Comments</a></h2>
<p>Doc-comments are stored within the script’s <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> after compilation.</p>
<p>The <code>AST::iter_functions</code> method provides a <code>ScriptFnMetadata</code> instance
for each function defined within the script, which includes doc-comments.</p>
<p>Doc-comments never affect the evaluation of a script nor do they incur
significant performance overhead.  However, third party tools can take advantage
of this information to auto-generate documentation for Rhai script functions.</p>
<h2><a class="header" href="#disabling-doc-comments" id="disabling-doc-comments">Disabling Doc-Comments</a></h2>
<p>Doc-comments can be disabled via the <code>Engine::set_doc_comments</code> method.</p>
<h1><a class="header" href="#values-and-types" id="values-and-types">Values and Types</a></h1>
<p>The following primitive types are supported natively:</p>
<table><thead><tr><th>Category</th><th>Equivalent Rust types</th><th><a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a></th><th><code>to_string()</code></th></tr></thead><tbody>
<tr><td><strong>Integer number</strong></td><td><code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <br/><code>u32</code>, <code>i32</code> (default for <a href="language//book/vnext/start/features.html"><code>only_i32</code></a>),<br/><code>u64</code>, <code>i64</code> <em>(default)</em></td><td><code>&quot;i32&quot;</code>, <code>&quot;u64&quot;</code> etc.</td><td><code>&quot;42&quot;</code>, <code>&quot;123&quot;</code> etc.</td></tr>
<tr><td><strong>Floating-point number</strong> (disabled with <a href="language//book/vnext/start/features.html"><code>no_float</code></a>)</td><td><code>f32</code> (default for <a href="language//book/vnext/start/features.html"><code>f32_float</code></a>), <code>f64</code> <em>(default)</em></td><td><code>&quot;f32&quot;</code> or <code>&quot;f64&quot;</code></td><td><code>&quot;123.4567&quot;</code> etc.</td></tr>
<tr><td><strong>Boolean value</strong></td><td><code>bool</code></td><td><code>&quot;bool&quot;</code></td><td><code>&quot;true&quot;</code> or <code>&quot;false&quot;</code></td></tr>
<tr><td><strong>Unicode character</strong></td><td><code>char</code></td><td><code>&quot;char&quot;</code></td><td><code>&quot;A&quot;</code>, <code>&quot;x&quot;</code> etc.</td></tr>
<tr><td><strong>Immutable Unicode <a href="language//book/vnext/language/strings-chars.html">string</a></strong></td><td><code>rhai::ImmutableString</code> (implemented as <code>Rc&lt;String&gt;</code> or <code>Arc&lt;String&gt;</code>)</td><td><code>&quot;string&quot;</code></td><td><code>&quot;hello&quot;</code> etc.</td></tr>
<tr><td><strong><a href="language//book/vnext/language/arrays.html"><code>Array</code></a></strong> (disabled with <a href="language//book/vnext/start/features.html"><code>no_index</code></a>)</td><td><code>rhai::Array</code></td><td><code>&quot;array&quot;</code></td><td><code>&quot;[ ?, ?, ? ]&quot;</code></td></tr>
<tr><td><strong><a href="language//book/vnext/language/object-maps.html">Object map</a></strong> (disabled with <a href="language//book/vnext/start/features.html"><code>no_object</code></a>)</td><td><code>rhai::Map</code></td><td><code>&quot;map&quot;</code></td><td><code>&quot;#{ &quot;a&quot;: 1, &quot;b&quot;: 2 }&quot;</code></td></tr>
<tr><td><strong><a href="language//book/vnext/language/timestamps.html">Timestamp</a></strong> (implemented in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a>, disabled with <a href="language//book/vnext/start/features.html"><code>no_std</code></a>)</td><td><code>std::time::Instant</code> (<a href="https://crates.io/crates/instant"><code>instant::Instant</code></a> if <a href="language//book/vnext/start/builds/wasm.html">WASM</a> build)</td><td><code>&quot;timestamp&quot;</code></td><td><code>&quot;&lt;timestamp&gt;&quot;</code></td></tr>
<tr><td><strong><a href="language//book/vnext/language/fn-ptr.html">Function pointer</a></strong></td><td><code>rhai::FnPtr</code></td><td><code>Fn</code></td><td><code>&quot;Fn(foo)&quot;</code></td></tr>
<tr><td><strong><a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a> value</strong> (i.e. can be anything)</td><td><code>rhai::Dynamic</code></td><td><em>the actual type</em></td><td><em>actual value</em></td></tr>
<tr><td><strong>Shared value</strong> (a reference-counted, shared <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a> value, created via <a href="language//book/vnext/language/fn-closure.html">automatic currying</a>, disabled with <a href="language//book/vnext/start/features.html"><code>no_closure</code></a>)</td><td></td><td><em>the actual type</em></td><td><em>actual value</em></td></tr>
<tr><td><strong>System integer</strong> (current configuration)</td><td><code>rhai::INT</code> (<code>i32</code> or <code>i64</code>)</td><td><code>&quot;i32&quot;</code> or <code>&quot;i64&quot;</code></td><td><code>&quot;42&quot;</code>, <code>&quot;123&quot;</code> etc.</td></tr>
<tr><td><strong>System floating-point</strong> (current configuration, disabled with <a href="language//book/vnext/start/features.html"><code>no_float</code></a>)</td><td><code>rhai::FLOAT</code> (<code>f32</code> or <code>f64</code>)</td><td><code>&quot;f32&quot;</code> or <code>&quot;f64&quot;</code></td><td><code>&quot;123.456&quot;</code> etc.</td></tr>
<tr><td><strong>Nothing/void/nil/null/Unit</strong> (or whatever it is called)</td><td><code>()</code></td><td><code>&quot;()&quot;</code></td><td><code>&quot;&quot;</code> <em>(empty string)</em></td></tr>
</tbody></table>
<p>All types are treated strictly separate by Rhai, meaning that <code>i32</code> and <code>i64</code> and <code>u32</code> are completely different -
they even cannot be added together. This is very similar to Rust.</p>
<p>The default integer type is <code>i64</code>. If other integer types are not needed, it is possible to exclude them and make a
smaller build with the <a href="language//book/vnext/start/features.html"><code>only_i64</code></a> feature.</p>
<p>If only 32-bit integers are needed, enabling the <a href="language//book/vnext/start/features.html"><code>only_i32</code></a> feature will remove support for all integer types other than <code>i32</code>, including <code>i64</code>.
This is useful on some 32-bit targets where using 64-bit integers incur a performance penalty.</p>
<p>If no floating-point is needed or supported, use the <a href="language//book/vnext/start/features.html"><code>no_float</code></a> feature to remove it.</p>
<p><a href="language//book/vnext/language/strings-chars.html">Strings</a> in Rhai are <em>immutable</em>, meaning that they can be shared but not modified.  In actual, the <code>ImmutableString</code> type
is an alias to <code>Rc&lt;String&gt;</code> or <code>Arc&lt;String&gt;</code> (depending on the <a href="language//book/vnext/start/features.html"><code>sync</code></a> feature).
Any modification done to a Rhai string will cause the string to be cloned and the modifications made to the copy.</p>
<p>The <code>to_string</code> function converts a standard type into a <a href="language//book/vnext/language/strings-chars.html">string</a> for display purposes.</p>
<p>The <code>to_debug</code> function converts a standard type into a <a href="language//book/vnext/language/strings-chars.html">string</a> in debug format.</p>
<h1><a class="header" href="#dynamic-values" id="dynamic-values">Dynamic Values</a></h1>
<p>A <code>Dynamic</code> value can be <em>any</em> type. However, under <a href="language//book/vnext/start/features.html"><code>sync</code></a>, all types must be <code>Send + Sync</code>.</p>
<h2><a class="header" href="#use-type_of-to-get-value-type" id="use-type_of-to-get-value-type">Use <code>type_of()</code> to Get Value Type</a></h2>
<p>Because <a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a> a <code>Dynamic</code> value returns the type of the actual value,
it is usually used to perform type-specific actions based on the actual value’s type.</p>
<pre><code class="language-c">let mystery = get_some_dynamic_value();

switch type_of(mystery) {
    &quot;i64&quot; =&gt; print(&quot;Hey, I got an integer here!&quot;),
    &quot;f64&quot; =&gt; print(&quot;Hey, I got a float here!&quot;),
    &quot;string&quot; =&gt; print(&quot;Hey, I got a string here!&quot;),
    &quot;bool&quot; =&gt; print(&quot;Hey, I got a boolean here!&quot;),
    &quot;array&quot; =&gt; print(&quot;Hey, I got an array here!&quot;),
    &quot;map&quot; =&gt; print(&quot;Hey, I got an object map here!&quot;),
    &quot;Fn&quot; =&gt; print(&quot;Hey, I got a function pointer here!&quot;),
    &quot;TestStruct&quot; =&gt; print(&quot;Hey, I got the TestStruct custom type here!&quot;),
    _ =&gt; print(&quot;I don't know what this is: &quot; + type_of(mystery))
}
</code></pre>
<h2><a class="header" href="#functions-returning-dynamic" id="functions-returning-dynamic">Functions Returning <code>Dynamic</code></a></h2>
<p>In Rust, sometimes a <code>Dynamic</code> forms part of a returned value – a good example is an <a href="language//book/vnext/language/arrays.html">array</a>
which contains <code>Dynamic</code> elements, or an <a href="language//book/vnext/language/object-maps.html">object map</a> which contains <code>Dynamic</code> property values.</p>
<p>To get the <em>real</em> values, the actual value types <em>must</em> be known in advance.
There is no easy way for Rust to decide, at run-time, what type the <code>Dynamic</code> value is
(short of using the <code>type_name</code> function and match against the name).</p>
<h2><a class="header" href="#type-checking-and-casting" id="type-checking-and-casting">Type Checking and Casting</a></h2>
<p>A <code>Dynamic</code> value’s actual type can be checked via the <code>is</code> method.</p>
<p>The <code>cast</code> method then converts the value into a specific, known type.</p>
<p>Alternatively, use the <code>try_cast</code> method which does not panic but returns <code>None</code> when the cast fails.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list: Array = engine.eval(&quot;...&quot;)?;      // return type is 'Array'
let item = list[0];                         // an element in an 'Array' is 'Dynamic'

item.is::&lt;i64&gt;() == true;                   // 'is' returns whether a 'Dynamic' value is of a particular type

let value = item.cast::&lt;i64&gt;();             // if the element is 'i64', this succeeds; otherwise it panics
let value: i64 = item.cast();               // type can also be inferred

let value = item.try_cast::&lt;i64&gt;()?;        // 'try_cast' does not panic when the cast fails, but returns 'None'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#type-name" id="type-name">Type Name</a></h2>
<p>The <code>type_name</code> method gets the name of the actual type as a static string slice,
which can be <code>match</code>-ed against.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list: Array = engine.eval(&quot;...&quot;)?;      // return type is 'Array'
let item = list[0];                         // an element in an 'Array' is 'Dynamic'

match item.type_name() {                    // 'type_name' returns the name of the actual Rust type
    &quot;i64&quot; =&gt; ...
    &quot;alloc::string::String&quot; =&gt; ...
    &quot;bool&quot; =&gt; ...
    &quot;crate::path::to::module::TestStruct&quot; =&gt; ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> <code>type_name</code> always returns the <em>full</em> Rust path name of the type, even when the type
has been registered with a friendly name via <code>Engine::register_type_with_name</code>.  This behavior
is different from that of the <a href="language//book/vnext/language/type-of.html"><code>type_of</code></a> function in Rhai.</p>
<h2><a class="header" href="#conversion-traits" id="conversion-traits">Conversion Traits</a></h2>
<p>The following conversion traits are implemented for <code>Dynamic</code>:</p>
<ul>
<li><code>From&lt;i64&gt;</code> (<code>i32</code> if <a href="language//book/vnext/start/features.html"><code>only_i32</code></a>)</li>
<li><code>From&lt;f64&gt;</code> (if not <a href="language//book/vnext/start/features.html"><code>no_float</code></a>)</li>
<li><code>From&lt;bool&gt;</code></li>
<li><code>From&lt;rhai::ImmutableString&gt;</code></li>
<li><code>From&lt;String&gt;</code></li>
<li><code>From&lt;char&gt;</code></li>
<li><code>From&lt;Vec&lt;T&gt;&gt;</code> (into an <a href="language//book/vnext/language/arrays.html">array</a>)</li>
<li><code>From&lt;HashMap&lt;String, T&gt;&gt;</code> (into an <a href="language//book/vnext/language/object-maps.html">object map</a>)</li>
<li><code>From&lt;Instant&gt;</code> (into a <a href="language//book/vnext/language/timestamps.html">timestamp</a> if not <a href="language//book/vnext/start/features.html"><code>no_std</code></a>)</li>
</ul>
<h1><a class="header" href="#type_of" id="type_of"><code>type_of()</code></a></h1>
<p>The <code>type_of</code> function detects the actual type of a value.</p>
<p>This is useful because all variables are <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a> in nature.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use 'type_of()' to get the actual types of values
type_of('c') == &quot;char&quot;;
type_of(42) == &quot;i64&quot;;

let x = 123;
x.type_of() == &quot;i64&quot;;       // method-call style is also OK
type_of(x) == &quot;i64&quot;;

x = 99.999;
type_of(x) == &quot;f64&quot;;

x = &quot;hello&quot;;
if type_of(x) == &quot;string&quot; {
    do_something_with_string(x);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#custom-types" id="custom-types">Custom Types</a></h2>
<p><code>type_of()</code> a <a href="language//book/vnext/rust/custom.html">custom type</a> returns:</p>
<ul>
<li>
<p>the registered name, if registered via <code>Engine::register_type_with_name</code></p>
</li>
<li>
<p>the full Rust type name, if registered via <code>Engine::register_type</code></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TestStruct1;
struct TestStruct2;

engine
    // type_of(struct1) == &quot;crate::path::to::module::TestStruct1&quot;
    .register_type::&lt;TestStruct1&gt;()
    // type_of(struct2) == &quot;MyStruct&quot;
    .register_type_with_name::&lt;TestStruct2&gt;(&quot;MyStruct&quot;);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#serialization-and-deserialization-of-dynamic-with-serde" id="serialization-and-deserialization-of-dynamic-with-serde">Serialization and Deserialization of <code>Dynamic</code> with <code>serde</code></a></h1>
<p>Rhai’s <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> type supports serialization and deserialization by
<a href="https://crates.io/crates/serde"><code>serde</code></a> via the <a href="rust//book/vnext/start/features.html"><code>serde</code></a> feature.</p>
<p><a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> works <em>both</em> as a <em>serialization format</em> as well as a data type that is serializable.</p>
<h2><a class="header" href="#serializedeserialize-a-dynamic" id="serializedeserialize-a-dynamic">Serialize/Deserialize a <code>Dynamic</code></a></h2>
<p>With the <a href="rust//book/vnext/start/features.html"><code>serde</code></a> feature turned on, <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> implements
<a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>serde::Serialize</code></a> and
<a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>, so it can easily
be serialized and deserialized with <a href="https://crates.io/crates/serde"><code>serde</code></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value: Dynamic = ...;

// Serialize 'Dynamic' to JSON
let json = serde_json::to_string(&amp;value);

// Deserialize 'Dynamic' from JSON
let result: Dynamic = serde_json::from_str(&amp;json);
<span class="boring">}
</span></code></pre></pre>
<p><a href="rust//book/vnext/rust/custom.html">Custom types</a> are serialized as text strings of the value’s type name.</p>
<h2><a class="header" href="#dynamic-as-serialization-format" id="dynamic-as-serialization-format"><code>Dynamic</code> as Serialization Format</a></h2>
<p>A <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> can be seamlessly converted to and from any type that implements
<a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>serde::Serialize</code></a> and/or
<a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>, acting as a
serialization format.</p>
<h3><a class="header" href="#serialize-any-type-to-dynamic" id="serialize-any-type-to-dynamic">Serialize Any Type to <code>Dynamic</code></a></h3>
<p>The function <code>rhai::serde::to_dynamic</code> automatically converts any Rust type that implements
<a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>serde::Serialize</code></a> into a <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a>.</p>
<p>For primary types, this is usually not necessary because using <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic::from</code></a> is much
easier and is essentially the same thing.  The only difference is treatment for integer values.
<code>Dynamic::from</code> keeps different integer types intact, while <code>rhai::serde::to_dynamic</code> converts them
all into <a href="rust//book/vnext/language/values-and-types.html"><code>INT</code></a> (i.e. the system integer type which is <code>i64</code> or <code>i32</code> depending on
the <a href="rust//book/vnext/start/features.html"><code>only_i32</code></a> feature).</p>
<p>Rust <code>struct</code>‘s (or any type that is marked as a <code>serde</code> map) are converted into <a href="rust//book/vnext/language/object-maps.html">object maps</a> while
Rust <code>Vec</code>‘s (or any type that is marked as a <code>serde</code> sequence) are converted into <a href="rust//book/vnext/language/arrays.html">arrays</a>.</p>
<p>While it is also simple to serialize a Rust type to <code>JSON</code> via <code>serde</code>,
then use <a href="rust//book/vnext/language/json.html"><code>Engine::parse_json</code></a> to convert it into an <a href="rust//book/vnext/language/object-maps.html">object map</a>,
<code>rhai::serde::to_dynamic</code> serializes it to <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> directly via <code>serde</code> without going through the <code>JSON</code> step.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Dynamic, Map};
use rhai::serde::to_dynamic;

#[derive(Debug, serde::Serialize)]
struct Point {
    x: f64,
    y: f64
}

#[derive(Debug, serde::Serialize)]
struct MyStruct {
    a: i64,
    b: Vec&lt;String&gt;,
    c: bool,
    d: Point
}

let x = MyStruct {
    a: 42,
    b: vec![ &quot;hello&quot;.into(), &quot;world&quot;.into() ],
    c: true,
    d: Point { x: 123.456, y: 999.0 }
};

// Convert the 'MyStruct' into a 'Dynamic'
let map: Dynamic = to_dynamic(x);

map.is::&lt;Map&gt;() == true;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#deserialize-a-dynamic-into-any-type" id="deserialize-a-dynamic-into-any-type">Deserialize a <code>Dynamic</code> into Any Type</a></h3>
<p>The function <code>rhai::serde::from_dynamic</code> automatically converts a <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> value into any Rust type
that implements <a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.</p>
<p>In particular, <a href="rust//book/vnext/language/object-maps.html">object maps</a> are converted into Rust <code>struct</code>‘s (or any type that is marked as
a <code>serde</code> map) while <a href="rust//book/vnext/language/arrays.html">arrays</a> are converted into Rust <code>Vec</code>‘s (or any type that is marked
as a <code>serde</code> sequence).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Dynamic};
use rhai::serde::from_dynamic;

#[derive(Debug, serde::Deserialize)]
struct Point {
    x: f64,
    y: f64
}

#[derive(Debug, serde::Deserialize)]
struct MyStruct {
    a: i64,
    b: Vec&lt;String&gt;,
    c: bool,
    d: Point
}

let engine = Engine::new();

let result: Dynamic = engine.eval(r#&quot;
            #{
                a: 42,
                b: [ &quot;hello&quot;, &quot;world&quot; ],
                c: true,
                d: #{ x: 123.456, y: 999.0 }
            }
        &quot;#)?;

// Convert the 'Dynamic' object map into 'MyStruct'
let x: MyStruct = from_dynamic(&amp;result)?;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#cannot-deserialize-shared-values" id="cannot-deserialize-shared-values">Cannot Deserialize Shared Values</a></h3>
<p>A <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> containing a <em>shared</em> value cannot be deserialized – i.e. it will give a type error.</p>
<p>Use <code>Dynamic::flatten</code> to obtain a cloned copy before deserialization
(if the value is not shared, it is simply returned and not cloned).</p>
<p>Shared values are turned off via the <a href="rust//book/vnext/start/features.html"><code>no_closure</code></a> feature.</p>
<h2><a class="header" href="#lighter-alternative" id="lighter-alternative">Lighter Alternative</a></h2>
<p>The <a href="https://crates.io/crates/serde"><code>serde</code></a> crate is quite heavy.</p>
<p>If only <em>simple</em> JSON parsing (i.e. only deserialization) of a hash object into a Rhai <a href="rust//book/vnext/language/object-maps.html">object map</a> is required,
the <a href="rust//book/vnext/language/json.html"><code>Engine::parse_json</code></a> method is available as a <em>cheap</em> alternative,
but it does not provide the same level of correctness, nor are there any configurable options.</p>
<h1><a class="header" href="#numbers" id="numbers">Numbers</a></h1>
<p>Integer numbers follow C-style format with support for decimal, binary (’<code>0b</code>‘), octal (’<code>0o</code>‘) and hex (’<code>0x</code>‘) notations.</p>
<p>The default system integer type (also aliased to <code>INT</code>) is <code>i64</code>. It can be turned into <code>i32</code> via the <a href="language//book/vnext/start/features.html"><code>only_i32</code></a> feature.</p>
<p>Floating-point numbers are also supported if not disabled with <a href="language//book/vnext/start/features.html"><code>no_float</code></a>. The default system floating-point type is <code>i64</code>
(also aliased to <code>FLOAT</code>). It can be turned into <code>f32</code> via the <a href="language//book/vnext/start/features.html"><code>f32_float</code></a> feature.</p>
<p>‘<code>_</code>‘ separators can be added freely and are ignored within a number – except at the very beginning or right after
a decimal point (’<code>.</code>‘).</p>
<table><thead><tr><th>Format</th><th>Type</th></tr></thead><tbody>
<tr><td><code>123_345</code>, <code>-42</code></td><td><code>INT</code> in decimal</td></tr>
<tr><td><code>0o07_76</code></td><td><code>INT</code> in octal</td></tr>
<tr><td><code>0xabcd_ef</code></td><td><code>INT</code> in hex</td></tr>
<tr><td><code>0b0101_1001</code></td><td><code>INT</code> in binary</td></tr>
<tr><td><code>123_456.789</code>, <code>-42.</code></td><td><code>FLOAT</code></td></tr>
</tbody></table>
<h1><a class="header" href="#numeric-operators" id="numeric-operators">Numeric Operators</a></h1>
<p>Numeric operators generally follow C styles.</p>
<h2><a class="header" href="#unary-operators" id="unary-operators">Unary Operators</a></h2>
<table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>positive</td></tr>
<tr><td><code>-</code></td><td>negative</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = -5;

number = -5 - +5;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#binary-operators" id="binary-operators">Binary Operators</a></h2>
<table><thead><tr><th>Operator</th><th>Description</th><th align="center">Integers only</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>plus</td><td align="center"></td></tr>
<tr><td><code>-</code></td><td>minus</td><td align="center"></td></tr>
<tr><td><code>*</code></td><td>multiply</td><td align="center"></td></tr>
<tr><td><code>/</code></td><td>divide (integer division if acting on integer types)</td><td align="center"></td></tr>
<tr><td><code>%</code></td><td>modulo (remainder)</td><td align="center"></td></tr>
<tr><td><code>~</code></td><td>power</td><td align="center"></td></tr>
<tr><td><code>&amp;</code></td><td>bit-wise <em>And</em></td><td align="center">Yes</td></tr>
<tr><td><code>|</code></td><td>bit-wise <em>Or</em></td><td align="center">Yes</td></tr>
<tr><td><code>^</code></td><td>bit-wise <em>Xor</em></td><td align="center">Yes</td></tr>
<tr><td><code>&lt;&lt;</code></td><td>left bit-shift</td><td align="center">Yes</td></tr>
<tr><td><code>&gt;&gt;</code></td><td>right bit-shift</td><td align="center">Yes</td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (1 + 2) * (6 - 4) / 2;  // arithmetic, with parentheses

let reminder = 42 % 10;         // modulo

let power = 42 ~ 2;             // power (i64 and f64 only)

let left_shifted = 42 &lt;&lt; 3;     // left shift

let right_shifted = 42 &gt;&gt; 3;    // right shift

let bit_op = 42 | 99;           // bit masking
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#numeric-functions" id="numeric-functions">Numeric Functions</a></h1>
<h2><a class="header" href="#integer-functions" id="integer-functions">Integer Functions</a></h2>
<p>The following standard functions (defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicMathPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code> and <code>f64</code> only:</p>
<table><thead><tr><th>Function</th><th align="center">No available under</th><th>Description</th></tr></thead><tbody>
<tr><td><code>abs</code></td><td align="center"></td><td>absolute value</td></tr>
<tr><td><code>sign</code></td><td align="center"></td><td>returns -1 (<code>INT</code>) if the number is negative, +1 if positive, 0 if zero</td></tr>
</tbody></table>
<h2><a class="header" href="#floating-point-functions" id="floating-point-functions">Floating-Point Functions</a></h2>
<p>The following standard functions (defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicMathPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on <code>f64</code> only:</p>
<table><thead><tr><th>Category</th><th>Functions</th></tr></thead><tbody>
<tr><td>Trigonometry</td><td><code>sin</code>, <code>cos</code>, <code>tan</code>, <code>sinh</code>, <code>cosh</code>, <code>tanh</code> in degrees</td></tr>
<tr><td>Arc-trigonometry</td><td><code>asin</code>, <code>acos</code>, <code>atan</code>, <code>asinh</code>, <code>acosh</code>, <code>atanh</code> in degrees</td></tr>
<tr><td>Square root</td><td><code>sqrt</code></td></tr>
<tr><td>Exponential</td><td><code>exp</code> (base <em>e</em>)</td></tr>
<tr><td>Logarithmic</td><td><code>ln</code> (base <em>e</em>), <code>log10</code> (base 10), <code>log</code> (any base)</td></tr>
<tr><td>Rounding</td><td><code>floor</code>, <code>ceiling</code>, <code>round</code>, <code>int</code>, <code>fraction</code> methods and properties</td></tr>
<tr><td>Conversion</td><td><a href="language//book/vnext/language/convert.html"><code>to_int</code></a></td></tr>
<tr><td>Testing</td><td><code>is_nan</code>, <code>is_finite</code>, <code>is_infinite</code> methods and properties</td></tr>
</tbody></table>
<h2><a class="header" href="#conversion-functions" id="conversion-functions">Conversion Functions</a></h2>
<p>The following standard functions (defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicMathPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>)
parse numbers:</p>
<table><thead><tr><th>Function</th><th align="center">No available under</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="language//book/vnext/language/convert.html"><code>to_float</code></a></td><td align="center"><a href="language//book/vnext/start/features.html"><code>no_float</code></a></td><td>converts an integer type to <code>FLOAT</code></td></tr>
<tr><td><a href="language//book/vnext/language/convert.html"><code>parse_int</code></a></td><td align="center"></td><td>converts a <a href="language//book/vnext/language/strings-chars.html">string</a> to <code>INT</code> with an optional radix</td></tr>
<tr><td><a href="language//book/vnext/language/convert.html"><code>parse_float</code></a></td><td align="center"><a href="language//book/vnext/start/features.html"><code>no_float</code></a></td><td>converts a <a href="language//book/vnext/language/strings-chars.html">string</a> to <code>FLOAT</code></td></tr>
</tbody></table>
<h1><a class="header" href="#value-conversions" id="value-conversions">Value Conversions</a></h1>
<h2><a class="header" href="#convert-between-integer-and-floating-point" id="convert-between-integer-and-floating-point">Convert Between Integer and Floating-Point</a></h2>
<p>The <code>to_float</code> function converts a supported number to <code>FLOAT</code> (defaults to <code>f64</code>).</p>
<p>The <code>to_int</code> function converts a supported number to <code>INT</code> (<code>i32</code> or <code>i64</code> depending on <a href="language//book/vnext/start/features.html"><code>only_i32</code></a>).</p>
<p>That’s it; for other conversions, register custom conversion functions.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;

let y = x * 100.0;              // &lt;- error: cannot multiply i64 with f64

let y = x.to_float() * 100.0;   // works

let z = y.to_int() + x;         // works

let c = 'X';                    // character

print(&quot;c is '&quot; + c + &quot;' and its code is &quot; + c.to_int());    // prints &quot;c is 'X' and its code is 88&quot;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#parse-string-into-number" id="parse-string-into-number">Parse String into Number</a></h2>
<p>The <code>parse_float</code> function converts a <a href="language//book/vnext/language/strings-chars.html">string</a> into a <code>FLOAT</code> (defaults to <code>f64</code>).</p>
<p>The <code>parse_int</code> function converts a <a href="language//book/vnext/language/strings-chars.html">string</a> into an <code>INT</code> (<code>i32</code> or <code>i64</code> depending on <a href="language//book/vnext/start/features.html"><code>only_i32</code></a>).
An optional radix (2-36) can be provided to parse the <a href="language//book/vnext/language/strings-chars.html">string</a> into a number of the specified radix.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = parse_float(&quot;123.4&quot;);   // parse as floating-point
x == 123.4;
type_of(x) == &quot;f64&quot;;

let dec = parse_int(&quot;42&quot;);      // parse as decimal
let dec = parse_int(&quot;42&quot;, 10);  // radix = 10 is the default
dec == 42;
type_of(dec) == &quot;i64&quot;;

let bin = parse_int(&quot;110&quot;, 2);  // parse as binary (radix = 2)
bin == 0b110;
type_of(bin) == &quot;i64&quot;;

let hex = parse_int(&quot;ab&quot;, 16);  // parse as hex (radix = 16)
hex == 0xab;
type_of(hex) == &quot;i64&quot;;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#strings-and-characters" id="strings-and-characters">Strings and Characters</a></h1>
<p>String in Rhai contain any text sequence of valid Unicode characters.
Internally strings are stored in UTF-8 encoding.</p>
<p>Strings can be built up from other strings and types via the <code>+</code> operator
(provided by the <a href="language//book/vnext/rust/packages/index.html"><code>MoreStringPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>).
This is particularly useful when printing output.</p>
<p><a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a> a string returns <code>&quot;string&quot;</code>.</p>
<p>The maximum allowed length of a string can be controlled via <code>Engine::set_max_string_size</code>
(see <a href="language//book/vnext/safety/max-string-size.html">maximum length of strings</a>).</p>
<h2><a class="header" href="#the-immutablestring-type" id="the-immutablestring-type">The <code>ImmutableString</code> Type</a></h2>
<p>All strings in Rhai are implemented as <code>ImmutableString</code> (see <a href="language//book/vnext/language/values-and-types.html">standard types</a>).
An <code>ImmutableString</code> does not change and can be shared.</p>
<p>Modifying an <code>ImmutableString</code> causes it first to be cloned, and then the modification made to the copy.</p>
<h3><a class="header" href="#important--avoid-string-parameters" id="important--avoid-string-parameters"><strong>IMPORTANT</strong> – Avoid <code>String</code> Parameters</a></h3>
<p><code>ImmutableString</code> should be used in place of <code>String</code> for function parameters because using
<code>String</code> is very inefficient (the <code>String</code> argument is cloned during every call).</p>
<p>A alternative is to use <code>&amp;str</code> which de-sugars to <code>ImmutableString</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn slow(s: String) -&gt; i64 { ... }               // string is cloned each call

fn fast1(s: ImmutableString) -&gt; i64 { ... }     // cloning 'ImmutableString' is cheap

fn fast2(s: &amp;str) -&gt; i64 { ... }                // de-sugars to above
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#string-and-character-literals" id="string-and-character-literals">String and Character Literals</a></h2>
<p>String and character literals follow C-style formatting, with support for Unicode (’<code>\u</code><em>xxxx</em>‘ or ‘<code>\U</code><em>xxxxxxxx</em>‘)
and hex (’<code>\x</code><em>xx</em>‘) escape sequences.</p>
<p>Hex sequences map to ASCII characters, while ‘<code>\u</code>‘ maps to 16-bit common Unicode code points and ‘<code>\U</code>‘ maps the full,
32-bit extended Unicode code points.</p>
<p>Standard escape sequences:</p>
<table><thead><tr><th>Escape sequence</th><th>Meaning</th></tr></thead><tbody>
<tr><td><code>\\</code></td><td>back-slash <code>\</code></td></tr>
<tr><td><code>\t</code></td><td>tab</td></tr>
<tr><td><code>\r</code></td><td>carriage-return <code>CR</code></td></tr>
<tr><td><code>\n</code></td><td>line-feed <code>LF</code></td></tr>
<tr><td><code>\&quot;</code></td><td>double-quote <code>&quot;</code></td></tr>
<tr><td><code>\'</code></td><td>single-quote <code>'</code></td></tr>
<tr><td><code>\x</code><em>xx</em></td><td>ASCII character in 2-digit hex</td></tr>
<tr><td><code>\u</code><em>xxxx</em></td><td>Unicode character in 4-digit hex</td></tr>
<tr><td><code>\U</code><em>xxxxxxxx</em></td><td>Unicode character in 8-digit hex</td></tr>
</tbody></table>
<h2><a class="header" href="#differences-from-rust-strings" id="differences-from-rust-strings">Differences from Rust Strings</a></h2>
<p>Internally Rhai strings are stored as UTF-8 just like Rust (they <em>are</em> Rust <code>String</code>‘s!),
but nevertheless there are major differences.</p>
<p>In Rhai a string is the same as an array of Unicode characters and can be directly indexed (unlike Rust).</p>
<p>This is similar to most other languages where strings are internally represented not as UTF-8 but as arrays of multi-byte
Unicode characters.</p>
<p>Individual characters within a Rhai string can also be replaced just as if the string is an array of Unicode characters.</p>
<p>In Rhai, there are also no separate concepts of <code>String</code> and <code>&amp;str</code> as in Rust.</p>
<h2><a class="header" href="#examples-5" id="examples-5">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = &quot;Bob&quot;;
let middle_initial = 'C';
let last = &quot;Davis&quot;;

let full_name = name + &quot; &quot; + middle_initial + &quot;. &quot; + last;
full_name == &quot;Bob C. Davis&quot;;

// String building with different types
let age = 42;
let record = full_name + &quot;: age &quot; + age;
record == &quot;Bob C. Davis: age 42&quot;;

// Unlike Rust, Rhai strings can be indexed to get a character
// (disabled with 'no_index')
let c = record[4];
c == 'C';

ts.s = record;                          // custom type properties can take strings

let c = ts.s[4];
c == 'C';

let c = &quot;foo&quot;[0];                       // indexing also works on string literals...
c == 'f';

let c = (&quot;foo&quot; + &quot;bar&quot;)[5];             // ... and expressions returning strings
c == 'r';

// Escape sequences in strings
record += &quot; \u2764\n&quot;;                  // escape sequence of '❤' in Unicode
record == &quot;Bob C. Davis: age 42 ❤\n&quot;;   // '\n' = new-line

// Unlike Rust, Rhai strings can be directly modified character-by-character
// (disabled with 'no_index')
record[4] = '\x58'; // 0x58 = 'X'
record == &quot;Bob X. Davis: age 42 ❤\n&quot;;

// Use 'in' to test if a substring (or character) exists in a string
&quot;Davis&quot; in record == true;
'X' in record == true;
'C' in record == false;

// Strings can be iterated with a 'for' statement, yielding characters
for ch in record {
    print(ch);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#built-in-string-functions" id="built-in-string-functions">Built-in String Functions</a></h1>
<p>The following standard methods (mostly defined in the <a href="language//book/vnext/rust/packages/index.html"><code>MoreStringPackage</code></a> but excluded if
using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on <a href="language//book/vnext/language/strings-chars.html">strings</a>:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>len</code> method and property</td><td><em>none</em></td><td>returns the number of characters (not number of bytes) in the string</td></tr>
<tr><td><code>pad</code></td><td>1) target length<br/>2) character/string to pad</td><td>pads the string with a character or a string to at least a specified length</td></tr>
<tr><td><code>+=</code> operator, <code>append</code></td><td>character/string to append</td><td>Adds a character or a string to the end of another string</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the string</td></tr>
<tr><td><code>truncate</code></td><td>target length</td><td>cuts off the string at exactly a specified number of characters</td></tr>
<tr><td><code>contains</code></td><td>character/sub-string to search for</td><td>checks if a certain character or sub-string occurs in the string</td></tr>
<tr><td><code>index_of</code></td><td>1) character/sub-string to search for<br/>2) <em>(optional)</em> start index</td><td>returns the index that a certain character or sub-string occurs in the string, or -1 if not found</td></tr>
<tr><td><code>sub_string</code></td><td>1) start index<br/>2) <em>(optional)</em> number of characters to extract, none if &lt; 0</td><td>extracts a sub-string (to the end of the string if length is not specified)</td></tr>
<tr><td><code>split</code></td><td>delimiter character/string</td><td>splits the string by the specified delimiter, returning an <a href="language//book/vnext/language/arrays.html">array</a> of string segments; not available under <a href="language//book/vnext/start/features.html"><code>no_index</code></a></td></tr>
<tr><td><code>crop</code></td><td>1) start index<br/>2) <em>(optional)</em> number of characters to retain, none if &lt; 0</td><td>retains only a portion of the string</td></tr>
<tr><td><code>replace</code></td><td>1) target character/sub-string<br/>2) replacement character/string</td><td>replaces a sub-string with another</td></tr>
<tr><td><code>trim</code></td><td><em>none</em></td><td>trims the string of whitespace at the beginning and end</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-6" id="examples-6">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let full_name == &quot; Bob C. Davis &quot;;
full_name.len == 14;

full_name.trim();
full_name.len == 12;
full_name == &quot;Bob C. Davis&quot;;

full_name.pad(15, '$');
full_name.len == 15;
full_name == &quot;Bob C. Davis$$$&quot;;

let n = full_name.index_of('$');
n == 12;

full_name.index_of(&quot;$$&quot;, n + 1) == 13;

full_name.sub_string(n, 3) == &quot;$$$&quot;;

full_name.truncate(6);
full_name.len == 6;
full_name == &quot;Bob C.&quot;;

full_name.replace(&quot;Bob&quot;, &quot;John&quot;);
full_name.len == 7;
full_name == &quot;John C.&quot;;

full_name.contains('C') == true;
full_name.contains(&quot;John&quot;) == true;

full_name.crop(5);
full_name == &quot;C.&quot;;

full_name.crop(0, 1);
full_name == &quot;C&quot;;

full_name.clear();
full_name.len == 0;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>Arrays are first-class citizens in Rhai. Like C, arrays are accessed with zero-based, non-negative integer indices:</p>
<blockquote>
<p><em>array</em> <code>[</code> <em>index</em> <code>]</code></p>
</blockquote>
<p>Array literals are built within square brackets ‘<code>[</code>‘ ... ‘<code>]</code>‘ and separated by commas ‘<code>,</code>‘:</p>
<blockquote>
<p><code>[</code> <em>value</em> <code>,</code> <em>value</em> <code>,</code> <code>...</code> <code>,</code> <em>value</em> <code>]</code></p>
<p><code>[</code> <em>value</em> <code>,</code> <em>value</em> <code>,</code> <code>...</code> <code>,</code> <em>value</em> <code>,</code> <code>]</code>     <code>// trailing comma is OK</code></p>
</blockquote>
<p>All elements stored in an array are <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a>, and the array can freely grow or shrink with elements added or removed.</p>
<p>The Rust type of a Rhai array is <code>rhai::Array</code>.</p>
<p><a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a> an array returns <code>&quot;array&quot;</code>.</p>
<p>Arrays are disabled via the <a href="language//book/vnext/start/features.html"><code>no_index</code></a> feature.</p>
<p>The maximum allowed size of an array can be controlled via <code>Engine::set_max_array_size</code>
(see <a href="language//book/vnext/safety/max-array-size.html">maximum size of arrays</a>.</p>
<h2><a class="header" href="#built-in-functions" id="built-in-functions">Built-in Functions</a></h2>
<p>The following methods (mostly defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicArrayPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on arrays:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>push</code></td><td>element to insert</td><td>inserts an element at the end</td></tr>
<tr><td><code>append</code></td><td>array to append</td><td>concatenates the second array to the end of the first</td></tr>
<tr><td><code>+=</code> operator</td><td>1) array<br/>2) element to insert (not another array)</td><td>inserts an element at the end</td></tr>
<tr><td><code>+=</code> operator</td><td>1) array<br/>2) array to append</td><td>concatenates the second array to the end of the first</td></tr>
<tr><td><code>+</code> operator</td><td>1) first array<br/>2) second array</td><td>concatenates the first array with the second</td></tr>
<tr><td><code>==</code> operator</td><td>1) first array<br/>2) second array</td><td>are the two arrays the same (elements compared with the <code>==</code> operator, if defined)?</td></tr>
<tr><td><code>!=</code> operator</td><td>1) first array<br/>2) second array</td><td>are the two arrays different (elements compared with the <code>==</code> operator, if defined)?</td></tr>
<tr><td><code>in</code> operator</td><td>item to find</td><td>does the array contain the item (compared with the <code>==</code> operator, if defined)?</td></tr>
<tr><td><code>insert</code></td><td>1) element to insert<br/>2) position, beginning if &lt; 0, end if &gt; length</td><td>inserts an element at a certain index</td></tr>
<tr><td><code>pop</code></td><td><em>none</em></td><td>removes the last element and returns it (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> if empty)</td></tr>
<tr><td><code>shift</code></td><td><em>none</em></td><td>removes the first element and returns it (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> if empty)</td></tr>
<tr><td><code>extract</code></td><td>1) start position, beginning if &lt; 0, end if &gt; length<br/>2) <em>(optional)</em> number of items to extract, none if &lt; 0</td><td>extracts a portion of the array into a new array</td></tr>
<tr><td><code>remove</code></td><td>index</td><td>removes an element at a particular index and returns it (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> if the index is not valid)</td></tr>
<tr><td><code>reverse</code></td><td><em>none</em></td><td>reverses the array</td></tr>
<tr><td><code>len</code> method and property</td><td><em>none</em></td><td>returns the number of elements</td></tr>
<tr><td><code>pad</code></td><td>1) target length<br/>2) element to pad</td><td>pads the array with an element to at least a specified length</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the array</td></tr>
<tr><td><code>truncate</code></td><td>target length</td><td>cuts off the array at exactly a specified length (discarding all subsequent elements)</td></tr>
<tr><td><code>chop</code></td><td>target length</td><td>cuts off the head of the array, leaving the tail at exactly a specified length</td></tr>
<tr><td><code>drain</code></td><td>1) <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)<br/>2) <em>(optional)</em> <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>) that provides the initial value</td><td>removes all items (returning them) that return <code>true</code> when called with the predicate function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>drain</code></td><td>1) start position, beginning if &lt; 0, end if &gt; length<br/>2) number of items to remove, none if &lt; 0</td><td>removes a portion of the array, returning the removed items (not in original order)</td></tr>
<tr><td><code>retain</code></td><td>1) <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)<br/>2) <em>(optional)</em> <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>) that provides the initial value</td><td>removes all items (returning them) that do not return <code>true</code> when called with the predicate function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>retain</code></td><td>1) start position, beginning if &lt; 0, end if &gt; length<br/>2) number of items to retain, none if &lt; 0</td><td>retains a portion of the array, removes all other items and returning them (not in original order)</td></tr>
<tr><td><code>splice</code></td><td>1) start position, beginning if &lt; 0, end if &gt; length<br/>2) number of items to remove, none if &lt; 0<br/>3) array to insert</td><td>replaces a portion of the array with another (not necessarily of the same length as the replaced portion)</td></tr>
<tr><td><code>filter</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>constructs a new array with all items that return <code>true</code> when called with the predicate function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>index_of</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>returns the index of the first item in the array that returns <code>true</code> when called with the predicate function, or -1 if not found:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>map</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to conversion function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>constructs a new array with all items mapped to the result of applying the conversion function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>reduce</code></td><td>1) <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to accumulator function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)<br/>2) <em>(optional)</em> <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>) that provides the initial value</td><td>reduces the array into a single value via the accumulator function:<br/>1st parameter: accumulated value (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> initially)<br/>2nd parameter: array item<br/>3rd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>reduce_rev</code></td><td>1) <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to accumulator function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)<br/>2) <em>(optional)</em> <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>) that provides the initial value</td><td>reduces the array (in reverse order) into a single value via the accumulator function:<br/>1st parameter: accumulated value (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> initially)<br/>2nd parameter: array item<br/>3rd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>some</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>returns <code>true</code> if any item returns <code>true</code> when called with the predicate function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>all</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to predicate (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>returns <code>true</code> if all items return <code>true</code> when called with the predicate function:<br/>1st parameter: array item<br/>2nd parameter: <em>(optional)</em> offset index</td></tr>
<tr><td><code>sort</code></td><td><a href="language//book/vnext/language/fn-ptr.html">function pointer</a> to a comparison function (usually a <a href="language//book/vnext/language/fn-closure.html">closure</a>)</td><td>sorts the array with a comparison function:<br/>1st parameter: first item<br/>2nd parameter: second item<br/>return value: <code>INT</code> &lt; 0 if first &lt; second, &gt; 0 if first &gt; second, 0 if first == second</td></tr>
</tbody></table>
<h2><a class="header" href="#use-custom-types-with-arrays" id="use-custom-types-with-arrays">Use Custom Types With Arrays</a></h2>
<p>To use a <a href="language//book/vnext/rust/custom.html">custom type</a> with arrays, a number of array functions need to be manually implemented,
in particular <code>push</code>, <code>insert</code>, <code>pad</code> and the <code>+=</code> operator.  In addition, the <code>==</code> operator must be
implemented for the <a href="language//book/vnext/rust/custom.html">custom type</a> in order to support the <code>in</code> operator which uses <code>==</code> to
compare elements.</p>
<p>See the section on <a href="language//book/vnext/rust/custom.html">custom types</a> for more details.</p>
<h2><a class="header" href="#examples-7" id="examples-7">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = [2, 3];             // y == [2, 3]

let y = [2, 3,];            // y == [2, 3]

y.insert(0, 1);             // y == [1, 2, 3]

y.insert(999, 4);           // y == [1, 2, 3, 4]

y.len == 4;

y[0] == 1;
y[1] == 2;
y[2] == 3;
y[3] == 4;

(1 in y) == true;           // use 'in' to test if an item exists in the array
(42 in y) == false;         // 'in' uses the '==' operator (which users can override)
                            // to check if the target item exists in the array

y[1] = 42;                  // y == [1, 42, 3, 4]

(42 in y) == true;

y.remove(2) == 3;           // y == [1, 42, 4]

y.len == 3;

y[2] == 4;                  // elements after the removed element are shifted

ts.list = y;                // arrays can be assigned completely (by value copy)

ts.list[1] == 42;

[1, 2, 3][0] == 1;          // indexing on array literal

fn abc() {
    [42, 43, 44]            // a function returning an array
}

abc()[0] == 42;

y.push(4);                  // y == [1, 42, 4, 4]

y += 5;                     // y == [1, 42, 4, 4, 5]

y.len == 5;

y.shift() == 1;             // y == [42, 4, 4, 5]

y.chop(3);                  // y == [4, 4, 5]

y.len == 3;

y.pop() == 5;               // y == [4, 4]

y.len == 2;

for item in y {             // arrays can be iterated with a 'for' statement
    print(item);
}

y.pad(6, &quot;hello&quot;);          // y == [4, 4, &quot;hello&quot;, &quot;hello&quot;, &quot;hello&quot;, &quot;hello&quot;]

y.len == 6;

y.truncate(4);              // y == [4, 4, &quot;hello&quot;, &quot;hello&quot;]

y.len == 4;

y.clear();                  // y == []

y.len == 0;

let a = [42, 123, 99];

a.map(|v| v + 1);           // returns [43, 124, 100]

a.map(|v, i| v + i);        // returns [42, 124, 101]

a.filter(|v| v &gt; 50);       // returns [123, 99]

a.filter(|v, i| i == 1);    // returns [123]

// Use a closure to provide the initial value
a.reduce(|sum, v| sum + v, || 0) == 264;

// Detect the initial value of '()'
a.reduce(
    |sum, v| if sum.type_of() == &quot;()&quot; { v } else { sum + v }
) == 264;

// Detect the initial value via index
a.reduce(|sum, v, i|
    if i == 0 { v } else { sum + v }
) == 264;

// Use a closure to provide the initial value
a.reduce_rev(|sum, v| sum + v, || 0) == 264;

// Detect the initial value of '()'
a.reduce_rev(
    |sum, v| if sum.type_of() == &quot;()&quot; { v } else { sum + v }
) == 264;

// Detect the initial value via index
a.reduce_rev(|sum, v, i|
    if i == 2 { v } else { sum + v }
) == 264;

a.some(|v| v &gt; 50);         // returns true

a.some(|v, i| v &lt; i);       // returns false

a.none(|v| v != 0);         // returns false

a.none(|v, i| v == i);      // returns true

a.all(|v| v &gt; 50);          // returns false

a.all(|v, i| v &gt; i);        // returns true

a.splice(1, 1, [1, 3, 2]);  // a == [42, 1, 3, 2, 99]

a.extract(1, 3);            // returns [1, 3, 2]

a.sort(|x, y| x - y);       // a == [1, 2, 3, 42, 99]

a.drain(|v| v &lt;= 1);        // a == [2, 3, 42, 99]

a.drain(|v, i| i &gt;= 3);     // a == [2, 3, 42]

a.retain(|v| v &gt; 10);       // a == [42]

a.retain(|v, i| i &gt; 0);     // a == []
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#object-maps" id="object-maps">Object Maps</a></h1>
<p>Object maps are hash dictionaries. Properties are all <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a> and can be freely added and retrieved.</p>
<p>The Rust type of a Rhai object map is <code>rhai::Map</code>.</p>
<p><a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a> an object map returns <code>&quot;map&quot;</code>.</p>
<p>Object maps are disabled via the <a href="language//book/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<p>The maximum allowed size of an object map can be controlled via <code>Engine::set_max_map_size</code>
(see <a href="language//book/vnext/safety/max-map-size.html">maximum size of object maps</a>).</p>
<h2><a class="header" href="#object-map-literals" id="object-map-literals">Object Map Literals</a></h2>
<p>Object map literals are built within braces ‘<code>#{</code>‘ ... ‘<code>}</code>‘ (<em>name</em> <code>:</code> <em>value</em> syntax similar to Rust)
and separated by commas ‘<code>,</code>‘:</p>
<blockquote>
<p><code>#{</code> <em>property</em> <code>:</code> <em>value</em> <code>,</code> <code>...</code> <code>,</code> <em>property</em> <code>:</code> <em>value</em> <code>}</code></p>
<p><code>#{</code> <em>property</em> <code>:</code> <em>value</em> <code>,</code> <code>...</code> <code>,</code> <em>property</em> <code>:</code> <em>value</em> <code>,</code> <code>}</code>  <code>// trailing comma is OK</code></p>
</blockquote>
<p>The property <em>name</em> can be a simple variable name following the same
naming rules as <a href="language//book/vnext/language/variables.html">variables</a>, or an arbitrary <a href="language//book/vnext/language/strings-chars.html">string</a> literal.</p>
<h2><a class="header" href="#access-properties" id="access-properties">Access Properties</a></h2>
<h3><a class="header" href="#dot-notation" id="dot-notation">Dot Notation</a></h3>
<p>The <em>dot notation</em> allows only property names that follow the same naming rules as <a href="language//book/vnext/language/variables.html">variables</a>.</p>
<blockquote>
<p><em>object</em> <code>.</code> <em>property</em></p>
</blockquote>
<h3><a class="header" href="#index-notation" id="index-notation">Index Notation</a></h3>
<p>The <em>index notation</em> allows setting/getting properties of arbitrary names (even the empty <a href="language//book/vnext/language/strings-chars.html">string</a>).</p>
<blockquote>
<p><em>object</em> <code>[</code> <em>property</em> <code>]</code></p>
</blockquote>
<h3><a class="header" href="#non-existence" id="non-existence">Non-Existence</a></h3>
<p>Trying to read a non-existing property returns <a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> instead of causing an error.</p>
<p>This is similar to JavaScript where accessing a non-existing property returns <code>undefined</code>.</p>
<h2><a class="header" href="#built-in-functions-1" id="built-in-functions-1">Built-in Functions</a></h2>
<p>The following methods (defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicMapPackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>)
operate on object maps:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>has</code>, <code>in</code> operator</td><td>property name</td><td>does the object map contain a property of a particular name?</td></tr>
<tr><td><code>len</code></td><td><em>none</em></td><td>returns the number of properties</td></tr>
<tr><td><code>clear</code></td><td><em>none</em></td><td>empties the object map</td></tr>
<tr><td><code>remove</code></td><td>property name</td><td>removes a certain property and returns it (<a href="language//book/vnext/language/values-and-types.html"><code>()</code></a> if the property does not exist)</td></tr>
<tr><td><code>+=</code> operator, <code>mixin</code></td><td>second object map</td><td>mixes in all the properties of the second object map to the first (values of properties with the same names replace the existing values)</td></tr>
<tr><td><code>+</code> operator</td><td>1) first object map<br/>2) second object map</td><td>merges the first object map with the second</td></tr>
<tr><td><code>==</code> operator</td><td>1) first object map<br/>2) second object map</td><td>are the two object map the same (elements compared with the <code>==</code> operator, if defined)?</td></tr>
<tr><td><code>!=</code> operator</td><td>1) first object map<br/>2) second object map</td><td>are the two object map different (elements compared with the <code>==</code> operator, if defined)?</td></tr>
<tr><td><code>fill_with</code></td><td>second object map</td><td>adds in all properties of the second object map that do not exist in the object map</td></tr>
<tr><td><code>keys</code></td><td><em>none</em></td><td>returns an <a href="language//book/vnext/language/arrays.html">array</a> of all the property names (in random order), not available under <a href="language//book/vnext/start/features.html"><code>no_index</code></a></td></tr>
<tr><td><code>values</code></td><td><em>none</em></td><td>returns an <a href="language//book/vnext/language/arrays.html">array</a> of all the property values (in random order), not available under <a href="language//book/vnext/start/features.html"><code>no_index</code></a></td></tr>
</tbody></table>
<h2><a class="header" href="#examples-8" id="examples-8">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = #{              // object map literal with 3 properties
    a: 1,
    bar: &quot;hello&quot;,
    &quot;baz!$@&quot;: 123.456,  // like JavaScript, you can use any string as property names...
    &quot;&quot;: false,          // even the empty string!

    a: 42               // &lt;- syntax error: duplicated property name
};

y.a = 42;               // access via dot notation
y.baz!$@ = 42;          // &lt;- syntax error: only proper variable names allowed in dot notation
y.&quot;baz!$@&quot; = 42;        // &lt;- syntax error: strings not allowed in dot notation

y.a == 42;

y[&quot;baz!$@&quot;] == 123.456; // access via index notation

&quot;baz!$@&quot; in y == true;  // use 'in' to test if a property exists in the object map
(&quot;z&quot; in y) == false;

ts.obj = y;             // object maps can be assigned completely (by value copy)
let foo = ts.list.a;
foo == 42;

let foo = #{ a:1,};     // trailing comma is OK

let foo = #{ a:1, b:2, c:3 }[&quot;a&quot;];
foo == 1;

fn abc() {
    #{ a:1, b:2, c:3 } // a function returning an object map
}

let foo = abc().b;
foo == 2;

let foo = y[&quot;a&quot;];
foo == 42;

y.has(&quot;a&quot;) == true;
y.has(&quot;xyz&quot;) == false;

y.xyz == ();            // a non-existing property returns '()'
y[&quot;xyz&quot;] == ();

y.len() == 3;

y.remove(&quot;a&quot;) == 1;     // remove property

y.len() == 2;
y.has(&quot;a&quot;) == false;

for name in y.keys() {  // get an array of all the property names via 'keys'
    print(name);
}

for val in y.values() { // get an array of all the property values via 'values'
    print(val);
}

y.clear();              // empty the object map

y.len() == 0;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#no-support-for-property-getters" id="no-support-for-property-getters">No Support for Property Getters</a></h2>
<p>In order not to affect the speed of accessing properties in an object map, new property
<a href="language//book/vnext/rust/getters-setters.html">getters</a> cannot be registered because they conflict with the syntax of
property access.</p>
<p>A property <a href="language//book/vnext/rust/getters-setters.html">getter</a> function registered via <code>Engine::register_get</code>, for example,
for a <code>Map</code> will never be found – instead, the property will be looked up in the object map.</p>
<p>Therefore, <em>method-call</em> notation must be used for built-in properties:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map.len                 // access property 'len', returns '()' if not found

map.len()               // returns the number of properties

map.keys                // access property 'keys', returns '()' if not found

map.keys()              // returns array of all property names

map.values              // access property 'values', returns '()' if not found

map.values()            // returns array of all property values
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#parse-an-object-map-from-json" id="parse-an-object-map-from-json">Parse an Object Map from JSON</a></h1>
<p>The syntax for an <a href="language//book/vnext/language/object-maps.html">object map</a> is extremely similar to the JSON representation of a object hash,
with the exception of <code>null</code> values which can technically be mapped to <a href="language//book/vnext/language/values-and-types.html"><code>()</code></a>.</p>
<p>A valid JSON string does not start with a hash character <code>#</code> while a Rhai <a href="language//book/vnext/language/object-maps.html">object map</a> does – that’s the major difference!</p>
<p>Use the <code>Engine::parse_json</code> method to parse a piece of JSON into an object map.
The JSON text must represent a single object hash (i.e. must be wrapped within “<code>{ .. }</code>“)
otherwise it returns a syntax error.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// JSON string - notice that JSON property names are always quoted
//               notice also that comments are acceptable within the JSON string
let json = r#&quot;{
                &quot;a&quot;: 1,                 // &lt;- this is an integer number
                &quot;b&quot;: true,
                &quot;c&quot;: 123.0,             // &lt;- this is a floating-point number
                &quot;$d e f!&quot;: &quot;hello&quot;,     // &lt;- any text can be a property name
                &quot;^^^!!!&quot;: [1,42,&quot;999&quot;], // &lt;- value can be array or another hash
                &quot;z&quot;: null               // &lt;- JSON 'null' value
              }
&quot;#;

// Parse the JSON expression as an object map
// Set the second boolean parameter to true in order to map 'null' to '()'
let map = engine.parse_json(json, true)?;

map.len() == 6;       // 'map' contains all properties in the JSON string

// Put the object map into a 'Scope'
let mut scope = Scope::new();
scope.push(&quot;map&quot;, map);

let result = engine.eval_with_scope::&lt;INT&gt;(r#&quot;map[&quot;^^^!!!&quot;].len()&quot;#)?;

result == 3;          // the object map is successfully used in the script
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#representation-of-numbers" id="representation-of-numbers">Representation of Numbers</a></h2>
<p>JSON numbers are all floating-point while Rhai supports integers (<code>INT</code>) and floating-point (<code>FLOAT</code>) if
the <a href="language//book/vnext/start/features.html"><code>no_float</code></a> feature is not used.</p>
<p>Most common generators of JSON data distinguish between integer and floating-point values by always
serializing a floating-point number with a decimal point (i.e. <code>123.0</code> instead of <code>123</code> which is
assumed to be an integer).</p>
<p>This style can be used successfully with Rhai <a href="language//book/vnext/language/object-maps.html">object maps</a>.</p>
<h2><a class="header" href="#parse-json-with-sub-objects" id="parse-json-with-sub-objects">Parse JSON with Sub-Objects</a></h2>
<p><code>Engine::parse_json</code> depends on the fact that the <a href="language//book/vnext/language/object-maps.html">object map</a> literal syntax in Rhai is <em>almost</em>
the same as a JSON object.  However, it is <em>almost</em> because the syntax for a sub-object in JSON
(i.e. “<code>{ ... }</code>“) is different from a Rhai <a href="language//book/vnext/language/object-maps.html">object map</a> literal (i.e. “<code>#{ ... }</code>“).</p>
<p>When <code>Engine::parse_json</code> encounters JSON with sub-objects, it fails with a syntax error.</p>
<p>If it is certain that no text string in the JSON will ever contain the character ‘<code>{</code>‘,
then it is possible to parse it by first replacing all occupance of ‘<code>{</code>‘ with “<code>#{</code>“.</p>
<p>A JSON object hash starting with <code>#{</code> is handled transparently by <code>Engine::parse_json</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// JSON with sub-object 'b'.
let json = r#&quot;{&quot;a&quot;:1, &quot;b&quot;:{&quot;x&quot;:true, &quot;y&quot;:false}}&quot;#;

// Our JSON text does not contain the '{' character, so off we go!
let new_json = json.replace(&quot;{&quot;, &quot;#{&quot;);

// The leading '{' will also be replaced to '#{', but 'parse_json' handles this just fine.
let map = engine.parse_json(&amp;new_json, false)?;

map.len() == 2;       // 'map' contains two properties: 'a' and 'b'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-serde-to-serializedeserialize-tofrom-json" id="use-serde-to-serializedeserialize-tofrom-json">Use <code>serde</code> to Serialize/Deserialize to/from JSON</a></h2>
<p>Remember, <code>Engine::parse_json</code> is nothing more than a <em>cheap</em> alternative to true JSON parsing.</p>
<p>If correctness is needed, or for more configuration possibilities, turn on the <a href="language//book/vnext/start/features.html"><code>serde</code></a>
feature to pull in the <a href="https://crates.io/crates/serde"><code>serde</code></a> crate which enables
serialization and deserialization to/from multiple formats, including JSON.</p>
<p>Beware, though... the <a href="https://crates.io/crates/serde"><code>serde</code></a> crate is quite heavy.</p>
<p>See <em><a href="language//book/vnext/rust/serde.html">Serialization/Deserialization of <code>Dynamic</code> with <code>serde</code></a></em> for more details.</p>
<h1><a class="header" href="#special-support-for-oop-via-object-maps" id="special-support-for-oop-via-object-maps">Special Support for OOP via Object Maps</a></h1>
<p><a href="language//book/vnext/language/object-maps.html">Object maps</a> can be used to simulate <a href="language//book/vnext/patterns/oop.html">object-oriented programming (OOP)</a> by storing data
as properties and methods as properties holding <a href="language//book/vnext/language/fn-ptr.html">function pointers</a>.</p>
<p>If an <a href="language//book/vnext/language/object-maps.html">object map</a>‘s property holds a <a href="language//book/vnext/language/fn-ptr.html">function pointer</a>, the property can simply be called like
a normal method in method-call syntax.  This is a <em>short-hand</em> to avoid the more verbose syntax
of using the <code>call</code> function keyword.</p>
<p>When a property holding a <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> or a <a href="language//book/vnext/language/fn-closure.html">closure</a> is called like a method,
what happens next depends on whether the target function is a native Rust function or
a script-defined function.</p>
<ul>
<li>
<p>If it is a registered native Rust function, it is called directly in <em>method-call</em> style with the <a href="language//book/vnext/language/object-maps.html">object map</a> inserted as the first argument.</p>
</li>
<li>
<p>If it is a script-defined function, the <code>this</code> variable within the function body is bound to the <a href="language//book/vnext/language/object-maps.html">object map</a> before the function is called.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let obj = #{
                data: 40,
                action: || this.data += x    // 'action' holds a closure
           };

obj.action(2);                               // calls the function pointer with `this` bound to 'obj'

obj.call(obj.action, 2);                     // &lt;- the above de-sugars to this

obj.data == 42;

// To achieve the above with normal function pointer call will fail.
fn do_action(map, x) { map.data += x; }      // 'map' is a copy

obj.action = Fn(&quot;do_action&quot;);

obj.action.call(obj, 2);                     // 'obj' is passed as a copy by value
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#timestamp" id="timestamp"><code>timestamp</code></a></h1>
<p>Timestamps are provided by the <a href="language//book/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a> (excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>)
via the <code>timestamp</code> function.</p>
<p>Timestamps are not available under <a href="language//book/vnext/start/features.html"><code>no_std</code></a>.</p>
<p>The Rust type of a timestamp is <code>std::time::Instant</code> (<a href="https://crates.io/crates/instant"><code>instant::Instant</code></a> in <a href="language//book/vnext/start/builds/wasm.html">WASM</a> builds).</p>
<p><a href="language//book/vnext/language/type-of.html"><code>type_of()</code></a> a timestamp returns <code>&quot;timestamp&quot;</code>.</p>
<h2><a class="header" href="#built-in-functions-2" id="built-in-functions-2">Built-in Functions</a></h2>
<p>The following methods (defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicTimePackage</code></a> but excluded if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on timestamps:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>elapsed</code> method and property</td><td><em>none</em></td><td>returns the number of seconds since the timestamp</td></tr>
<tr><td><code>-</code> operator</td><td>1) later timestamp<br/>2) earlier timestamp</td><td>returns the number of seconds between the two timestamps</td></tr>
<tr><td><code>+</code> operator</td><td>number of seconds to add</td><td>returns a new timestamp</td></tr>
<tr><td><code>-</code> operator</td><td>number of seconds to subtract</td><td>returns a new timestamp</td></tr>
</tbody></table>
<h2><a class="header" href="#examples-9" id="examples-9">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let now = timestamp();

// Do some lengthy operation...

if now.elapsed &gt; 30.0 {
    print(&quot;takes too long (over 30 seconds)!&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<p>The following are reserved keywords in Rhai:</p>
<table><thead><tr><th>Active keywords</th><th>Reserved keywords</th><th>Usage</th><th align="center">Inactive under feature</th></tr></thead><tbody>
<tr><td><code>true</code>, <code>false</code></td><td></td><td>constants</td><td align="center"></td></tr>
<tr><td><code>let</code>, <code>const</code></td><td><code>var</code>, <code>static</code></td><td>variables</td><td align="center"></td></tr>
<tr><td></td><td><code>begin</code>, <code>end</code></td><td>block scopes</td><td align="center"></td></tr>
<tr><td><code>is_shared</code></td><td></td><td>shared values</td><td align="center"><a href="language//book/vnext/start/features.html"><code>no_closure</code></a></td></tr>
<tr><td><code>if</code>, <code>else</code></td><td><code>then</code>, <code>unless</code>, <code>goto</code>, <code>exit</code></td><td>control flow</td><td align="center"></td></tr>
<tr><td><code>switch</code></td><td><code>match</code>, <code>case</code></td><td>switching and matching</td><td align="center"></td></tr>
<tr><td><code>do</code>, <code>while</code>, <code>loop</code>, <code>until</code>, <code>for</code>, <code>in</code>, <code>continue</code>, <code>break</code></td><td><code>each</code></td><td>looping</td><td align="center"></td></tr>
<tr><td><code>fn</code>, <code>private</code></td><td><code>public</code>, <code>new</code></td><td>functions</td><td align="center"><a href="language//book/vnext/start/features.html"><code>no_function</code></a></td></tr>
<tr><td><code>return</code></td><td></td><td>return values</td><td align="center"></td></tr>
<tr><td><code>throw</code>, <code>try</code>, <code>catch</code></td><td></td><td>throw/catch exceptions</td><td align="center"></td></tr>
<tr><td><code>import</code>, <code>export</code>, <code>as</code></td><td><code>use</code>, <code>with</code>, <code>module</code>, <code>package</code></td><td>modules/packages</td><td align="center"><a href="language//book/vnext/start/features.html"><code>no_module</code></a></td></tr>
<tr><td><code>Fn</code>, <code>call</code>, <code>curry</code></td><td></td><td>function pointers</td><td align="center"></td></tr>
<tr><td></td><td><code>spawn</code>, <code>thread</code>, <code>go</code>, <code>sync</code>, <code>async</code>, <code>await</code>, <code>yield</code></td><td>threading/async</td><td align="center"></td></tr>
<tr><td><code>type_of</code>, <code>print</code>, <code>debug</code>, <code>eval</code></td><td></td><td>special functions</td><td align="center"></td></tr>
<tr><td></td><td><code>default</code>, <code>void</code>, <code>null</code>, <code>nil</code></td><td>special values</td><td align="center"></td></tr>
</tbody></table>
<p>Keywords cannot become the name of a <a href="language//book/vnext/language/functions.html">function</a> or <a href="language//book/vnext/language/variables.html">variable</a>, even when they are disabled.</p>
<h1><a class="header" href="#statements" id="statements">Statements</a></h1>
<h2><a class="header" href="#terminated-by-" id="terminated-by-">Terminated by ‘<code>;</code>‘</a></h2>
<p>Statements are terminated by semicolons ‘<code>;</code>‘ and they are mandatory,
except for the <em>last</em> statement in a <em>block</em> (enclosed by ‘<code>{</code>‘ .. ‘<code>}</code>‘ pairs) where it can be omitted.</p>
<p>Semicolons can also be omitted if the statement ends with a block itself
(e.g. the <code>if</code>, <code>while</code>, <code>for</code> and <code>loop</code> statements).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 42;             // normal assignment statement
let a = foo(42);        // normal function call statement
foo &lt; 42;               // normal expression as statement

let a = { 40 + 2 };     // 'a' is set to the value of the statement block, which is the value of the last statement
//              ^ the last statement does not require a terminating semicolon (although it also works with it)
//                ^ semicolon required here to terminate the assignment statement; it is a syntax error without it

if foo { a = 42 }
//               ^ there is no need to terminate an if-statement with a semicolon

4 * 10 + 2              // a statement which is just one expression - no ending semicolon is OK
                        // because it is the last statement of the whole block
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#statement-expression" id="statement-expression">Statement Expression</a></h2>
<p>A statement can be used anywhere where an expression is expected. These are called, for lack of a more
creative name, “statement expressions.”</p>
<p>The <em>last</em> statement of a statement block is <em>always</em> the block’s return value when used as a statement,
<em>regardless</em> of whether it is terminated by a semicolon or not. This is different from Rust where,
if the last statement is terminated by a semicolon, the block’s return value is taken to be <code>()</code>.</p>
<p>If the last statement has no return value (e.g. variable definitions, assignments) then it is assumed to be <a href="language//book/vnext/language/values-and-types.html"><code>()</code></a>.</p>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<h2><a class="header" href="#valid-names" id="valid-names">Valid Names</a></h2>
<p>Variables in Rhai follow normal C naming rules – must contain only ASCII letters, digits and underscores ‘<code>_</code>‘,
and cannot start with a digit.</p>
<p>For example: ‘<code>_c3po</code>‘ and ‘<code>r2d2</code>‘ are valid variable names, but ‘<code>3abc</code>‘ is not.</p>
<p>However, unlike Rust, a variable name must also contain at least one ASCII letter, and an ASCII letter must come before any digit.
In other words, the first character that is not an underscore ‘<code>_</code>‘ must be an ASCII letter and not a digit.</p>
<p>Therefore, some names acceptable to Rust, like ‘<code>_</code>‘, ‘<code>_42foo</code>‘, ‘<code>_1</code>‘ etc., are not valid in Rhai.
This restriction is to reduce confusion because, for instance, ‘<code>_1</code>‘ can easily be misread (or mis-typed) as <code>-1</code>.</p>
<p>Variable names are case <em>sensitive</em>.</p>
<p>Variable names also cannot be the same as a <a href="language//book/vnext/appendix/keywords.html">keyword</a>.</p>
<h3><a class="header" href="#unicode-standard-annex-31-identifiers" id="unicode-standard-annex-31-identifiers">Unicode Standard Annex #31 Identifiers</a></h3>
<p>The <a href="language//book/vnext/start/features.html"><code>unicode-xid-ident</code></a> feature expands the allowed characters for variable names to the set defined by
<a href="http://www.unicode.org/reports/tr31/">Unicode Standard Annex #31</a>.</p>
<h2><a class="header" href="#declare-a-variable" id="declare-a-variable">Declare a Variable</a></h2>
<p>Variables are declared using the <code>let</code> keyword.</p>
<p>Variables do not have to be given an initial value.
If none is provided, it defaults to <a href="language//book/vnext/language/values-and-types.html"><code>()</code></a>.</p>
<p>A variable defined within a statement block is <em>local</em> to that block.</p>
<p>Use <code>is_def_var</code> to detect if a variable is defined.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x;              // ok - value is '()'
let x = 3;          // ok
let _x = 42;        // ok
let x_ = 42;        // also ok
let _x_ = 42;       // still ok

let _ = 123;        // &lt;- syntax error: illegal variable name
let _9 = 9;         // &lt;- syntax error: illegal variable name

let x = 42;         // variable is 'x', lower case
let X = 123;        // variable is 'X', upper case
x == 42;
X == 123;

{
    let x = 999;    // local variable 'x' shadows the 'x' in parent block
    x == 999;       // access to local 'x'
}
x == 42;            // the parent block's 'x' is not changed

is_def_var(&quot;x&quot;) == true;

is_def_var(&quot;_x&quot;) == true;

is_def_var(&quot;y&quot;) == false;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#constants" id="constants">Constants</a></h1>
<p>Constants can be defined using the <code>const</code> keyword and are immutable.</p>
<p>Constants follow the same naming rules as <a href="language//book/vnext/language/variables.html">variables</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const x = 42;

print(x * 2);       // prints 84

x = 123;            // &lt;- syntax error: cannot assign to constant
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const x;            // 'x' is a constant '()'

const x = 40 + 2;   // 'x' is a constant 42
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#manually-add-constant-into-custom-scope" id="manually-add-constant-into-custom-scope">Manually Add Constant into Custom Scope</a></h2>
<p>It is possible to add a constant into a custom <a href="language//book/vnext/engine/scope.html"><code>Scope</code></a> so it’ll be available to scripts
running with that <a href="language//book/vnext/engine/scope.html"><code>Scope</code></a>.</p>
<p>When added to a custom <a href="language//book/vnext/engine/scope.html"><code>Scope</code></a>, a constant can hold any value, not just a literal value.</p>
<p>It is very useful to have a constant value hold a <a href="language//book/vnext/rust/custom.html">custom type</a>, which essentially acts
as a <a href="language/../patterns/singleton.html"><em>singleton</em></a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, RegisterFn};

#[derive(Debug, Clone)]
struct TestStruct(i64);                                     // custom type

let mut engine = Engine::new();

engine
    .register_type_with_name::&lt;TestStruct&gt;(&quot;TestStruct&quot;)    // register custom type
    .register_get(&quot;value&quot;, |obj: &amp;mut TestStruct| obj.0),   // property getter
    .register_fn(&quot;update_value&quot;,
        |obj: &amp;mut TestStruct, value: i64| obj.0 = value    // mutating method
    );

let mut scope = Scope::new();                               // create custom scope

scope.push_constant(&quot;MY_NUMBER&quot;, TestStruct(123_i64));      // add constant variable

// Beware: constant objects can still be modified via a method call!
engine.consume_with_scope(&amp;mut scope,
r&quot;
    MY_NUMBER.update_value(42);
    print(MY_NUMBER.value);                                 // prints 42
&quot;)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#caveat--constants-can-be-modified-via-rust" id="caveat--constants-can-be-modified-via-rust">Caveat – Constants Can be Modified via Rust</a></h2>
<p>A custom type stored as a constant cannot be modified via script, but <em>can</em> be modified via
a registered Rust function that takes a first <code>&amp;mut</code> parameter – because there is no way for
Rhai to know whether the Rust function modifies its argument!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const x = 42;       // a constant

x.increment();      // call 'increment' defined in Rust with '&amp;mut' first parameter

x == 43;            // value of 'x' is changed!

fn double() {
    this *= 2;      // function doubles 'this'
}

let y = 1;          // 'y' is not constant and mutable

y.double();         // double it...

y == 2;             // value of 'y' is changed as expected

x.double();         // &lt;- error: cannot modify constant 'this'

x == 43;            // value of 'x' is unchanged by script
<span class="boring">}
</span></code></pre></pre>
<p>This is important to keep in mind because the script <a href="language//book/vnext/engine/optimize/index.html">optimizer</a>
by default does <em>constant propagation</em> as a operation.</p>
<p>If a constant is eventually modified by a Rust function, the optimizer will not see
the updated value and will propagate the original initialization value instead.</p>
<h1><a class="header" href="#logic-operators" id="logic-operators">Logic Operators</a></h1>
<h2><a class="header" href="#comparison-operators" id="comparison-operators">Comparison Operators</a></h2>
<table><thead><tr><th align="center">Operator</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><code>==</code></td><td>equals to</td></tr>
<tr><td align="center"><code>!=</code></td><td>not equals to</td></tr>
<tr><td align="center"><code>&gt;</code></td><td>greater than</td></tr>
<tr><td align="center"><code>&gt;=</code></td><td>greater than or equals to</td></tr>
<tr><td align="center"><code>&lt;</code></td><td>less than</td></tr>
<tr><td align="center"><code>&lt;=</code></td><td>less than or equals to</td></tr>
</tbody></table>
<p>Comparing most values of the same data type work out-of-the-box for all <a href="language//book/vnext/language/values-and-types.html">standard types</a> supported by the system.</p>
<p>However, if using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a> without loading any <a href="language//book/vnext/rust/packages/index.html">packages</a>, comparisons can only be made between a limited
set of types (see <a href="language//book/vnext/engine/raw.html#built-in-operators">built-in operators</a>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>42 == 42;               // true

42 &gt; 42;                // false

&quot;hello&quot; &gt; &quot;foo&quot;;        // true

&quot;42&quot; == 42;             // false
<span class="boring">}
</span></code></pre></pre>
<p>Comparing two values of <em>different</em> data types, or of unknown data types, always results in <code>false</code>,
except for ‘<code>!=</code>‘ (not equals) which results in <code>true</code>. This is in line with intuition.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>42 == 42.0;             // false - i64 cannot be compared with f64

42 != 42.0;             // true - i64 cannot be compared with f64

42 &gt; &quot;42&quot;;              // false - i64 cannot be compared with string

42 &lt;= &quot;42&quot;;             // false - i64 cannot be compared with string

let ts = new_ts();      // custom type

ts == 42;               // false - types cannot be compared

ts != 42;               // true - types cannot be compared
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#boolean-operators" id="boolean-operators">Boolean operators</a></h2>
<table><thead><tr><th align="center">Operator</th><th>Description</th><th align="center">Short-Circuits?</th></tr></thead><tbody>
<tr><td align="center"><code>!</code> (prefix)</td><td>boolean <em>NOT</em></td><td align="center">no</td></tr>
<tr><td align="center"><code>&amp;&amp;</code></td><td>boolean <em>AND</em></td><td align="center">yes</td></tr>
<tr><td align="center"><code>&amp;</code></td><td>boolean <em>AND</em></td><td align="center">no</td></tr>
<tr><td align="center"><code>||</code></td><td>boolean <em>OR</em></td><td align="center">yes</td></tr>
<tr><td align="center"><code>|</code></td><td>boolean <em>OR</em></td><td align="center">no</td></tr>
</tbody></table>
<p>Double boolean operators <code>&amp;&amp;</code> and <code>||</code> <em>short-circuit</em> – meaning that the second operand will not be evaluated
if the first one already proves the condition wrong.</p>
<p>Single boolean operators <code>&amp;</code> and <code>|</code> always evaluate both operands.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a() || b();             // b() is not evaluated if a() is true

a() &amp;&amp; b();             // b() is not evaluated if a() is false

a() | b();              // both a() and b() are evaluated

a() &amp; b();              // both a() and b() are evaluated
<span class="boring">}
</span></code></pre></pre>
<p>All boolean operators are <a href="language//book/vnext/engine/raw.html#built-in-operators">built in</a> for the <code>bool</code> data type.</p>
<h1><a class="header" href="#compound-assignment-operators" id="compound-assignment-operators">Compound Assignment Operators</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let number = 9;

number += 8;            // number = number + 8

number -= 7;            // number = number - 7

number *= 6;            // number = number * 6

number /= 5;            // number = number / 5

number %= 4;            // number = number % 4

number ~= 3;            // number = number ~ 3

number &lt;&lt;= 2;           // number = number &lt;&lt; 2

number &gt;&gt;= 1;           // number = number &gt;&gt; 1

number &amp;= 0x00ff;       // number = number &amp; 0x00ff;

number |= 0x00ff;       // number = number | 0x00ff;

number ^= 0x00ff;       // number = number ^ 0x00ff;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#the-flexible-" id="the-flexible-">The Flexible <code>+=</code></a></h2>
<p>The the <code>+</code> and <code>+=</code> operators are often <a href="language//book/vnext/rust/functions.html#function-overloading">overloaded</a> to perform
build-up operations for different data types.</p>
<p>For example, it is used to build <a href="language//book/vnext/language/strings-chars.html">strings</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;abc&quot;;
my_str += &quot;ABC&quot;;
my_str += 12345;

my_str == &quot;abcABC12345&quot;
<span class="boring">}
</span></code></pre></pre>
<p>to concatenate <a href="language//book/vnext/language/arrays.html">arrays</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_array = [1, 2, 3];
my_array += [4, 5];

my_array == [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>and mix two <a href="language//book/vnext/language/object-maps.html">object maps</a> together:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_obj = #{a:1, b:2};
my_obj += #{c:3, d:4, e:5};

my_obj.len() == 5;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#if-statement" id="if-statement"><code>if</code> Statement</a></h1>
<p><code>if</code> statements follow C syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if foo(x) {
    print(&quot;It's true!&quot;);
} else if bar == baz {
    print(&quot;It's true again!&quot;);
} else if baz.is_foo() {
    print(&quot;Yet again true.&quot;);
} else if foo(bar - baz) {
    print(&quot;True again... this is getting boring.&quot;);
} else {
    print(&quot;It's finally false!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#braces-are-mandatory" id="braces-are-mandatory">Braces Are Mandatory</a></h2>
<p>Unlike C, the condition expression does <em>not</em> need to be enclosed in parentheses ‘<code>(</code>‘ .. ‘<code>)</code>‘, but
all branches of the <code>if</code> statement must be enclosed within braces ‘<code>{</code>‘ .. ‘<code>}</code>‘,
even when there is only one statement inside the branch.</p>
<p>Like Rust, there is no ambiguity regarding which <code>if</code> clause a branch belongs to.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rhai is not C!
if (decision) print(&quot;I've decided!&quot;);
//            ^ syntax error, expecting '{' in statement block
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#if-expressions" id="if-expressions"><code>if</code>-Expressions</a></h2>
<p>Like Rust, <code>if</code> statements can also be used as <em>expressions</em>, replacing the <code>? :</code> conditional operators
in other C-like languages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following is equivalent to C: int x = 1 + (decision ? 42 : 123) / 2;
let x = 1 + if decision { 42 } else { 123 } / 2;
x == 22;

let x = if decision { 42 }; // no else branch defaults to '()'
x == ();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#switch-expression" id="switch-expression"><code>switch</code> Expression</a></h1>
<p>The <code>switch</code> <em>expression</em> allows matching on literal values, and it mostly follows Rust’s
<code>match</code> syntax:</p>
<pre><code class="language-c">switch calc_secret_value(x) {
    1 =&gt; print(&quot;It's one!&quot;),
    2 =&gt; {
        print(&quot;It's two!&quot;);
        print(&quot;Again!&quot;);
    }
    3 =&gt; print(&quot;Go!&quot;),
    // _ is the default when no cases match
    _ =&gt; print(&quot;Oops! Something's wrong: &quot; + x)
}
</code></pre>
<h2><a class="header" href="#expression-not-statement" id="expression-not-statement">Expression, Not Statement</a></h2>
<p><code>switch</code> is not a statement, but an expression. This means that a <code>switch</code> expression can
appear anywhere a regular expression can, e.g. as function call arguments.</p>
<pre><code class="language-c">let x = switch foo { 1 =&gt; true, _ =&gt; false };

func(switch foo {
    &quot;hello&quot; =&gt; 42,
    &quot;world&quot; =&gt; 123,
    _ =&gt; 0
});

// The above is somewhat equivalent to:

let x = if foo == 1 { true } else { false };

if foo == &quot;hello&quot; {
    func(42);
} else if foo == &quot;world&quot; {
    func(123);
} else {
    func(0);
}
</code></pre>
<h2><a class="header" href="#array-and-object-map-literals-also-work" id="array-and-object-map-literals-also-work">Array and Object Map Literals Also Work</a></h2>
<p>The <code>switch</code> expression can match against any <em>literal</em>, including <a href="language//book/vnext/language/arrays.html">array</a> and <a href="language//book/vnext/language/object-maps.html">object map</a> literals.</p>
<pre><code class="language-c">// Match on arrays
switch [foo, bar, baz] {
    [&quot;hello&quot;, 42, true] =&gt; { ... }
    [&quot;hello&quot;, 123, false] =&gt; { ... }
    [&quot;world&quot;, 1, true] =&gt; { ... }
    _ =&gt; { ... }
}

// Match on object maps
switch map {
    #{ a: 1, b: 2, c: true } =&gt; { ... }
    #{ a: 42, d: &quot;hello&quot; } =&gt; { ... }
    _ =&gt; { ... }
}
</code></pre>
<p>Switching on <a href="language//book/vnext/language/arrays.html">arrays</a> is very useful when working with Rust enums (see <a href="language//book/vnext/patterns/enums.html">this chapter</a>
for more details).</p>
<h2><a class="header" href="#difference-from-if-else-if-chain" id="difference-from-if-else-if-chain">Difference From <code>if</code>-<code>else if</code> Chain</a></h2>
<p>Although a <code>switch</code> expression looks <em>almost</em> the same as an <code>if</code>-<code>else if</code> chain,
there are subtle differences between the two.</p>
<h3><a class="header" href="#look-up-table-vs-x--y" id="look-up-table-vs-x--y">Look-up Table vs <code>x == y</code></a></h3>
<p>A <code>switch</code> expression matches through <em>hashing</em> via a look-up table.
Therefore, matching is very fast.  Walking down an <code>if</code>-<code>else if</code> chain
is <em>much</em> slower.</p>
<p>On the other hand, operators can be <a href="language//book/vnext/rust/operators.html">overloaded</a> in Rhai,
meaning that it is possible to override the <code>==</code> operator for integers such
that <code>x == y</code> returns a different result from the built-in default.</p>
<p><code>switch</code> expressions do <em>not</em> use the <code>==</code> operator for comparison;
instead, they <em>hash</em> the data values and jump directly to the correct
statements via a pre-compiled look-up table.  This makes matching extremely
efficient, but it also means that <a href="language//book/vnext/rust/operators.html">overloading</a>
the <code>==</code> operator will have no effect.</p>
<p>Therefore, in environments where it is desirable to <a href="language//book/vnext/rust/operators.html">overload</a>
the <code>==</code> operator – though it is difficult to think of valid scenarios where you’d want
<code>1 == 1</code> to return something other than <code>true</code> – avoid using the <code>switch</code> expression.</p>
<h3><a class="header" href="#efficiency" id="efficiency">Efficiency</a></h3>
<p>Because the <code>switch</code> expression works through a look-up table, it is very efficient
even for <em>large</em> number of cases; in fact, switching is an O(1) operation regardless
of the size of the data and number of cases to match.</p>
<p>A long <code>if</code>-<code>else if</code> chain becomes increasingly slower with each additional case
because essentially an O(n) <em>linear scan</em> is performed.</p>
<h1><a class="header" href="#while-loop" id="while-loop"><code>while</code> Loop</a></h1>
<p><code>while</code> loops follow C syntax.</p>
<p>Like C, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;

while x &gt; 0 {
    x -= 1;
    if x &lt; 6 { continue; }  // skip to the next iteration
    print(x);
    if x == 5 { break; }    // break out of while loop
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#do-loop" id="do-loop"><code>do</code> Loop</a></h1>
<p><code>do</code> loops have two opposite variants: <code>do</code> ... <code>while</code> and <code>do</code> ... <code>until</code>.</p>
<p>Like the <code>while</code> loop, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;

do {
    x -= 1;
    if x &lt; 6 { continue; }  // skip to the next iteration
    print(x);
    if x == 5 { break; }    // break out of do loop
} while x &gt; 0;


do {
    x -= 1;
    if x &lt; 6 { continue; }  // skip to the next iteration
    print(x);
    if x == 5 { break; }    // break out of do loop
} until x == 0;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#infinite-loop" id="infinite-loop">Infinite <code>loop</code></a></h1>
<p>Infinite loops follow Rust syntax.</p>
<p>Like Rust, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;

loop {
    x -= 1;

    if x &gt; 5 { continue; }  // skip to the next iteration

    print(x);

    if x == 0 { break; }    // break out of loop
}
<span class="boring">}
</span></code></pre></pre>
<p>Beware: a <code>loop</code> statement without a <code>break</code> statement inside its loop block is infinite -
there is no way for the loop to stop iterating.</p>
<h1><a class="header" href="#for-loop" id="for-loop"><code>for</code> Loop</a></h1>
<p>Iterating through a range or an <a href="language//book/vnext/language/arrays.html">array</a>, or any type with a registered <a href="language//book/vnext/language/iterator.html">type iterator</a>,
is provided by the <code>for</code> ... <code>in</code> loop.</p>
<p>Like C, <code>continue</code> can be used to skip to the next iteration, by-passing all following statements;
<code>break</code> can be used to break out of the loop unconditionally.</p>
<p>To loop through a number sequence (with or without steps), use the <code>range</code> function to
return a numeric iterator.</p>
<h2><a class="header" href="#iterate-through-strings" id="iterate-through-strings">Iterate Through Strings</a></h2>
<p>Iterating through a <a href="language//book/vnext/language/strings-chars.html">string</a> yields characters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello, world!&quot;;

for ch in s {
    if ch &gt; 'z' { continue; }   // skip to the next iteration

    print(ch);

    if x == '@' { break; }      // break out of for loop
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#iterate-through-arrays" id="iterate-through-arrays">Iterate Through Arrays</a></h2>
<p>Iterating through an <a href="language//book/vnext/language/arrays.html">array</a> yields cloned <em>copies</em> of each element.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 3, 5, 7, 9, 42];

for x in array {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#iterate-through-numeric-ranges" id="iterate-through-numeric-ranges">Iterate Through Numeric Ranges</a></h2>
<p>The <code>range</code> function allows iterating through a range of numbers
(not including the last number).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Iterate starting from 0 and stopping at 49.
for x in range(0, 50) {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// The 'range' function also takes a step.
for x in range(0, 50, 3) {      // step by 3
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#iterate-through-object-maps" id="iterate-through-object-maps">Iterate Through Object Maps</a></h2>
<p>Two methods, <code>keys</code> and <code>values</code>, return <a href="language//book/vnext/language/arrays.html">arrays</a> containing cloned <em>copies</em>
of all property names and values of an <a href="language//book/vnext/language/object-maps.html">object map</a>, respectively.</p>
<p>These <a href="language//book/vnext/language/arrays.html">arrays</a> can be iterated.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = #{a:1, b:3, c:5, d:7, e:9};

// Property names are returned in unsorted, random order
for x in map.keys() {
    if x &gt; 10 { continue; }     // skip to the next iteration

    print(x);

    if x == 42 { break; }       // break out of for loop
}

// Property values are returned in unsorted, random order
for val in map.values() {
    print(val);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#iterators-for-custom-types" id="iterators-for-custom-types">Iterators for Custom Types</a></h1>
<p>If a <a href="language//book/vnext/rust/custom.html">custom type</a> is iterable, the <a href="language/for.html"><code>for</code></a> loop can be used to iterate through
its items in sequence.</p>
<p>In order to use a <a href="language/for.html"><code>for</code></a> statement, a <em>type iterator</em> must be registered for
the <a href="language//book/vnext/rust/custom.html">custom type</a> in question.</p>
<p><code>Engine::register_iterator&lt;T&gt;</code> allows registration of a <em>type iterator</em> for any type
that implements <code>IntoIterator</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom type
#[derive(Debug, Clone)]
struct TestStruct { ... }

// Implement 'IntoIterator' trait
impl IntoIterator&lt;Item = ...&gt; for TestStruct {
    type Item = ...;
    type IntoIter = SomeIterType&lt;Self::Item&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        ...
    }
}

engine
    .register_type_with_name::&lt;TestStruct&gt;(&quot;TestStruct&quot;)
    .register_fn(&quot;new_ts&quot;, || TestStruct { ... })
    .register_iterator::&lt;TestStruct&gt;();           // register type iterator
<span class="boring">}
</span></code></pre></pre>
<p>With a type iterator registered, the <a href="language//book/vnext/rust/custom.html">custom type</a> can be iterated through:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ts = new_ts();

// Use 'for' statement to loop through items in 'ts'
for item in ts {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#return-values" id="return-values">Return Values</a></h1>
<p>The <code>return</code> statement is used to immediately stop evaluation and exist the current context
(typically a function call) yielding a <em>return value</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>return;             // equivalent to return ();

return 123 + 456;   // returns 579
<span class="boring">}
</span></code></pre></pre>
<p>A <code>return</code> statement at <em>global</em> level stop the entire script evaluation,
the return value is taken as the result of the script evaluation.</p>
<h1><a class="header" href="#throw-exception-on-error" id="throw-exception-on-error">Throw Exception on Error</a></h1>
<p>All of <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a>‘s evaluation/consuming methods return <code>Result&lt;T, Box&lt;rhai::EvalAltResult&gt;&gt;</code>
with <code>EvalAltResult</code> holding error information.</p>
<p>To deliberately return an error during an evaluation, use the <code>throw</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if some_bad_condition_has_happened {
    throw error;    // 'throw' any value as the exception
}

throw;              // defaults to '()'
<span class="boring">}
</span></code></pre></pre>
<p>Exceptions thrown via <code>throw</code> in the script can be captured in Rust by matching
<code>Err(Box&lt;EvalAltResult::ErrorRuntime(value, position)&gt;)</code> with the exception value
captured by <code>value</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = engine.eval::&lt;i64&gt;(r#&quot;
    let x = 42;

    if x &gt; 0 {
        throw x;
    }
&quot;#);

println!(&quot;{}&quot;, result);     // prints &quot;Runtime error: 42 (line 5, position 15)&quot;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#catch-a-thrown-exception" id="catch-a-thrown-exception">Catch a Thrown Exception</a></h2>
<p>It is possible to <em>catch</em> an exception instead of having it abort the evaluation
of the entire script via the <a href="language//book/vnext/language/try-catch.html"><code>try</code> ... <code>catch</code></a>
statement common to many C-like languages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>try
{
    throw 42;
}
catch (err)         // 'err' captures the thrown exception value
{
    print(err);     // prints 42
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#catch-exceptions" id="catch-exceptions">Catch Exceptions</a></h1>
<p>When an <a href="language//book/vnext/language/throw.html">exception</a> is thrown via a <a href="language//book/vnext/language/throw.html"><code>throw</code></a> statement, evaluation of the script halts
and the <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> returns with <code>Err(Box&lt;EvalAltResult::ErrorRuntime&gt;)</code> containing the
exception value that has been thrown.</p>
<p>It is possible, via the <code>try</code> ... <code>catch</code> statement, to <em>catch</em> exceptions, optionally
with an <em>error variable</em>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Catch an exception and capturing its value
try
{
    throw 42;
}
catch (err)         // 'err' captures the thrown exception value
{
    print(err);     // prints 42
}

// Catch an exception without capturing its value
try
{
    print(42/0);    // deliberate divide-by-zero exception
}
catch               // no error variable - exception value is discarded
{
    print(&quot;Ouch!&quot;);
}

// Exception in the 'catch' block
try
{
    print(42/0);    // throw divide-by-zero exception
}
catch
{
    print(&quot;You seem to be dividing by zero here...&quot;);

    throw &quot;die&quot;;    // a 'throw' statement inside a 'catch' block
                    // throws a new exception
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#re-throw-exception" id="re-throw-exception">Re-Throw Exception</a></h2>
<p>Like the <code>try</code> ... <code>catch</code> syntax in most languages, it is possible to <em>re-throw</em>
an exception within the <code>catch</code> block simply by another <a href="language//book/vnext/language/throw.html"><code>throw</code></a> statement without
a value.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>try
{
    // Call something that will throw an exception...
    do_something_bad_that_throws();
}
catch
{
    print(&quot;Oooh! You've done something real bad!&quot;);

    throw;          // 'throw' without a value within a 'catch' block
                    // re-throws the original exception
}

<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#catchable-exceptions" id="catchable-exceptions">Catchable Exceptions</a></h2>
<p>Many script-oriented exceptions can be caught via <code>try</code> ... <code>catch</code>:</p>
<table><thead><tr><th>Error type</th><th align="center">Error value</th></tr></thead><tbody>
<tr><td>Runtime error thrown by a <a href="language//book/vnext/language/throw.html"><code>throw</code></a> statement</td><td align="center">value in <code>throw</code> statement</td></tr>
<tr><td>Other runtime error</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Arithmetic error</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Variable not found</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><a href="language//book/vnext/language/functions.html">Function</a> not found</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><a href="language//book/vnext/rust/modules/index.html">Module</a> not found</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Unbound [<code>this</code>]</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Data type mismatch</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Assignment to a calculated/constant value</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><a href="language//book/vnext/language/arrays.html">Array</a>/<a href="language//book/vnext/language/strings-chars.html">string</a> indexing out-of-bounds</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Indexing with an inappropriate data type</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Error in a dot expression</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><code>for</code> statement without a <a href="language//book/vnext/language/iterator.html">type iterator</a></td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Error in an <code>in</code> expression</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td>Data race detected</td><td align="center">error message <a href="language//book/vnext/language/strings-chars.html">string</a></td></tr>
</tbody></table>
<h2><a class="header" href="#non-catchable-exceptions" id="non-catchable-exceptions">Non-Catchable Exceptions</a></h2>
<p>Some exceptions <em>cannot</em> be caught:</p>
<ul>
<li>Syntax error during parsing</li>
<li>System error – e.g. script file not found</li>
<li>Script evaluation metrics over <a href="language//book/vnext/safety/index.html">safety limits</a></li>
<li>Function calls nesting exceeding <a href="language//book/vnext/safety/max-call-stack.html">maximum call stack depth</a></li>
<li>Script evaluation manually terminated</li>
</ul>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Rhai supports defining functions in script (unless disabled with <a href="language//book/vnext/start/features.html"><code>no_function</code></a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x, y) {
    return x + y;
}

fn sub(x, y,) {     // trailing comma in parameters list is OK
    return x - y;
}

add(2, 3) == 5;

sub(2, 3,) == -1;   // trailing comma in arguments list is OK
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implicit-return" id="implicit-return">Implicit Return</a></h2>
<p>Just like in Rust, an implicit return can be used. In fact, the last statement of a block is <em>always</em> the block’s return value
regardless of whether it is terminated with a semicolon <code>';'</code>. This is different from Rust.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x, y) {      // implicit return:
    x + y;          // value of the last statement (no need for ending semicolon)
                    // is used as the return value
}

fn add2(x) {
    return x + 2;   // explicit return
}

add(2, 3) == 5;

add2(42) == 44;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-definitions-only" id="global-definitions-only">Global Definitions Only</a></h2>
<p>Functions can only be defined at the global level, never inside a block or another function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Global level is OK
fn add(x, y) {
    x + y
}

// The following will not compile
fn do_addition(x) {
    fn add_y(n) {   // &lt;- syntax error: functions cannot be defined inside another function
        n + y
    }

    add_y(x)
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#no-access-to-external-scope" id="no-access-to-external-scope">No Access to External Scope</a></h2>
<p>Functions are not <em>closures</em>. They do not capture the calling environment
and can only access their own parameters.
They cannot access variables external to the function itself.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;

fn foo() { x }          // &lt;- syntax error: variable 'x' doesn't exist
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#but-can-call-other-functions" id="but-can-call-other-functions">But Can Call Other Functions</a></h2>
<p>All functions in the same <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> can call each other.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x) { x + 1 }     // function defined in the global namespace

fn bar(x) { foo(x) }    // OK! function 'foo' can be called
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#use-before-definition-allowed" id="use-before-definition-allowed">Use Before Definition Allowed</a></h2>
<p>Unlike C/C++, functions in Rhai can be defined <em>anywhere</em> at global level.</p>
<p>A function does not need to be defined prior to being used in a script;
a statement in the script can freely call a function defined afterwards.</p>
<p>This is similar to Rust and many other modern languages, such as JavaScript’s <code>function</code> keyword.</p>
<h2><a class="header" href="#arguments-are-passed-by-value" id="arguments-are-passed-by-value">Arguments are Passed by Value</a></h2>
<p>Functions defined in script always take <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a> parameters (i.e. they can be of any types).
Therefore, functions with the same name and same <em>number</em> of parameters are equivalent.</p>
<p>All arguments are passed by <em>value</em>, so all Rhai script-defined functions are <em>pure</em>
(i.e. they never modify their arguments).</p>
<p>Any update to an argument will <strong>not</strong> be reflected back to the caller.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change(s) {      // 's' is passed by value
    s = 42;         // only a COPY of 's' is changed
}

let x = 500;

change(x);

x == 500;           // 'x' is NOT changed!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#this--simulating-an-object-method" id="this--simulating-an-object-method"><code>this</code> – Simulating an Object Method</a></h2>
<p>Script-defined functions can also be called in method-call style.
When this happens, the keyword ‘<code>this</code>‘ binds to the object in the method call and can be changed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn change() {       // not that the object does not need a parameter
    this = 42;      // 'this' binds to the object in method-call
}

let x = 500;

x.change();         // call 'change' in method-call style, 'this' binds to 'x'

x == 42;            // 'x' is changed!

change();           // &lt;- error: `this` is unbound
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#is_def_fn" id="is_def_fn"><code>is_def_fn</code></a></h2>
<p>Use <code>is_def_fn</code> to detect if a Rhai function is defined (and therefore callable),
based on its name and the number of parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x) { x + 1 }

is_def_fn(&quot;foo&quot;, 1) == true;

is_def_fn(&quot;foo&quot;, 0) == false;

is_def_fn(&quot;foo&quot;, 2) == false;

is_def_fn(&quot;bar&quot;, 1) == false;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#metadata" id="metadata">Metadata</a></h2>
<p>The function <code>get_fn_metadata_list</code> is a <em>reflection</em> API that returns an array of the metadata
of all script-defined functions in scope.</p>
<p>Functions from the following sources are returned, in order:</p>
<ol>
<li>Encapsulated script environment (e.g. when loading a <a href="language//book/vnext/rust/modules/index.html">module</a> from a script file),</li>
<li>Current script,</li>
<li><a href="language//book/vnext/rust/modules/index.html">Modules</a> imported via the <a href="language//book/vnext/language/modules/import.html"><code>import</code></a> statement (latest imports first),</li>
<li><a href="language//book/vnext/rust/modules/index.html">Modules</a> added via <a href="language//book/vnext/rust/modules/create.html"><code>Engine::register_static_module</code></a> (latest registrations first)</li>
</ol>
<p>The return value is an <a href="language//book/vnext/language/arrays.html">array</a> of <a href="language//book/vnext/language/object-maps.html">object maps</a> (so <code>get_fn_metadata_list</code> is not available under
<a href="language//book/vnext/start/features.html"><code>no_index</code></a> or <a href="language//book/vnext/start/features.html"><code>no_object</code></a>), containing the following fields:</p>
<table><thead><tr><th>Field</th><th align="center">Type</th><th align="center">Optional?</th><th>Description</th></tr></thead><tbody>
<tr><td><code>namespace</code></td><td align="center"><a href="language//book/vnext/language/strings-chars.html">string</a></td><td align="center">yes</td><td>the module <em>namespace</em> if the function is defined within a module</td></tr>
<tr><td><code>access</code></td><td align="center"><a href="language//book/vnext/language/strings-chars.html">string</a></td><td align="center">no</td><td><code>&quot;public&quot;</code> if the function is public,<br/><code>&quot;private&quot;</code> if it is private</td></tr>
<tr><td><code>name</code></td><td align="center"><a href="language//book/vnext/language/strings-chars.html">string</a></td><td align="center">no</td><td>function name</td></tr>
<tr><td><code>params</code></td><td align="center"><a href="language//book/vnext/language/arrays.html">array</a> of <a href="language//book/vnext/language/strings-chars.html">strings</a></td><td align="center">no</td><td>parameter names</td></tr>
<tr><td><code>is_anonymous</code></td><td align="center"><code>bool</code></td><td align="center">no</td><td>is this function an anonymous function?</td></tr>
</tbody></table>
<h1><a class="header" href="#call-method-as-function" id="call-method-as-function">Call Method as Function</a></h1>
<h2><a class="header" href="#first-mut-parameter" id="first-mut-parameter">First <code>&amp;mut</code> Parameter</a></h2>
<p>Property <a href="language//book/vnext/rust/getters-setters.html">getters/setters</a> and <a href="language//book/vnext/rust/custom.html">methods</a> in a Rust custom type registered with the <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> can be called
just like a regular function.  In fact, like Rust, property getters/setters and object methods
are registered as regular <a href="language//book/vnext/language/functions.html">functions</a> in Rhai that take a first <code>&amp;mut</code> parameter.</p>
<p>Unlike functions defined in script (for which all arguments are passed by <em>value</em>),
native Rust functions may mutate the object (or the first argument if called in normal function call style).</p>
<p>However, sometimes it is not as straight-forward, and methods called in function-call style may end up
not muting the object – see the example below. Therefore, it is best to always use method-call style.</p>
<p>Custom types, properties and methods can be disabled via the <a href="language//book/vnext/start/features.html"><code>no_object</code></a> feature.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = new_ts();   // constructor function
a.field = 500;      // property setter
a.update();         // method call, 'a' can be modified

update(a);          // &lt;- this de-sugars to 'a.update()' thus if 'a' is a simple variable
                    //    unlike scripted functions, 'a' can be modified and is not a copy

let array = [ a ];

update(array[0]);   // &lt;- 'array[0]' is an expression returning a calculated value,
                    //    a transient (i.e. a copy), so this statement has no effect
                    //    except waste a lot of time cloning

array[0].update();  // &lt;- call in method-call style will update 'a'
<span class="boring">}
</span></code></pre></pre>
<p><strong>IMPORTANT: Rhai does NOT support normal references (i.e. <code>&amp;T</code>) as parameters.</strong></p>
<h2><a class="header" href="#number-of-parameters-in-methods" id="number-of-parameters-in-methods">Number of Parameters in Methods</a></h2>
<p>Native Rust methods registered with an <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> take <em>one additional parameter</em> more than
an equivalent method coded in script, where the object is accessed via the <code>this</code> pointer instead.</p>
<p>The following table illustrates the differences:</p>
<table><thead><tr><th align="center">Function type</th><th align="center">Parameters</th><th align="center">Object reference</th><th align="center">Function signature</th></tr></thead><tbody>
<tr><td align="center">Native Rust</td><td align="center"><em>N</em> + 1</td><td align="center">first <code>&amp;mut T</code> parameter</td><td align="center"><code>Fn(obj: &amp;mut T, x: U, y: V)</code></td></tr>
<tr><td align="center">Rhai script</td><td align="center"><em>N</em></td><td align="center"><code>this</code> (of type <code>&amp;mut T</code>)</td><td align="center"><code>Fn(x: U, y: V)</code></td></tr>
</tbody></table>
<h2><a class="header" href="#mut-is-efficient-except-for-mut-immutablestring" id="mut-is-efficient-except-for-mut-immutablestring"><code>&amp;mut</code> is Efficient, Except for <code>&amp;mut ImmutableString</code></a></h2>
<p>Using a <code>&amp;mut</code> first parameter is highly encouraged when using types that are expensive to clone,
even when the intention is not to mutate that argument, because it avoids cloning that argument value.</p>
<p>Even when a function is never intended to be a method – for example an operator,
it is still sometimes beneficial to make it method-like (i.e. with a first <code>&amp;mut</code> parameter)
if the first parameter is not modified.</p>
<p>For types that are expensive to clone (remember, all function calls are passed cloned
copies of argument values), this may result in a significant performance boost.</p>
<p>For primary types that are cheap to clone (e.g. those that implement <code>Copy</code>), including <code>ImmutableString</code>,
this is not necessary.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a type that is very expensive to clone.
#[derive(Debug, Clone)]
struct VeryComplexType { ... }

// Calculate some value by adding 'VeryComplexType' with an integer number.
fn do_add(obj: &amp;VeryComplexType, offset: i64) -&gt; i64 {
    ...
}

engine
    .register_type::&lt;VeryComplexType&gt;()
    .register_fn(&quot;+&quot;, add_pure /* or  add_method*/);

// Very expensive to call, as the 'VeryComplexType' is cloned before each call.
fn add_pure(obj: VeryComplexType, offset: i64) -&gt; i64 {
    do_add(obj, offset)
}

// Efficient to call, as only a reference to the 'VeryComplexType' is passed.
fn add_method(obj: &amp;mut VeryComplexType, offset: i64) -&gt; i64 {
    do_add(obj, offset)
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-overloading-1" id="function-overloading-1">Function Overloading</a></h1>
<p><a href="language//book/vnext/language/functions.html">Functions</a> defined in script can be <em>overloaded</em> by <em>arity</em> (i.e. they are resolved purely upon the function’s <em>name</em>
and <em>number</em> of parameters, but not parameter <em>types</em> since all parameters are the same type – <a href="language//book/vnext/language/dynamic.html"><code>Dynamic</code></a>).</p>
<p>New definitions <em>overwrite</em> previous definitions of the same name and number of parameters.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x,y,z) { print(&quot;Three!!! &quot; + x + &quot;,&quot; + y + &quot;,&quot; + z); }

fn foo(x)     { print(&quot;One! &quot; + x); }

fn foo(x,y)   { print(&quot;Two! &quot; + x + &quot;,&quot; + y); }

fn foo()      { print(&quot;None.&quot;); }

fn foo(x)     { print(&quot;HA! NEW ONE! &quot; + x); }   // overwrites previous definition

foo(1,2,3);     // prints &quot;Three!!! 1,2,3&quot;

foo(42);        // prints &quot;HA! NEW ONE! 42&quot;

foo(1,2);       // prints &quot;Two!! 1,2&quot;

foo();          // prints &quot;None.&quot;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-namespaces" id="function-namespaces">Function Namespaces</a></h1>
<h2><a class="header" href="#each-function-is-a-separate-compilation-unit" id="each-function-is-a-separate-compilation-unit">Each Function is a Separate Compilation Unit</a></h2>
<p><a href="language//book/vnext/language/functions.html">Functions</a> in Rhai are <em>pure</em> and they form individual <em>compilation units</em>.
This means that individual functions can be separated, exported, re-grouped, imported,
and generally mix-’n-match-ed with other completely unrelated scripts.</p>
<p>For example, the <code>AST::merge</code> and <code>AST::combine</code> methods (or the equivalent <code>+</code> and <code>+=</code> operators)
allow combining all functions in one <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> into another, forming a new, unified, group of functions.</p>
<p>In general, there are two types of <em>namespaces</em> where functions are looked up:</p>
<table><thead><tr><th>Namespace</th><th align="center">How Many</th><th>Source</th><th>Lookup</th><th align="center">Sub-modules?</th><th align="center">Variables?</th></tr></thead><tbody>
<tr><td>Global</td><td align="center">One</td><td>1) <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> being evaluated<br/>2) <code>Engine::register_XXX</code> API<br/>3) global <a href="language//book/vnext/rust/modules/index.html">modules</a> registered via <code>Engine::register_global_module</code><br/>4) functions in static <a href="language//book/vnext/rust/modules/index.html">modules</a> registered via <code>Engine::register_static_module</code> and marked <em>global</em></td><td>simple name</td><td align="center">ignored</td><td align="center">ignored</td></tr>
<tr><td>Module</td><td align="center">Many</td><td>1) <a href="language//book/vnext/rust/modules/index.html">Module</a> registered via <code>Engine::register_static_module</code><br/>2) <a href="language//book/vnext/rust/modules/index.html">Module</a> loaded via <a href="language//book/vnext/language/modules/import.html"><code>import</code></a> statement</td><td>namespace-qualified name</td><td align="center">yes</td><td align="center">yes</td></tr>
</tbody></table>
<h2><a class="header" href="#module-namespaces" id="module-namespaces">Module Namespaces</a></h2>
<p>There can be multiple module namespaces at any time during a script evaluation, usually loaded via the
<a href="language//book/vnext/language/modules/import.html"><code>import</code></a> statement.</p>
<p><em>Static</em> module namespaces can also be registered into an <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> via <code>Engine::register_static_module</code>.</p>
<p>Functions and variables in module namespaces are isolated and encapsulated within their own environments.</p>
<p>They must be called or accessed in a <em>namespace-qualified</em> manner.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import &quot;my_module&quot; as m;            // new module namespace 'm' created via 'import'

let x = m::calc_result();           // namespace-qualified function call

let y = m::MY_NUMBER;               // namespace-qualified variable (constant) access

let x = calc_result();              // &lt;- error: function 'calc_result' not found
                                    //    in global namespace!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-namespace" id="global-namespace">Global Namespace</a></h2>
<p>There is one <em>global</em> namespace for every <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a>, which includes (in the following search order):</p>
<ul>
<li>
<p>All functions defined in the <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> currently being evaluated.</p>
</li>
<li>
<p>All native Rust functions and iterators registered via the <code>Engine::register_XXX</code> API.</p>
</li>
<li>
<p>All functions and iterators defined in global <a href="language//book/vnext/rust/modules/index.html">modules</a> that are registered into the <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> via
<code>Engine::register_global_module</code>.</p>
</li>
<li>
<p>Functions defined in <a href="language//book/vnext/rust/modules/index.html">modules</a> registered via <code>Engine::register_static_module</code> that are specifically
marked for exposure to the global namespace (e.g. via the <code>#[rhai(global)]</code> attribute in a <a href="language//book/vnext/plugins/module.html">plugin module</a>).</p>
</li>
</ul>
<p>Anywhere in a Rhai script, when a function call is made, the function is searched within the
global namespace, in the above search order.</p>
<p>Therefore, function calls in Rhai are <em>late</em> bound – meaning that the function called cannot be
determined or guaranteed and there is no way to <em>lock down</em> the function being called.
This aspect is very similar to JavaScript before ES6 modules.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile a script into AST
let ast1 = engine.compile(
    r#&quot;
        fn get_message() {
            &quot;Hello!&quot;                // greeting message
        }

        fn say_hello() {
            print(get_message());   // prints message
        }

        say_hello();
    &quot;#
)?;

// Compile another script with an overriding function
let ast2 = engine.compile(r#&quot;fn get_message() { &quot;Boo!&quot; }&quot;#)?;

// Combine the two AST's
ast1 += ast2;                       // 'message' will be overwritten

engine.consume_ast(&amp;ast1)?;         // prints 'Boo!'
<span class="boring">}
</span></code></pre></pre>
<p>Therefore, care must be taken when <em>cross-calling</em> functions to make sure that the correct
functions are called.</p>
<p>The only practical way to ensure that a function is a correct one is to use <a href="language//book/vnext/rust/modules/index.html">modules</a> -
i.e. define the function in a separate module and then <a href="language//book/vnext/language/modules/import.html"><code>import</code></a> it:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>----------------
| message.rhai |
----------------

fn get_message() { &quot;Hello!&quot; }


---------------
| script.rhai |
---------------

import &quot;message&quot; as msg;

fn say_hello() {
    print(msg::get_message());
}
say_hello();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-pointers" id="function-pointers">Function Pointers</a></h1>
<p>It is possible to store a <em>function pointer</em> in a variable just like a normal value.
In fact, internally a function pointer simply stores the <em>name</em> of the function as a string.</p>
<p>A function pointer is created via the <code>Fn</code> function, which takes a <a href="language//book/vnext/language/strings-chars.html">string</a> parameter.</p>
<p>Call a function pointer using the <code>call</code> method.</p>
<h2><a class="header" href="#built-in-methods" id="built-in-methods">Built-in methods</a></h2>
<p>The following standard methods (mostly defined in the <a href="language//book/vnext/rust/packages/index.html"><code>BasicFnPackage</code></a> but excluded if
using a <a href="language//book/vnext/engine/raw.html">raw <code>Engine</code></a>) operate on function pointers:</p>
<table><thead><tr><th>Function</th><th>Parameter(s)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code> method and property</td><td><em>none</em></td><td>returns the name of the function encapsulated by the function pointer</td></tr>
<tr><td><code>is_anonymous</code> method and property</td><td><em>none</em></td><td>does the function pointer refer to an <a href="language//book/vnext/language/fn-anon.html">anonymous function</a>? Not available under <a href="language//book/vnext/start/features.html"><code>no_function</code></a>.</td></tr>
<tr><td><code>call</code></td><td><em>arguments</em></td><td>calls the function matching the function pointer’s name with the <em>arguments</em></td></tr>
</tbody></table>
<h2><a class="header" href="#examples-10" id="examples-10">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x) { 41 + x }

let func = Fn(&quot;foo&quot;);       // use the 'Fn' function to create a function pointer

print(func);                // prints 'Fn(foo)'

let func = fn_name.Fn();    // &lt;- error: 'Fn' cannot be called in method-call style

func.type_of() == &quot;Fn&quot;;     // type_of() as function pointer is 'Fn'

func.name == &quot;foo&quot;;

func.call(1) == 42;         // call a function pointer with the 'call' method

foo(1) == 42;               // &lt;- the above de-sugars to this

call(func, 1);              // normal function call style also works for 'call'

let len = Fn(&quot;len&quot;);        // 'Fn' also works with registered native Rust functions

len.call(&quot;hello&quot;) == 5;

let add = Fn(&quot;+&quot;);          // 'Fn' works with built-in operators also

add.call(40, 2) == 42;

let fn_name = &quot;hello&quot;;      // the function name does not have to exist yet

let hello = Fn(fn_name + &quot;_world&quot;);

hello.call(0);              // error: function not found - 'hello_world (i64)'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#global-namespace-only" id="global-namespace-only">Global Namespace Only</a></h2>
<p>Because of their dynamic nature, function pointers cannot refer to functions in <a href="language//book/vnext/language/modules/import.html"><code>import</code></a>-ed <a href="language//book/vnext/rust/modules/index.html">modules</a>.
They can only refer to functions within the global <a href="language//book/vnext/language/fn-namespaces.html">namespace</a>.
See <em><a href="language//book/vnext/language/fn-namespaces.html">Function Namespaces</a></em> for more details.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import &quot;foo&quot; as f;          // assume there is 'f::do_work()'

f::do_work();               // works!

let p = Fn(&quot;f::do_work&quot;);   // error: invalid function name

fn do_work_now() {          // call it from a local function
    f::do_work();
}

let p = Fn(&quot;do_work_now&quot;);

p.call();                   // works!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#dynamic-dispatch" id="dynamic-dispatch">Dynamic Dispatch</a></h2>
<p>The purpose of function pointers is to enable rudimentary <em>dynamic dispatch</em>, meaning to determine,
at runtime, which function to call among a group.</p>
<p>Although it is possible to simulate dynamic dispatch via a number and a large <code>if-then-else-if</code> statement,
using function pointers significantly simplifies the code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = some_calculation();

// These are the functions to call depending on the value of 'x'
fn method1(x) { ... }
fn method2(x) { ... }
fn method3(x) { ... }

// Traditional - using decision variable
let func = sign(x);

// Dispatch with if-statement
if func == -1 {
    method1(42);
} else if func == 0 {
    method2(42);
} else if func == 1 {
    method3(42);
}

// Using pure function pointer
let func = if x &lt; 0 {
    Fn(&quot;method1&quot;)
} else if x == 0 {
    Fn(&quot;method2&quot;)
} else if x &gt; 0 {
    Fn(&quot;method3&quot;)
}

// Dynamic dispatch
func.call(42);

// Using functions map
let map = [ Fn(&quot;method1&quot;), Fn(&quot;method2&quot;), Fn(&quot;method3&quot;) ];

let func = sign(x) + 1;

// Dynamic dispatch
map[func].call(42);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#bind-the-this-pointer" id="bind-the-this-pointer">Bind the <code>this</code> Pointer</a></h2>
<p>When <code>call</code> is called as a <em>method</em> but not on a function pointer, it is possible to dynamically dispatch
to a function call while binding the object in the method call to the <code>this</code> pointer of the function.</p>
<p>To achieve this, pass the function pointer as the <em>first</em> argument to <code>call</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x) {                 // define function which uses 'this'
    this += x;
}

let func = Fn(&quot;add&quot;);       // function pointer to 'add'

func.call(1);               // error: 'this' pointer is not bound

let x = 41;

func.call(x, 1);            // error: function 'add (i64, i64)' not found

call(func, x, 1);           // error: function 'add (i64, i64)' not found

x.call(func, 1);            // 'this' is bound to 'x', dispatched to 'func'

x == 42;
<span class="boring">}
</span></code></pre></pre>
<p>Beware that this only works for <em>method-call</em> style.  Normal function-call style cannot bind
the <code>this</code> pointer (for syntactic reasons).</p>
<p>Therefore, obviously, binding the <code>this</code> pointer is unsupported under <a href="language//book/vnext/start/features.html"><code>no_object</code></a>.</p>
<h2><a class="header" href="#call-a-function-pointer-in-rust" id="call-a-function-pointer-in-rust">Call a Function Pointer in Rust</a></h2>
<p>It is completely normal to register a Rust function with an <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> that takes parameters
whose types are function pointers.  The Rust type in question is <code>rhai::FnPtr</code>.</p>
<p>A function pointer in Rhai is essentially syntactic sugar wrapping the <em>name</em> of a function
to call in script.  Therefore, the script’s <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> is required to call a function pointer,
as well as the entire <em>execution context</em> that the script is running in.</p>
<p>For a rust function taking a function pointer as parameter, the <a href="language/../rust/register-raw.html">Low-Level API</a>
must be used to register the function.</p>
<p>Essentially, use the low-level <code>Engine::register_raw_fn</code> method to register the function.
<code>FnPtr::call_dynamic</code> is used to actually call the function pointer, passing to it the
current <em>native call context</em>, the <code>this</code> pointer, and other necessary arguments.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Module, Dynamic, FnPtr, NativeCallContext};

let mut engine = Engine::new();

// Define Rust function in required low-level API signature
fn call_fn_ptr_with_value(context: NativeCallContext, args: &amp;mut [&amp;mut Dynamic])
    -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
{
    // 'args' is guaranteed to contain enough arguments of the correct types
    let fp = std::mem::take(args[1]).cast::&lt;FnPtr&gt;();   // 2nd argument - function pointer
    let value = args[2].clone();                        // 3rd argument - function argument
    let this_ptr = args.get_mut(0).unwrap();            // 1st argument - this pointer

    // Use 'FnPtr::call_dynamic' to call the function pointer.
    // Beware, private script-defined functions will not be found.
    fp.call_dynamic(context, Some(this_ptr), [value])
}

// Register a Rust function using the low-level API
engine.register_raw_fn(&quot;super_call&quot;,
    &amp;[ // parameter types
        std::any::TypeId::of::&lt;i64&gt;(),
        std::any::TypeId::of::&lt;FnPtr&gt;(),
        std::any::TypeId::of::&lt;i64&gt;()
    ],
    call_fn_ptr_with_value
);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#nativecallcontext" id="nativecallcontext"><code>NativeCallContext</code></a></h2>
<p><code>FnPtr::call_dynamic</code> takes a parameter of type <code>NativeCallContext</code> which holds the <em>native call context</em>
of the particular call to a registered Rust function. It is a type that exposes the following:</p>
<table><thead><tr><th>Field</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>the current <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a>, with all configurations and settings.<br/>This is sometimes useful for calling a script-defined function within the same evaluation context using <a href="language//book/vnext/engine/call-fn.html"><code>Engine::call_fn</code></a>, or calling a <a href="language//book/vnext/language/fn-ptr.html">function pointer</a>.</td></tr>
<tr><td><code>fn_name()</code></td><td align="center"><code>&amp;str</code></td><td>name of the function called (useful when the same Rust function is mapped to multiple Rhai-callable function names)</td></tr>
<tr><td><code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td><code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="language//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td><code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="language//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="language//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td><code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="language//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td><code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="language//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="language//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
</tbody></table>
<p>This type is normally provided by the <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> (e.g. when using <a href="language/../rust/register-raw.html"><code>Engine::register_fn_raw</code></a>).
However, it may also be manually constructed from a tuple:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, FnPtr, NativeCallContext};

let engine = Engine::new();

// Compile script to AST
let mut ast = engine.compile(
    r#&quot;
        let test = &quot;hello&quot;;
        |x| test + x            // this creates an closure
    &quot;#,
)?;

// Save the closure together with captured variables
let fn_ptr = engine.eval_ast::&lt;FnPtr&gt;(&amp;ast)?;

// Get rid of the script, retaining only functions
ast.retain_functions(|_, _, _| true);

// Create function namespace from the 'AST'
let lib = [ast.as_ref()];

// Create native call context
let fn_name = fn_ptr.fn_name().to_string();
let context = NativeCallContext::new(&amp;engine, &amp;fn_name, &amp;lib);

// 'f' captures: the engine, the AST, and the closure
let f = move |x: i64| fn_ptr.call_dynamic(context, None, [x.into()]);

// 'f' can be called like a normal function
let result = f(42)?;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#function-pointer-currying" id="function-pointer-currying">Function Pointer Currying</a></h1>
<p>It is possible to <em>curry</em> a <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> by providing partial (or all) arguments.</p>
<p>Currying is done via the <code>curry</code> keyword and produces a new <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> which carries
the curried arguments.</p>
<p>When the curried <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> is called, the curried arguments are inserted starting from the left.
The actual call arguments should be reduced by the number of curried arguments.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mul(x, y) {                  // function with two parameters
    x * y
}

let func = Fn(&quot;mul&quot;);

func.call(21, 2) == 42;         // two arguments are required for 'mul'

let curried = func.curry(21);   // currying produces a new function pointer which
                                // carries 21 as the first argument

let curried = curry(func, 21);  // function-call style also works

curried.call(2) == 42;          // &lt;- de-sugars to 'func.call(21, 2)'
                                //    only one argument is now required
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#automatic-currying" id="automatic-currying">Automatic Currying</a></h2>
<p><a href="language//book/vnext/language/fn-anon.html">Anonymous functions</a> defined via a closure syntax <em>capture</em> external variables
that are not shadowed inside the function’s scope.</p>
<p>This is accomplished via <a href="language//book/vnext/language/fn-closure.html">automatic currying</a>.</p>
<h1><a class="header" href="#anonymous-functions" id="anonymous-functions">Anonymous Functions</a></h1>
<p>Sometimes it gets tedious to define separate functions only to dispatch them via single <a href="language//book/vnext/language/fn-ptr.html">function pointers</a>.
This scenario is especially common when simulating object-oriented programming (<a href="language//book/vnext/patterns/oop.html">OOP</a>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define object
let obj = #{
    data: 42,
    increment: Fn(&quot;inc_obj&quot;),       // use function pointers to
    decrement: Fn(&quot;dec_obj&quot;),       // refer to method functions
    print: Fn(&quot;print_obj&quot;)
};

// Define method functions one-by-one
fn inc_obj(x) { this.data += x; }
fn dec_obj(x) { this.data -= x; }
fn print_obj() { print(this.data); }
<span class="boring">}
</span></code></pre></pre>
<p>The above can be replaced by using <em>anonymous functions</em> which have the same syntax as Rust’s closures
(but they are <strong>NOT</strong> real closures, merely syntactic sugar):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let obj = #{
    data: 42,
    increment: |x| this.data += x,          // one-liner
    decrement: |x| this.data -= x,
    print_obj: || { print(this.data); }     // full function body
};
<span class="boring">}
</span></code></pre></pre>
<p>The anonymous functions will be hoisted into separate functions in the global namespace.
The above is equivalent to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let obj = #{
    data: 42,
    increment: Fn(&quot;anon_fn_1000&quot;),
    decrement: Fn(&quot;anon_fn_1001&quot;),
    print: Fn(&quot;anon_fn_1002&quot;)
};

fn anon_fn_1000(x) { this.data += x; }
fn anon_fn_1001(x) { this.data -= x; }
fn anon_fn_1002() { print this.data; }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#warning--not-real-closures" id="warning--not-real-closures">WARNING – NOT Real Closures</a></h2>
<p>Remember: anonymous functions, though having the same syntax as Rust <em>closures</em>, are themselves
<strong>not</strong> real closures.</p>
<p>In particular, they capture their execution environment via <a href="language//book/vnext/language/fn-closure.html">automatic currying</a>
(disabled via <a href="language//book/vnext/start/features.html"><code>no_closure</code></a>).</p>
<h1><a class="header" href="#simulating-closures" id="simulating-closures">Simulating Closures</a></h1>
<h2><a class="header" href="#capture-external-variables-via-automatic-currying" id="capture-external-variables-via-automatic-currying">Capture External Variables via Automatic Currying</a></h2>
<p>Since <a href="language//book/vnext/language/fn-anon.html">anonymous functions</a> de-sugar to standard function definitions, they retain all the behaviors of
Rhai functions, including being <em>pure</em>, having no access to external variables.</p>
<p>The anonymous function syntax, however, automatically <em>captures</em> variables that are not defined within
the current scope, but are defined in the external scope – i.e. the scope where the anonymous function
is created.</p>
<p>Variables that are accessible during the time the <a href="language//book/vnext/language/fn-anon.html">anonymous function</a> is created can be captured,
as long as they are not shadowed by local variables defined within the function’s scope.</p>
<p>The captured variables are automatically converted into <strong>reference-counted shared values</strong>
(<code>Rc&lt;RefCell&lt;Dynamic&gt;&gt;</code> in normal builds, <code>Arc&lt;RwLock&lt;Dynamic&gt;&gt;</code> in <a href="language//book/vnext/start/features.html"><code>sync</code></a> builds).</p>
<p>Therefore, similar to closures in many languages, these captured shared values persist through
reference counting, and may be read or modified even after the variables that hold them
go out of scope and no longer exist.</p>
<p>Use the <code>Dynamic::is_shared</code> function to check whether a particular value is a shared value.</p>
<p>Automatic currying can be turned off via the <a href="language//book/vnext/start/features.html"><code>no_closure</code></a> feature.</p>
<h2><a class="header" href="#examples-11" id="examples-11">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1;                          // a normal variable

x.is_shared() == false;

let f = |y| x + y;                  // variable 'x' is auto-curried (captured) into 'f'

x.is_shared() == true;              // 'x' is now a shared value!

f.call(2) == 3;                     // 1 + 2 == 3

x = 40;                             // changing 'x'...

f.call(2) == 42;                    // the value of 'x' is 40 because 'x' is shared

// The above de-sugars into this:
fn anon$1001(x, y) { x + y }        // parameter 'x' is inserted

$make_shared(x);                    // convert variable 'x' into a shared value

let f = Fn(&quot;anon$1001&quot;).curry(x);   // shared 'x' is curried

f.call(2) == 42;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#beware-captured-variables-are-truly-shared" id="beware-captured-variables-are-truly-shared">Beware: Captured Variables are Truly Shared</a></h2>
<p>The example below is a typical tutorial sample for many languages to illustrate the traps
that may accompany capturing external scope variables in closures.</p>
<p>It prints <code>9</code>, <code>9</code>, <code>9</code>, ... <code>9</code>, <code>9</code>, not <code>0</code>, <code>1</code>, <code>2</code>, ... <code>8</code>, <code>9</code>, because there is
ever only <em>one</em> captured variable, and all ten closures capture the <em>same</em> variable.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let funcs = [];

for i in range(0, 10) {
    funcs.push(|| print(i));        // the for loop variable 'i' is captured
}

funcs.len() == 10;                  // 10 closures stored in the array

funcs[0].type_of() == &quot;Fn&quot;;         // make sure these are closures

for f in funcs {
    f.call();                       // all references to 'i' are the same variable!
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#therefore--be-careful-to-prevent-data-races" id="therefore--be-careful-to-prevent-data-races">Therefore – Be Careful to Prevent Data Races</a></h2>
<p>Rust does not have data races, but that doesn’t mean Rhai doesn’t.</p>
<p>Avoid performing a method call on a captured shared variable (which essentially takes a
mutable reference to the shared object) while using that same variable as a parameter
in the method call – this is a sure-fire way to generate a data race error.</p>
<p>If a shared value is used as the <code>this</code> pointer in a method call to a closure function,
then the same shared value <em>must not</em> be captured inside that function, or a data race
will occur and the script will terminate with an error.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 20;

x.is_shared() == false;             // 'x' is not shared, so no data race is possible

let f = |a| this += x + a;          // 'x' is captured in this closure

x.is_shared() == true;              // now 'x' is shared

x.call(f, 2);                       // &lt;- error: data race detected on 'x'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#data-races-in-sync-builds-can-become-deadlocks" id="data-races-in-sync-builds-can-become-deadlocks">Data Races in <code>sync</code> Builds Can Become Deadlocks</a></h2>
<p>Under the <a href="language//book/vnext/start/features.html"><code>sync</code></a> feature, shared values are guarded with a <code>RwLock</code>, meaning that data race
conditions no longer raise an error.</p>
<p>Instead, they wait endlessly for the <code>RwLock</code> to be freed, and thus can become deadlocks.</p>
<p>On the other hand, since the same thread (i.e. the <a href="language//book/vnext/engine/hello-world.html"><code>Engine</code></a> thread) that is holding the lock
is attempting to read it again, this may also <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html#panics-1">panic</a>
depending on the O/S.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 20;

let f = |a| this += x + a;          // 'x' is captured in this closure

// Under `sync`, the following may wait forever, or may panic,
// because 'x' is locked as the `this` pointer but also accessed
// via a captured shared value.
x.call(f, 2);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#tldr" id="tldr">TL;DR</a></h2>
<h3><a class="header" href="#q-how-is-it-actually-implemented" id="q-how-is-it-actually-implemented">Q: How is it actually implemented?</a></h3>
<p>The actual implementation of closures de-sugars to:</p>
<ol>
<li>
<p>Keeping track of what variables are accessed inside the anonymous function,</p>
</li>
<li>
<p>If a variable is not defined within the anonymous function’s scope, it is looked up <em>outside</em> the function and
in the current execution scope – where the anonymous function is created.</p>
</li>
<li>
<p>The variable is added to the parameters list of the anonymous function, at the front.</p>
</li>
<li>
<p>The variable is then converted into a <strong>reference-counted shared value</strong>.</p>
<p>An <a href="language//book/vnext/language/fn-anon.html">anonymous function</a> which captures an external variable is the only way to create a reference-counted shared value in Rhai.</p>
</li>
<li>
<p>The shared value is then <a href="language//book/vnext/language/fn-curry.html">curried</a> into the <a href="language//book/vnext/language/fn-ptr.html">function pointer</a> itself, essentially carrying a reference to that shared value
and inserting it into future calls of the function.</p>
<p>This process is called <em>Automatic Currying</em>, and is the mechanism through which Rhai simulates normal closures.</p>
</li>
</ol>
<h3><a class="header" href="#q-why-are-closures-implemented-as-automatic-currying" id="q-why-are-closures-implemented-as-automatic-currying">Q: Why are closures implemented as automatic currying?</a></h3>
<p>In concept, a closure <em>closes</em> over captured variables from the outer scope – that’s why
they are called <em>closures</em>.  When this happen, a typical language implementation hoists
those variables that are captured away from the stack frame and into heap-allocated storage.
This is because those variables may be needed after the stack frame goes away.</p>
<p>These heap-allocated captured variables only go away when all the closures that need them
are finished with them.  A garbage collector makes this trivial to implement – they are
automatically collected as soon as all closures needing them are destroyed.</p>
<p>In Rust, this can be done by reference counting instead, with the potential pitfall of creating
reference loops that will prevent those variables from being deallocated forever.
Rhai avoids this by clone-copying most data values, so reference loops are hard to create.</p>
<p>Rhai does the hoisting of captured variables into the heap by converting those values
into reference-counted locked values, also allocated on the heap.  The process is identical.</p>
<p>Closures are usually implemented as a data structure containing two items:</p>
<ol>
<li>A function pointer to the function body of the closure,</li>
<li>A data structure containing references to the captured shared variables on the heap.</li>
</ol>
<p>Usually a language implementation passes the structure containing references to captured
shared variables into the function pointer, the function body taking this data structure
as an additional parameter.</p>
<p>This is essentially what Rhai does, except that Rhai passes each variable individually
as separate parameters to the function, instead of creating a structure and passing that
structure as a single parameter.  This is the only difference.</p>
<p>Therefore, in most languages, essentially all closures are implemented as automatic currying of
shared variables hoisted into the heap, automatically passing those variables as parameters into
the function. Rhai just brings this directly up to the front.</p>
<h1><a class="header" href="#print-and-debug" id="print-and-debug"><code>print</code> and <code>debug</code></a></h1>
<p>The <code>print</code> and <code>debug</code> functions default to printing to <code>stdout</code>, with <code>debug</code> using standard debug formatting.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print(&quot;hello&quot;);         // prints hello to stdout

print(1 + 2 + 3);       // prints 6 to stdout

print(&quot;hello&quot; + 42);    // prints hello42 to stdout

debug(&quot;world!&quot;);        // prints &quot;world!&quot; to stdout using debug formatting
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#override-print-and-debug-with-callback-functions" id="override-print-and-debug-with-callback-functions">Override <code>print</code> and <code>debug</code> with Callback Functions</a></h2>
<p>When embedding Rhai into an application, it is usually necessary to trap <code>print</code> and <code>debug</code> output
(for logging into a tracking log, for example) with the <code>Engine::on_print</code> and <code>Engine::on_debug</code> methods:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Any function or closure that takes an '&amp;str' argument can be used to override 'print'.
engine.on_print(|x| println!(&quot;hello: {}&quot;, x));

// Any function or closure that takes a '&amp;str' and a 'Position' argument can be used to
// override 'debug'.
engine.on_debug(|x, src, pos| println!(&quot;DEBUG of {} at {:?}: {}&quot;, src.unwrap_or(&quot;unknown&quot;), pos, x));

// Example: quick-'n-dirty logging
let logbook = Arc::new(RwLock::new(Vec::&lt;String&gt;::new()));

// Redirect print/debug output to 'log'
let log = logbook.clone();
engine.on_print(move |s| log.write().unwrap().push(format!(&quot;entry: {}&quot;, s)));

let log = logbook.clone();
engine.on_debug(move |s, src, pos| log.write().unwrap().push(
                        format!(&quot;DEBUG of {} at {:?}: {}&quot;, src.unwrap_or(&quot;unknown&quot;), pos, s)
               ));

// Evaluate script
engine.eval::&lt;()&gt;(script)?;

// 'logbook' captures all the 'print' and 'debug' output
for entry in logbook.read().unwrap().iter() {
    println!(&quot;{}&quot;, entry);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#on_debug-callback-signature" id="on_debug-callback-signature"><code>on_debug</code> Callback Signature</a></h2>
<p>The function signature passed to <code>Engine::on_debug</code> takes the following form:</p>
<blockquote>
<p><code>Fn(text: &amp;str, source: Option&lt;&amp;str&gt;, pos: Position) + 'static</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th>Parameter</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>text</code></td><td align="center"><code>&amp;str</code></td><td>text to display</td></tr>
<tr><td><code>source</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>source of the current evaluation, if any</td></tr>
<tr><td><code>pos</code></td><td align="center"><code>Position</code></td><td>position (line number and character offset) of the <code>debug</code> call</td></tr>
</tbody></table>
<p>The <em>source</em> of a script evaluation is any text string provided to an <a href="language//book/vnext/engine/compile.html"><code>AST</code></a> via the <code>AST::set_source</code> method.</p>
<p>If a <a href="language//book/vnext/rust/modules/index.html">module</a> is loaded via an <a href="language//book/vnext/language/modules/import.html"><code>import</code></a> statement, then the <em>source</em> of functions defined
within the module will be the module’s <em>path</em>.</p>
<h1><a class="header" href="#modules-1" id="modules-1">Modules</a></h1>
<p>Rhai allows organizing code (functions, both Rust-based or script-based, and variables) into <em>modules</em>.
Modules can be disabled via the <a href="language/modules//book/vnext/start/features.html"><code>no_module</code></a> feature.</p>
<p>A module is of the type <code>Module</code> and holds a collection of functions, variables, <a href="language/modules//book/vnext/language/iterator.html">type iterators</a> and sub-modules.
It may be created entirely from Rust functions, or it may encapsulate a Rhai script together with the functions
and variables defined by that script.</p>
<p>Other scripts can then load this module and use the functions and variables exported
as if they were defined inside the same script.</p>
<h1><a class="header" href="#export-variables-functions-and-sub-modules-in-module" id="export-variables-functions-and-sub-modules-in-module">Export Variables, Functions and Sub-Modules in Module</a></h1>
<p>The easiest way to expose a collection of functions as a self-contained <a href="language/modules//book/vnext/rust/modules/index.html">module</a> is to do it via a Rhai script itself.</p>
<p>See the section on <a href="language/modules//book/vnext/rust/modules/ast.html"><em>Creating a Module from AST</em></a> for more details.</p>
<p>The script text is evaluated, variables are then selectively exposed via the <a href="language/modules//book/vnext/language/modules/export.html"><code>export</code></a> statement.
Functions defined by the script are automatically exported.</p>
<p>Modules loaded within this module at the global level become <em>sub-modules</em> and are also automatically exported.</p>
<h2><a class="header" href="#export-global-variables" id="export-global-variables">Export Global Variables</a></h2>
<p>The <code>export</code> statement, which can only be at global level, exposes selected variables as members of a module.</p>
<p>Variables not exported are <em>private</em> and hidden. They are merely used to initialize the module,
but cannot be accessed from outside.</p>
<p>Everything exported from a module is <strong>constant</strong> (i.e. read-only).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a module script.

let hidden = 123;       // variable not exported - default hidden
let x = 42;             // this will be exported below

export x;               // the variable 'x' is exported under its own name

export let x = 42;      // convenient short-hand to declare a variable and export it
                        // under its own name

export x as answer;     // the variable 'x' is exported under the alias 'answer'
                        // another script can load this module and access 'x' as 'module::answer'

{
    let inner = 0;      // local variable - it disappears when the statement block ends,
                        //                  therefore it is not 'global' and cannot be exported

    export inner;       // &lt;- syntax error: cannot export a local variable
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#multiple-exports" id="multiple-exports">Multiple Exports</a></h3>
<p>One <code>export</code> statement can export multiple variables, even under multiple names.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following exports three variables:
//   - 'x' (as 'x' and 'hello')
//   - 'y' (as 'foo' and 'bar')
//   - 'z' (as 'z')
export x, x as hello, x as world, y as foo, y as bar, z;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#export-functions" id="export-functions">Export Functions</a></h2>
<p>All functions are automatically exported, <em>unless</em> it is explicitly opt-out with the <a href="language/modules//book/vnext/engine/call-fn.html"><code>private</code></a> prefix.</p>
<p>Functions declared <a href="language/modules//book/vnext/engine/call-fn.html"><code>private</code></a> are hidden to the outside.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a module script.

fn inc(x) { x + 1 }     // script-defined function - default public

private fn foo() {}     // private function - hidden
<span class="boring">}
</span></code></pre></pre>
<p><a href="language/modules//book/vnext/engine/call-fn.html"><code>private</code></a> functions are commonly called to initialize the module.
They cannot be called apart from this.</p>
<h2><a class="header" href="#sub-modules" id="sub-modules">Sub-Modules</a></h2>
<p>All loaded modules are automatically exported as sub-modules.</p>
<p>To prevent a module from being exported, load it inside a block statement so that it goes away at the
end of the block.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This is a module script.

import &quot;hello&quot; as foo;      // exported as sub-module 'foo'

{
    import &quot;world&quot; as bar;  // not exported - the module disappears at the end
                            //                of the statement block and is not 'global'
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#import-a-module" id="import-a-module">Import a Module</a></h1>
<p>Before a module can be used (via an <code>import</code> statement) in a script, there must be a <a href="language/modules//book/vnext/rust/modules/resolvers.html">module resolver</a>
registered into the <a href="language/modules//book/vnext/engine/hello-world.html"><code>Engine</code></a>, the default being the <code>FileModuleResolver</code>.</p>
<p>See the section on <a href="language/modules//book/vnext/rust/modules/resolvers.html"><em>Module Resolvers</em></a> for more details.</p>
<h2><a class="header" href="#import-statement" id="import-statement"><code>import</code> Statement</a></h2>
<p>A module can be <em>imported</em> via the <code>import</code> statement, and be given a name.
Its members can be accessed via ‘<code>::</code>‘ similar to C++.</p>
<p>A module that is only <code>import</code>-ed but not under any module name is commonly used for initialization purposes,
where the module script contains initialization statements that puts the functions registered with the
<a href="language/modules//book/vnext/engine/hello-world.html"><code>Engine</code></a> into a particular state.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import &quot;crypto_init&quot;;           // run the script file 'crypto_init.rhai' without creating an imported module

import &quot;crypto&quot; as lock;        // run the script file 'crypto.rhai' and import it as a module named 'lock'

const SECRET_NUMBER = 42;

let mod_file = &quot;crypto_&quot; + SECRET_NUMBER;

import mod_file as my_mod;      // load the script file &quot;crypto_42.rhai&quot; and import it as a module named 'my_mod'
                                // notice that module path names can be dynamically constructed!
                                // any expression that evaluates to a string is acceptable after the 'import' keyword

lock::encrypt(secret);          // use functions defined under the module via '::'

lock::hash::sha256(key);        // sub-modules are also supported

print(lock::status);            // module variables are constants

lock::status = &quot;off&quot;;           // &lt;- runtime error - cannot modify a constant
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#scoped-imports" id="scoped-imports">Scoped Imports</a></h2>
<p><code>import</code> statements are <em>scoped</em>, meaning that they are only accessible inside the scope that they’re imported.</p>
<p>They can appear anywhere a normal statement can be, but in the vast majority of cases <code>import</code> statements are
group at the beginning of a script. It is not advised to deviate from this common practice unless
there is a <em>Very Good Reason™</em>.</p>
<p>Especially, do not place an <code>import</code> statement within a loop; doing so will repeatedly re-load the same module
during every iteration of the loop!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mod = &quot;crypto&quot;;

if secured {                    // new block scope
    import mod as c;            // import module (the path needs not be a constant string)

    c::encrypt(key);            // use a function in the module
}                               // the module disappears at the end of the block scope

c::encrypt(others);             // &lt;- this causes a run-time error because the 'crypto' module
                                //    is no longer available!

for x in range(0, 1000) {
    import &quot;crypto&quot; as c;       // &lt;- importing a module inside a loop is a Very Bad Idea™

    c.encrypt(something);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#recursive-imports" id="recursive-imports">Recursive Imports</a></h2>
<p>Beware of <em>import cycles</em> – i.e. recursively loading the same module. This is a sure-fire way to
cause a stack overflow in the <a href="language/modules//book/vnext/engine/hello-world.html"><code>Engine</code></a>, unless stopped by setting a limit for <a href="language/modules//book/vnext/safety/max-modules.html">maximum number of modules</a>.</p>
<p>For instance, importing itself always causes an infinite recursion:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>--------------
| hello.rhai |
--------------

import &quot;hello&quot; as foo;          // import itself - infinite recursion!

foo::do_something();
<span class="boring">}
</span></code></pre></pre>
<p>Modules cross-referencing also cause infinite recursion:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>--------------
| hello.rhai |
--------------

import &quot;world&quot; as foo;
foo::do_something();


--------------
| world.rhai |
--------------

import &quot;hello&quot; as bar;
bar::do_something_else();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#eval-function" id="eval-function"><code>eval</code> Function</a></h1>
<h2><a class="header" href="#or-how-to-shoot-yourself-in-the-foot-even-easier" id="or-how-to-shoot-yourself-in-the-foot-even-easier">Or “How to Shoot Yourself in the Foot even Easier”</a></h2>
<p>Saving the best for last, there is the ever-dreaded... <code>eval</code> function!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 10;

fn foo(x) { x += 12; x }

let script = &quot;let y = x;&quot;;      // build a script
script +=    &quot;y += foo(y);&quot;;
script +=    &quot;x + y&quot;;

let result = eval(script);      // &lt;- look, JavaScript, we can also do this!

result == 42;

x == 10;                        // prints 10: functions call arguments are passed by value
y == 32;                        // prints 32: variables defined in 'eval' persist!

eval(&quot;{ let z = y }&quot;);          // to keep a variable local, use a statement block

print(z);                       // &lt;- error: variable 'z' not found

&quot;print(42)&quot;.eval();             // &lt;- nope... method-call style doesn't work with 'eval'
<span class="boring">}
</span></code></pre></pre>
<p>Script segments passed to <code>eval</code> execute inside the current <a href="language//book/vnext/engine/scope.html"><code>Scope</code></a>, so they can access and modify <em>everything</em>,
including all variables that are visible at that position in code! It is almost as if the script segments were
physically pasted in at the position of the <code>eval</code> call.</p>
<h2><a class="header" href="#cannot-define-new-functions" id="cannot-define-new-functions">Cannot Define New Functions</a></h2>
<p>New functions cannot be defined within an <code>eval</code> call, since functions can only be defined at the <em>global</em> level,
not inside another function call!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let script = &quot;x += 32&quot;;
let x = 10;
eval(script);                   // variable 'x' in the current scope is visible!
print(x);                       // prints 42

// The above is equivalent to:
let script = &quot;x += 32&quot;;
let x = 10;
x += 32;
print(x);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#eval-is-evil" id="eval-is-evil"><code>eval</code> is Evil</a></h2>
<p>For those who subscribe to the (very sensible) motto of <a href="http://linterrors.com/js/eval-is-evil">“<code>eval</code> is evil”</a>,
disable <code>eval</code> using <a href="language//book/vnext/engine/disable.html"><code>Engine::disable_symbol</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.disable_symbol(&quot;eval&quot;);  // disable usage of 'eval'
<span class="boring">}
</span></code></pre></pre>
<p><code>eval</code> can also be disabled by overloading it, probably with something that throws:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn eval(script) { throw &quot;eval is evil! I refuse to run &quot; + script }

let x = eval(&quot;40 + 2&quot;);         // throws &quot;eval is evil! I refuse to run 40 + 2&quot;
<span class="boring">}
</span></code></pre></pre>
<p>Or overload it from Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.register_result_fn(&quot;eval&quot;, |script: String| -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt; {
    Err(format!(&quot;eval is evil! I refuse to run {}&quot;, script).into())
});
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#safety-and-protection-against-dos-attacks" id="safety-and-protection-against-dos-attacks">Safety and Protection Against DoS Attacks</a></h1>
<p>For scripting systems open to untrusted user-land scripts, it is always best to limit the amount of
resources used by a script so that it does not consume more resources that it is allowed to.</p>
<p>The most important resources to watch out for are:</p>
<ul>
<li>
<p><strong>Memory</strong>: A malicious script may continuously grow a <a href="safety//book/vnext/language/strings-chars.html">string</a>, an <a href="safety//book/vnext/language/arrays.html">array</a> or <a href="safety//book/vnext/language/object-maps.html">object map</a> until all memory is consumed.</p>
<p>It may also create a large <a href="safety//book/vnext/language/arrays.html">array</a> or <a href="safety//book/vnext/language/object-maps.html">object map</a> literal that exhausts all memory during parsing.</p>
</li>
<li>
<p><strong>CPU</strong>: A malicious script may run an infinite tight loop that consumes all CPU cycles.</p>
</li>
<li>
<p><strong>Time</strong>: A malicious script may run indefinitely, thereby blocking the calling system which is waiting for a result.</p>
</li>
<li>
<p><strong>Stack</strong>: A malicious script may attempt an infinite recursive call that exhausts the call stack.</p>
<p>Alternatively, it may create a degenerated deep expression with so many levels that the parser exhausts the call stack
when parsing the expression; or even deeply-nested statement blocks, if nested deep enough.</p>
<p>Another way to cause a stack overflow is to load a <a href="safety//book/vnext/language/modules/import.html">self-referencing module</a>.</p>
</li>
<li>
<p><strong>Overflows</strong>: A malicious script may deliberately cause numeric over-flows and/or under-flows, divide by zero, and/or
create bad floating-point representations, in order to crash the system.</p>
</li>
<li>
<p><strong>Files</strong>: A malicious script may continuously <a href="safety//book/vnext/language/modules/import.html"><code>import</code></a> an external module within an infinite loop,
thereby putting heavy load on the file-system (or even the network if the file is not local).</p>
<p>Even when modules are not created from files, they still typically consume a lot of resources to load.</p>
</li>
<li>
<p><strong>Data</strong>: A malicious script may attempt to read from and/or write to data that it does not own. If this happens,
it is a severe security breach and may put the entire system at risk.</p>
</li>
</ul>
<h2><a class="header" href="#unchecked" id="unchecked"><code>unchecked</code></a></h2>
<p>All these safe-guards can be turned off via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature, which disables all
safety checks (even fatal errors such as arithmetic overflows and division-by-zero).</p>
<p>This will increase script evaluation performance, at the expense of having an erroneous
script able to panic the entire system.</p>
<h1><a class="header" href="#checked-arithmetic" id="checked-arithmetic">Checked Arithmetic</a></h1>
<p>By default, all arithmetic calculations in Rhai are <em>checked</em>, meaning that the script terminates
with an error whenever it detects a numeric over-flow/under-flow condition or an invalid
floating-point operation, instead of crashing the entire system.</p>
<p>This checking can be turned off via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance
(but higher risks as well).</p>
<h1><a class="header" href="#sand-boxing--block-access-to-external-data" id="sand-boxing--block-access-to-external-data">Sand-Boxing – Block Access to External Data</a></h1>
<p>Rhai is <em>sand-boxed</em> so a script can never read from outside its own environment.</p>
<p>Furthermore, an <a href="safety//book/vnext/engine/hello-world.html"><code>Engine</code></a> created non-<code>mut</code> cannot mutate any state, including itself
(and therefore it is also <em>re-entrant</em>).</p>
<p>It is highly recommended that <a href="safety//book/vnext/engine/hello-world.html"><code>Engine</code></a>‘s be created immutable as much as possible.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

// Use the fluent API to configure an 'Engine'
engine.register_get(&quot;field&quot;, get_field)
      .register_set(&quot;field&quot;, set_field)
      .register_fn(&quot;do_work&quot;, action);

// Then turn it into an immutable instance
let engine = engine;

// 'engine' is immutable...
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#using-rhai-to-control-external-environment" id="using-rhai-to-control-external-environment">Using Rhai to Control External Environment</a></h2>
<p>How does a <em>sand-boxed</em>, immutable <a href="safety//book/vnext/engine/hello-world.html"><code>Engine</code></a> control the external environment?
This is necessary in order to use Rhai as a <em>dynamic control layer</em> over a Rust core system.</p>
<p>There are two general patterns, both involving wrapping the external system
in a shared, interior-mutated object (e.g. <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>):</p>
<ul>
<li>
<p><a href="safety//book/vnext/patterns/control.html">Control Layer</a> pattern.</p>
</li>
<li>
<p><a href="safety//book/vnext/patterns/singleton.html">Singleton Command Object</a> pattern.</p>
</li>
</ul>
<h1><a class="header" href="#maximum-length-of-strings" id="maximum-length-of-strings">Maximum Length of Strings</a></h1>
<h2><a class="header" href="#limit-how-long-strings-can-grow" id="limit-how-long-strings-can-grow">Limit How Long Strings Can Grow</a></h2>
<p>Rhai by default does not limit how long a <a href="safety//book/vnext/language/strings-chars.html">string</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_string_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create a string literal longer than the maximum length will terminate with a parse error.</p>
<p>Any script operation that produces a string longer than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_string_size(500);    // allow strings only up to 500 bytes long (in UTF-8 format)

engine.set_max_string_size(0);      // allow unlimited string length
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-length" id="setting-maximum-length">Setting Maximum Length</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
a string’s length without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for strings concatenates two strings together to form one longer string;
if both strings are <em>slightly</em> below the maximum length limit, the resultant string may be almost <em>twice</em> the maximum length.</p>
<h1><a class="header" href="#maximum-size-of-arrays" id="maximum-size-of-arrays">Maximum Size of Arrays</a></h1>
<h2><a class="header" href="#limit-how-large-arrays-can-grow" id="limit-how-large-arrays-can-grow">Limit How Large Arrays Can Grow</a></h2>
<p>Rhai by default does not limit how large an <a href="safety//book/vnext/language/arrays.html">array</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_array_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create an array literal larger than the maximum will terminate with a parse error.</p>
<p>Any script operation that produces an array larger than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_array_size(500); // allow arrays only up to 500 items

engine.set_max_array_size(0);   // allow unlimited arrays
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-size" id="setting-maximum-size">Setting Maximum Size</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
an array’s size without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for arrays concatenates two arrays together to form one larger array;
if both arrays are <em>slightly</em> below the maximum size limit, the resultant array may be almost <em>twice</em> the maximum size.</p>
<p>As a malicious script may create a deeply-nested array which consumes huge amounts of memory while each individual
array still stays under the maximum size limit, Rhai also recursively adds up the sizes of all <a href="safety//book/vnext/language/strings-chars.html">strings</a>, <a href="safety//book/vnext/language/arrays.html">arrays</a>
and <a href="safety//book/vnext/language/object-maps.html">object maps</a> contained within each array to make sure that the <em>aggregate</em> sizes of none of these data structures
exceed their respective maximum size limits (if any).</p>
<h1><a class="header" href="#maximum-size-of-object-maps" id="maximum-size-of-object-maps">Maximum Size of Object Maps</a></h1>
<h2><a class="header" href="#limit-how-large-object-maps-can-grow" id="limit-how-large-object-maps-can-grow">Limit How Large Object Maps Can Grow</a></h2>
<p>Rhai by default does not limit how large (i.e. the number of properties) an <a href="safety//book/vnext/language/object-maps.html">object map</a> can be.</p>
<p>This can be changed via the <code>Engine::set_max_map_size</code> method, with zero being unlimited (the default).</p>
<p>A script attempting to create an object map literal with more properties than the maximum will terminate with a parse error.</p>
<p>Any script operation that produces an object map with more properties than the maximum also terminates the script with an error result.</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_map_size(500);   // allow object maps with only up to 500 properties

engine.set_max_map_size(0);     // allow unlimited object maps
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-size-1" id="setting-maximum-size-1">Setting Maximum Size</a></h2>
<p>Be conservative when setting a maximum limit and always consider the fact that a registered function may grow
an object map’s size without Rhai noticing until the very end.</p>
<p>For instance, the built-in ‘<code>+</code>‘ operator for object maps concatenates two object maps together to form one larger object map;
if both object maps are <em>slightly</em> below the maximum size limit, the resultant object map may be almost <em>twice</em> the maximum size.</p>
<p>As a malicious script may create a deeply-nested object map which consumes huge amounts of memory while each individual
object map still stays under the maximum size limit, Rhai also recursively adds up the sizes of all <a href="safety//book/vnext/language/strings-chars.html">strings</a>, <a href="safety//book/vnext/language/arrays.html">arrays</a>
and <a href="safety//book/vnext/language/object-maps.html">object maps</a> contained within each object map to make sure that the <em>aggregate</em> sizes of none of these data structures
exceed their respective maximum size limits (if any).</p>
<h1><a class="header" href="#maximum-number-of-operations" id="maximum-number-of-operations">Maximum Number of Operations</a></h1>
<h2><a class="header" href="#limit-how-long-a-script-can-run" id="limit-how-long-a-script-can-run">Limit How Long a Script Can Run</a></h2>
<p>Rhai by default does not limit how much time or CPU a script consumes.</p>
<p>This can be changed via the <code>Engine::set_max_operations</code> method, with zero being unlimited (the default).</p>
<p>The <em>operations count</em> is intended to be a very course-grained measurement of the amount of CPU that a script
has consumed, allowing the system to impose a hard upper limit on computing resources.</p>
<p>A script exceeding the maximum operations count terminates with an error result.
This can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_operations(500); // allow only up to 500 operations for this script

engine.set_max_operations(0);   // allow unlimited operations
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#what-does-one-operation-mean" id="what-does-one-operation-mean">What Does One <em>Operation</em> Mean</a></h2>
<p>The concept of one single <em>operation</em> in Rhai is volatile – it roughly equals one expression node,
loading one variable/constant, one operator call, one iteration of a loop, or one function call etc.
with sub-expressions, statements and function calls executed inside these contexts accumulated on top.</p>
<p>A good rule-of-thumb is that one simple non-trivial expression consumes on average 5-10 operations.</p>
<p>One <em>operation</em> can take an unspecified amount of time and real CPU cycles, depending on the particulars.
For example, loading a constant consumes very few CPU cycles, while calling an external Rust function,
though also counted as only one operation, may consume much more computing resources.</p>
<p>To help visualize, think of an <em>operation</em> as roughly equals to one <em>instruction</em> of a hypothetical CPU
which includes <em>specialized</em> instructions, such as <em>function call</em>, <em>load module</em> etc., each taking up
one CPU cycle to execute.</p>
<h1><a class="header" href="#track-progress-and-force-termination" id="track-progress-and-force-termination">Track Progress and Force-Termination</a></h1>
<p>It is impossible to know when, or even whether, a script run will end
(a.k.a. the <a href="http://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>).</p>
<p>When dealing with third-party untrusted scripts that may be malicious, to track evaluation progress and
to force-terminate a script prematurely (for any reason), provide a closure to the <a href="safety//book/vnext/engine/hello-world.html"><code>Engine</code></a> via
the <code>Engine::on_progress</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.on_progress(|count| {    // parameter is number of operations already performed
    if count % 1000 == 0 {
        println!(&quot;{}&quot;, count);  // print out a progress log every 1,000 operations
    }
    None                        // return 'None' to continue running the script
                                // return 'Some(token)' to immediately terminate the script
});
<span class="boring">}
</span></code></pre></pre>
<p>The closure passed to <code>Engine::on_progress</code> will be called once for every operation.
Return <code>Some(token)</code> to terminate the script immediately, with the provided value
(any <a href="safety//book/vnext/language/dynamic.html"><code>Dynamic</code></a>) acting as a termination token.</p>
<h2><a class="header" href="#termination-token" id="termination-token">Termination Token</a></h2>
<p>The <a href="safety//book/vnext/language/dynamic.html"><code>Dynamic</code></a> value returned by the closure for <code>Engine::on_progress</code> is a <em>termination token</em>.
A script that is manually terminated returns with <code>Err(EvalAltResult::ErrorTerminated)</code>
wrapping this value.</p>
<p>The termination token is commonly used to provide information on the <em>reason</em> or <em>source</em>
behind the termination decision.</p>
<p>If the termination token is not needed, simply return <code>Some(Dynamic::UNIT)</code> to terminate the script
run with <a href="safety//book/vnext/language/values-and-types.html"><code>()</code></a> as the token.</p>
<h2><a class="header" href="#operations-count-vs-progress-percentage" id="operations-count-vs-progress-percentage">Operations Count vs. Progress Percentage</a></h2>
<p>Notice that the <em>operations count</em> value passed into the closure does not indicate the <em>percentage</em> of work
already done by the script (and thus it is not real <em>progress</em> tracking), because it is impossible to determine
how long a script may run.</p>
<p>It is possible, however, to calculate this percentage based on an estimated total number of operations
for a typical run.</p>
<h1><a class="header" href="#maximum-number-of-modules" id="maximum-number-of-modules">Maximum Number of Modules</a></h1>
<p>Rhai by default does not limit how many <a href="safety//book/vnext/rust/modules/index.html">modules</a> can be loaded via <a href="safety//book/vnext/language/modules/import.html"><code>import</code></a> statements.</p>
<p>This can be changed via the <code>Engine::set_max_modules</code> method. Notice that setting the maximum number
of modules to zero does <em>not</em> indicate unlimited modules, but disallows loading any module altogether.</p>
<p>A script attempting to load more than the maximum number of modules will terminate with an error result.</p>
<p>This limit can also be used to stop <a href="safety//book/vnext/language/modules/import.html"><code>import</code>-loops</a> (i.e. cycles of modules referring to each other).</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance
(but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_modules(5);      // allow loading only up to 5 modules

engine.set_max_modules(0);      // disallow loading any module (maximum = zero)

engine.set_max_modules(1000);   // set to a large number for effectively unlimited modules
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#maximum-call-stack-depth" id="maximum-call-stack-depth">Maximum Call Stack Depth</a></h1>
<h2><a class="header" href="#limit-how-stack-usage-by-scripts" id="limit-how-stack-usage-by-scripts">Limit How Stack Usage by Scripts</a></h2>
<p>Rhai by default limits function calls to a maximum depth of 128 levels (8 levels in debug build).</p>
<p>This limit may be changed via the <code>Engine::set_max_call_levels</code> method.</p>
<p>A script exceeding the maximum call stack depth will terminate with an error result.</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_call_levels(10);     // allow only up to 10 levels of function calls

engine.set_max_call_levels(0);      // allow no function calls at all (max depth = zero)
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#setting-maximum-stack-depth" id="setting-maximum-stack-depth">Setting Maximum Stack Depth</a></h2>
<p>When setting this limit, care must be also taken to the evaluation depth of each <em>statement</em>
within a function. It is entirely possible for a malicious script to embed a recursive call deep
inside a nested expression or statement block (see <a href="safety//book/vnext/safety/max-stmt-depth.html">maximum statement depth</a>).</p>
<h1><a class="header" href="#maximum-statement-depth" id="maximum-statement-depth">Maximum Statement Depth</a></h1>
<h2><a class="header" href="#limit-how-deeply-nested-a-statement-can-be" id="limit-how-deeply-nested-a-statement-can-be">Limit How Deeply-Nested a Statement Can Be</a></h2>
<p>Rhai by default limits statements and expressions nesting to a maximum depth of 128
(which should be plenty) when they are at <em>global</em> level, but only a depth of 32
when they are within function bodies.</p>
<p>For debug builds, these limits are set further downwards to 32 and 16 respectively.</p>
<p>That is because it is possible to overflow the <a href="safety//book/vnext/engine/hello-world.html"><code>Engine</code></a>‘s stack when it tries to
recursively parse an extremely deeply-nested code stream.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following, if long enough, can easily cause stack overflow during parsing.
let a = (1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(...)+1)))))))))));
<span class="boring">}
</span></code></pre></pre>
<p>This limit may be changed via the <code>Engine::set_max_expr_depths</code> method.</p>
<p>There are two limits to set, one for the maximum depth at global level, and the other for function bodies.</p>
<p>A script exceeding the maximum nesting depths will terminate with a parsing error.
The malicious <a href="safety//book/vnext/engine/compile.html"><code>AST</code></a> will not be able to get past parsing in the first place.</p>
<p>This check can be disabled via the <a href="safety//book/vnext/start/features.html"><code>unchecked</code></a> feature for higher performance (but higher risks as well).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

engine.set_max_expr_depths(50, 5);  // allow nesting up to 50 layers of expressions/statements
                                    // at global level, but only 5 inside functions
<span class="boring">}
</span></code></pre></pre>
<p>Beware that there may be multiple layers for a simple language construct, even though it may correspond
to only one AST node. That is because the Rhai <em>parser</em> internally runs a recursive chain of function calls
and it is important that a malicious script does not panic the parser in the first place.</p>
<h2><a class="header" href="#beware-of-recursion" id="beware-of-recursion">Beware of Recursion</a></h2>
<p><em>Functions</em> are placed under stricter limits because of the multiplicative effect of <em>recursion</em>.</p>
<p>A script can effectively call itself while deep inside an expression chain within the function body,
thereby overflowing the stack even when the level of recursion is within limit.</p>
<p>In general, make sure that <code>C x ( 5 + F ) + S</code> layered calls do not cause a stack overflow, where:</p>
<ul>
<li><code>C</code> = maximum call stack depth,</li>
<li><code>F</code> = maximum statement depth for functions,</li>
<li><code>S</code> = maximum statement depth at global level.</li>
</ul>
<h1><a class="header" href="#script-optimization" id="script-optimization">Script Optimization</a></h1>
<p>Rhai includes an <em>optimizer</em> that tries to optimize a script after parsing.
This can reduce resource utilization and increase execution speed.</p>
<p>Script optimization can be turned off via the <a href="engine/optimize//book/vnext/start/features.html"><code>no_optimize</code></a> feature.</p>
<h2><a class="header" href="#dead-code-removal" id="dead-code-removal">Dead Code Removal</a></h2>
<p>For example, in the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 999;            // NOT eliminated: variable may be used later on (perhaps even an 'eval')
    123;                    // eliminated: no effect
    &quot;hello&quot;;                // eliminated: no effect
    [1, 2, x, x*2, 5];      // eliminated: no effect
    foo(42);                // NOT eliminated: the function 'foo' may have side-effects
    666                     // NOT eliminated: this is the return value of the block,
                            // and the block is the last one so this is the return value of the whole script
}
<span class="boring">}
</span></code></pre></pre>
<p>Rhai attempts to eliminate <em>dead code</em> (i.e. code that does nothing, for example an expression by itself as a statement,
which is allowed in Rhai).</p>
<p>The above script optimizes to:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>{
    let x = 999;
    foo(42);
    666
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#constants-propagation" id="constants-propagation">Constants Propagation</a></h2>
<p>Constants propagation is used to remove dead code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const ABC = true;

if ABC || some_work() { print(&quot;done!&quot;); }   // 'ABC' is constant so it is replaced by 'true'...

if true || some_work() { print(&quot;done!&quot;); }  // since '||' short-circuits, 'some_work' is never called

if true { print(&quot;done!&quot;); }                 // &lt;- the line above is equivalent to this

print(&quot;done!&quot;);                             // &lt;- the line above is further simplified to this
                                            //    because the condition is always true
<span class="boring">}
</span></code></pre></pre>
<p>These are quite effective for template-based machine-generated scripts where certain constant values
are spliced into the script text in order to turn on/off certain sections.</p>
<p>For fixed script texts, the constant values can be provided in a user-defined <a href="engine/optimize//book/vnext/engine/scope.html"><code>Scope</code></a> object
to the <a href="engine/optimize//book/vnext/engine/hello-world.html"><code>Engine</code></a> for use in compilation and evaluation.</p>
<h3><a class="header" href="#caveat" id="caveat">Caveat</a></h3>
<p>If the <a href="engine/optimize//book/vnext/language/constants.html">constants</a> are modified later on (yes, it is possible, via Rust functions),
the modified values will not show up in the optimized script.
Only the initialization values of <a href="engine/optimize//book/vnext/language/constants.html">constants</a> are ever retained.</p>
<p>This is almost never a problem because real-world scripts seldom modify a constant,
but the possibility is always there.</p>
<h2><a class="header" href="#eager-operator-evaluations" id="eager-operator-evaluations">Eager Operator Evaluations</a></h2>
<p>Beware, however, that most operators are actually function calls, and those functions can be overridden,
so whether they are optimized away depends on the situation:</p>
<ul>
<li>
<p>If the operands are not <em>constant</em> values, it is not optimized.</p>
</li>
<li>
<p>If the operator is <a href="engine/optimize//book/vnext/rust/operators.html">overloaded</a>, it is not optimized because the overloading function may not be <em>pure</em>
(i.e. may cause side-effects when called).</p>
</li>
<li>
<p>If the operator is not <em>binary</em>, it is not optimized. Only binary operators are built-in to Rhai.</p>
</li>
<li>
<p>If the operands are not of the same type, it is not optimized.</p>
</li>
<li>
<p>If the operator is not <em>built-in</em> (see list of <a href="engine/optimize//book/vnext/engine/raw.html#built-in-operators">built-in operators</a>), it is not optimized.</p>
</li>
<li>
<p>If the operator is a binary built-in operator for a <a href="engine/optimize//book/vnext/language/values-and-types.html">standard type</a>, it is called and replaced by a constant result.</p>
</li>
</ul>
<p>Rhai guarantees that no external function will be run (in order not to trigger side-effects) during the
optimization process (unless the optimization level is set to <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following is most likely generated by machine.

const DECISION = 1;             // this is an integer, one of the standard types

if DECISION == 1 {              // this is optimized into 'true'
    :
} else if DECISION == 2 {       // this is optimized into 'false'
    :
} else if DECISION == 3 {       // this is optimized into 'false'
    :
} else {
    :
}
<span class="boring">}
</span></code></pre></pre>
<p>Because of the eager evaluation of operators for <a href="engine/optimize//book/vnext/language/values-and-types.html">standard types</a>, many constant expressions will be evaluated
and replaced by the result.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = (1+2) * 3-4 / 5%6;      // will be replaced by 'let x = 9'

let y = (1 &gt; 2) || (3 &lt; =4);    // will be replaced by 'let y = true'
<span class="boring">}
</span></code></pre></pre>
<p>For operators that are not optimized away due to one of the above reasons, the function calls
are simply left behind:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assume 'new_state' returns some custom type that is NOT one of the standard types.
// Also assume that the '==; operator is defined for that custom type.
const DECISION_1 = new_state(1);
const DECISION_2 = new_state(2);
const DECISION_3 = new_state(3);

if DECISION == 1 {              // NOT optimized away because the operator is not built-in
    :                           // and may cause side-effects if called!
    :
} else if DECISION == 2 {       // same here, NOT optimized away
    :
} else if DECISION == 3 {       // same here, NOT optimized away
    :
} else {
    :
}
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, turn the optimizer to <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>.</p>
<h1><a class="header" href="#optimization-levels" id="optimization-levels">Optimization Levels</a></h1>
<p>There are three levels of optimization: <code>None</code>, <code>Simple</code> and <code>Full</code>.</p>
<ul>
<li>
<p><code>None</code> is obvious – no optimization on the AST is performed.</p>
</li>
<li>
<p><code>Simple</code> (default) performs only relatively <em>safe</em> optimizations without causing side-effects
(i.e. it only relies on static analysis and <a href="engine/optimize//book/vnext/engine/raw.html#built-in-operators">built-in operators</a> for constant <a href="engine/optimize//book/vnext/language/values-and-types.html">standard types</a>,
and will not perform any external function calls).</p>
<p>However, it is important to bear in mind that <em>constants propagation</em> is performed with the
caveat that, if <a href="engine/optimize//book/vnext/language/constants.html">constants</a> are modified later on (yes, it is possible, via Rust functions),
the modified values will not show up in the optimized script.  Only the initialization values
of <a href="engine/optimize//book/vnext/language/constants.html">constants</a> are ever retained.</p>
<p>Furthermore, overriding a <a href="engine/optimize//book/vnext/engine/raw.html#built-in-operators">built-in operator</a> in the <a href="engine/optimize//book/vnext/engine/hello-world.html"><code>Engine</code></a> afterwards
has no effect after the optimizer replaces an expression with its calculated value.</p>
</li>
<li>
<p><code>Full</code> is <em>much</em> more aggressive, <em>including</em> calling external functions on constant arguments to determine their result.
One benefit to this is that many more optimization opportunities arise, especially with regards to comparison operators.</p>
</li>
</ul>
<h2><a class="header" href="#set-optimization-level" id="set-optimization-level">Set Optimization Level</a></h2>
<p>An <a href="engine/optimize//book/vnext/engine/hello-world.html"><code>Engine</code></a>‘s optimization level is set via a call to <code>Engine::set_optimization_level</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Turn on aggressive optimizations
engine.set_optimization_level(rhai::OptimizationLevel::Full);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#re-optimize-an-ast" id="re-optimize-an-ast">Re-Optimize an AST</a></h1>
<p>Sometimes it is more efficient to store one single, large script with delimited code blocks guarded by
constant variables.  This script is compiled once to an <a href="engine/optimize//book/vnext/engine/compile.html"><code>AST</code></a>.</p>
<p>Then, depending on the execution environment, constants are passed into the <a href="engine/optimize//book/vnext/engine/hello-world.html"><code>Engine</code></a> and the <a href="engine/optimize//book/vnext/engine/compile.html"><code>AST</code></a>
is <em>re</em>-optimized based on those constants via the <code>Engine::optimize_ast</code> method,
effectively pruning out unused code sections.</p>
<p>The final, optimized <a href="engine/optimize//book/vnext/engine/compile.html"><code>AST</code></a> is then used for evaluations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile master script to AST
let master_ast = engine.compile(
r&quot;
    if SCENARIO == 1 {
        do_work();
    } else if SCENARIO == 2 {
        do_something();
    } else if SCENARIO == 3 {
        do_something_else();
    } else {
        do_nothing();
    }
&quot;)?;

// Create a new 'Scope' - put constants in it to aid optimization
let mut scope = Scope::new();
scope.push_constant(&quot;SCENARIO&quot;, 1_i64);

// Re-optimize the AST
let new_ast = engine.optimize_ast(&amp;scope, master_ast.clone(), OptimizationLevel::Simple);

// 'new_ast' is essentially: 'do_work()'
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#eager-function-evaluation-when-using-full-optimization-level" id="eager-function-evaluation-when-using-full-optimization-level">Eager Function Evaluation When Using Full Optimization Level</a></h1>
<p>When the optimization level is <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>, the <a href="engine/optimize//book/vnext/engine/hello-world.html"><code>Engine</code></a> assumes all functions to be <em>pure</em>
and will <em>eagerly</em> evaluated all function calls with constant arguments, using the result to replace the call.</p>
<p>This also applies to all operators (which are implemented as functions).</p>
<p>For instance, the same example above:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When compiling the following with OptimizationLevel::Full...

const DECISION = 1;
                            // this condition is now eliminated because 'sign(DECISION) &gt; 0'
if DECISION.sign() &gt; 0 {    // is a call to the 'sign' and '&gt;' functions, and they return 'true'
    print(&quot;hello!&quot;);        // this block is promoted to the parent level
} else {
    print(&quot;boo!&quot;);          // this block is eliminated because it is never reached
}

print(&quot;hello!&quot;);            // &lt;- the above is equivalent to this
                            //    ('print' and 'debug' are handled specially)
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#side-effect-considerations-for-full-optimization-level" id="side-effect-considerations-for-full-optimization-level">Side-Effect Considerations for Full Optimization Level</a></h1>
<p>All of Rhai’s built-in functions (and operators which are implemented as functions) are <em>pure</em>
(i.e. they do not mutate state nor cause any side-effects, with the exception of <code>print</code> and <code>debug</code>
which are handled specially) so using <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a> is usually quite safe <em>unless</em>
custom types and functions are registered.</p>
<p>If custom functions are registered, they <em>may</em> be called (or maybe not, if the calls happen to lie
within a pruned code block).</p>
<p>If custom functions are registered to overload built-in operators, they will also be called when
the operators are used (in an <code>if</code> statement, for example) causing side-effects.</p>
<p>Therefore, the rule-of-thumb is:</p>
<ul>
<li>
<p><em>Always</em> register custom types and functions <em>after</em> compiling scripts if <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a> is used.</p>
</li>
<li>
<p><em>DO NOT</em> depend on knowledge that the functions have no side-effects, because those functions can change later on and,
when that happens, existing scripts may break in subtle ways.</p>
</li>
</ul>
<h1><a class="header" href="#volatility-considerations-for-full-optimization-level" id="volatility-considerations-for-full-optimization-level">Volatility Considerations for Full Optimization Level</a></h1>
<p>Even if a custom function does not mutate state nor cause side-effects, it may still be <em>volatile</em>,
i.e. it <em>depends</em> on the external environment and is not <em>pure</em>.</p>
<p>A perfect example is a function that gets the current time – obviously each run will return a different value!</p>
<p>The optimizer, when using <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a>, will <em>merrily assume</em> that all functions are <em>pure</em>,
so when it finds constant arguments (or none) it eagerly executes the function call and replaces it with the result.</p>
<p>This causes the script to behave differently from the intended semantics.</p>
<p>Therefore, <strong>avoid using <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::Full</code></a></strong> if non-<em>pure</em> custom types and/or functions are involved.</p>
<h1><a class="header" href="#subtle-semantic-changes-after-optimization" id="subtle-semantic-changes-after-optimization">Subtle Semantic Changes After Optimization</a></h1>
<p>Some optimizations can alter subtle semantics of the script.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if true {           // condition always true
    123.456;        // eliminated
    hello;          // eliminated, EVEN THOUGH the variable doesn't exist!
    foo(42)         // promoted up-level
}

foo(42)             // &lt;- the above optimizes to this
<span class="boring">}
</span></code></pre></pre>
<p>If the original script were evaluated instead, it would have been an error – the variable <code>hello</code> does not exist,
so the script would have been terminated at that point with an error return.</p>
<p>In fact, any errors inside a statement that has been eliminated will silently <em>disappear</em>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print(&quot;start!&quot;);
if my_decision { /* do nothing... */ }  // eliminated due to no effect
print(&quot;end!&quot;);

// The above optimizes to:

print(&quot;start!&quot;);
print(&quot;end!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In the script above, if <code>my_decision</code> holds anything other than a boolean value,
the script should have been terminated due to a type error.</p>
<p>However, after optimization, the entire <code>if</code> statement is removed (because an access to <code>my_decision</code> produces
no side-effects), thus the script silently runs to completion without errors.</p>
<p>It is usually a <em>Very Bad Idea™</em> to depend on a script failing or such kind of subtleties, but if it turns out to be necessary
(why? I would never guess), turn script optimization off by setting the optimization level to <a href="engine/optimize//book/vnext/engine/optimize/optimize-levels.html"><code>OptimizationLevel::None</code></a>.</p>
<h1><a class="header" href="#usage-patterns-1" id="usage-patterns-1">Usage Patterns</a></h1>
<p>Leverage the full power and flexibility of Rhai in different scenarios.</p>
<h1><a class="header" href="#object-oriented-programming-oop" id="object-oriented-programming-oop">Object-Oriented Programming (OOP)</a></h1>
<p>Rhai does not have <em>objects</em> per se, but it is possible to <em>simulate</em> object-oriented programming.</p>
<h2><a class="header" href="#use-object-maps-to-simulate-oop" id="use-object-maps-to-simulate-oop">Use Object Maps to Simulate OOP</a></h2>
<p>Rhai’s <a href="patterns//book/vnext/language/object-maps.html">object maps</a> has <a href="patterns//book/vnext/language/object-maps-oop.html">special support for OOP</a>.</p>
<table><thead><tr><th>Rhai concept</th><th align="center">Maps to OOP</th></tr></thead><tbody>
<tr><td><a href="patterns//book/vnext/language/object-maps.html">Object maps</a></td><td align="center">objects</td></tr>
<tr><td><a href="patterns//book/vnext/language/object-maps.html">Object map</a> properties holding values</td><td align="center">properties</td></tr>
<tr><td><a href="patterns//book/vnext/language/object-maps.html">Object map</a> properties that hold <a href="patterns//book/vnext/language/fn-ptr.html">function pointers</a></td><td align="center">methods</td></tr>
</tbody></table>
<p>When a property of an <a href="patterns//book/vnext/language/object-maps.html">object map</a> is called like a method function, and if it happens to hold
a valid <a href="patterns//book/vnext/language/fn-ptr.html">function pointer</a> (perhaps defined via an <a href="patterns//book/vnext/language/fn-anon.html">anonymous function</a> or more commonly as a <a href="patterns//book/vnext/language/fn-closure.html">closure</a>),
then the call will be dispatched to the actual function with <code>this</code> binding to the <a href="patterns//book/vnext/language/object-maps.html">object map</a> itself.</p>
<h2><a class="header" href="#use-closures-to-define-methods" id="use-closures-to-define-methods">Use Closures to Define Methods</a></h2>
<p><a href="patterns//book/vnext/language/fn-anon.html">Anonymous functions</a> or <a href="patterns//book/vnext/language/fn-closure.html">closures</a> defined as values for <a href="patterns//book/vnext/language/object-maps.html">object map</a> properties take on
a syntactic shape which resembles very closely that of class methods in an OOP language.</p>
<p>Closures also <em><a href="patterns//book/vnext/language/fn-closure.html">capture</a></em> variables from the defining environment, which is a very
common language feature.  Capturing is accomplished via a feature called <em><a href="patterns//book/vnext/language/fn-closure.html">automatic currying</a></em> and
can be turned off via the <a href="patterns//book/vnext/start/features.html"><code>no_closure</code></a> feature.</p>
<h2><a class="header" href="#examples-12" id="examples-12">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let factor = 1;

// Define the object
let obj = #{
        data: 0,                             // object field
        increment: |x| this.data += x,       // 'this' binds to 'obj'
        update: |x| this.data = x * factor,  // 'this' binds to 'obj', 'factor' is captured
        action: || print(this.data)          // 'this' binds to 'obj'
    };

// Use the object
obj.increment(1);
obj.action();                                // prints 1

obj.update(42);
obj.action();                                // prints 42

factor = 2;

obj.update(42);
obj.action();                                // prints 84
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#simulating-inheritance-with-mixin" id="simulating-inheritance-with-mixin">Simulating Inheritance With Mixin</a></h2>
<p>The <code>fill_with</code> method of <a href="patterns//book/vnext/language/object-maps.html">object maps</a> can be conveniently used to <em>polyfill</em> default
method implementations from a <em>base class</em>, as per OOP lingo.</p>
<p>Do not use the <code>mixin</code> method because it <em>overwrites</em> existing fields.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define base class
let BaseClass = #{
    factor: 1,
    data: 42,

    get_data: || this.data * 2,
    update: |x| this.data += x * this.factor
};

let obj = #{
    // Override base class field
    factor: 100,

    // Override base class method
    // Notice that the base class can also be accessed, if in scope
    get_data: || this.call(BaseClass.get_data) * 999,
}

// Polyfill missing fields/methods
obj.fill_with(BaseClass);

// By this point, 'obj' has the following:
//
// #{
//      factor: 100
//      data: 42,
//      get_data: || this.call(BaseClass.get_data) * 999,
//      update: |x| this.data += x * this.factor
// }

// obj.get_data() =&gt; (this.data (42) * 2) * 999
obj.get_data() == 83916;

obj.update(1);

obj.data == 142
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#working-with-rust-enums" id="working-with-rust-enums">Working With Rust Enums</a></h1>
<p>Enums in Rust are typically used with <em>pattern matching</em>.  Rhai is dynamic, so although
it integrates with Rust enum variants just fine (treated transparently as <a href="patterns//book/vnext/rust/custom.html">custom types</a>),
it is impossible (short of registering a complete API) to distinguish between individual
enum variants or to extract internal data from them.</p>
<h2><a class="header" href="#simulate-an-enum-api" id="simulate-an-enum-api">Simulate an Enum API</a></h2>
<p>A <a href="patterns//book/vnext/plugins/module.html">plugin module</a> is extremely handy in creating an entire API for a custom enum type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Dynamic, EvalAltResult};
use rhai::plugin::*;

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
enum MyEnum {
    Foo,
    Bar(i64),
    Baz(String, bool)
}

// Create a plugin module with functions constructing the 'MyEnum' variants
#[export_module]
mod MyEnumModule {
    // Constructors for 'MyEnum' variants
    pub const Foo: &amp;MyEnum = MyEnum::Foo;
    pub fn Bar(value: i64) -&gt; MyEnum {
        MyEnum::Bar(value)
    }
    pub fn Baz(val1: String, val2: bool) -&gt; MyEnum {
        MyEnum::Baz(val1, val2)
    }
    // Access to fields
    #[rhai_fn(get = &quot;enum_type&quot;)]
    pub fn get_type(a: &amp;mut MyEnum) -&gt; String {
        match a {
            MyEnum::Foo =&gt; &quot;Foo&quot;.to_string(),
            MyEnum::Bar(_) =&gt; &quot;Bar&quot;.to_string(),
            MyEnum::Baz(_, _) =&gt; &quot;Baz&quot;.to_string()
        }
    }
    #[rhai_fn(get = &quot;field_0&quot;)]
    pub fn get_field_0(a: &amp;mut MyEnum) -&gt; Dynamic {
        match a {
            MyEnum::Foo =&gt; Dynamic::UNIT,
            MyEnum::Bar(x) =&gt; Dynamic::from(x),
            MyEnum::Baz(x, _) =&gt; Dynamic::from(x)
        }
    }
    #[rhai_fn(get = &quot;field_1&quot;)]
    pub fn get_field_1(a: &amp;mut MyEnum) -&gt; Dynamic {
        match a {
            MyEnum::Foo | MyEnum::Bar(_) =&gt; Dynamic::UNIT,
            MyEnum::Baz(_, x) =&gt; Dynamic::from(x)
        }
    }
    // Printing
    #[rhai(global, name = &quot;to_string&quot;, name = &quot;print&quot;, name = &quot;to_debug&quot;, name = &quot;debug&quot;)]
    pub fn to_string(a: &amp;mut MyEnum) -&gt; String {
        format!(&quot;{:?}&quot;, a))
    }
    #[rhai_fn(global, name = &quot;+&quot;)]
    pub fn add_to_str(s: &amp;str, a: MyEnum) -&gt; String {
        format!(&quot;{}{:?}&quot;, s, a))
    }
    #[rhai_fn(global, name = &quot;+&quot;)]
    pub fn add_str(a: &amp;mut MyEnum, s: &amp;str) -&gt; String {
        format!(&quot;{:?}&quot;, a).push_str(s))
    }
    #[rhai_fn(global, name = &quot;+=&quot;)]
    pub fn append_to_str(s: &amp;mut ImmutableString, a: MyEnum) -&gt; String {
        s += a.to_string())
    }
    // '==' and '!=' operators
    #[rhai_fn(global, name = &quot;==&quot;)]
    pub fn eq(a: &amp;mut MyEnum, b: MyEnum) -&gt; bool {
        a == &amp;b
    }
    #[rhai_fn(global, name = &quot;!=&quot;)]
    pub fn neq(a: &amp;mut MyEnum, b: MyEnum) -&gt; bool {
        a != &amp;b
    }
    // Array functions
    #[rhai_fn(global, name = &quot;push&quot;)]
    pub fn append_to_array(list: &amp;mut Array, item: MyEnum) {
        list.push(Dynamic::from(item)));
    }
    #[rhai_fn(global, name = &quot;+=&quot;)]
    pub fn append_to_array_op(list: &amp;mut Array, item: MyEnum) {
        list.push(Dynamic::from(item)));
    }
    #[rhai_fn(global, name = &quot;insert&quot;)]
    pub fn insert_to_array(list: &amp;mut Array, position: i64, item: MyEnum) {
        if position &lt;= 0 {
            list.insert(0, Dynamic::from(item));
        } else if (position as usize) &gt;= list.len() - 1 {
            list.push(item);
        } else {
            list.insert(position as usize, Dynamic::from(item));
        }
    }
    #[rhai_fn(global, name = &quot;pad&quot;)]
    pub fn pad_array(list: &amp;mut Array, len: i64, item: MyEnum) {
        if len as usize &gt; list.len() { list.resize(len as usize, item); }
    }
}

let mut engine = Engine::new();

// Load the module as the module namespace &quot;MyEnum&quot;
engine
    .register_type_with_name::&lt;MyEnum&gt;(&quot;MyEnum&quot;)
    .register_static_module(&quot;MyEnum&quot;, exported_module!(MyEnumModule).into());
<span class="boring">}
</span></code></pre></pre>
<p>With this API in place, working with enums feels almost the same as in Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = MyEnum::Foo;

let y = MyEnum::Bar(42);

let z = MyEnum::Baz(&quot;hello&quot;, true);

x == MyEnum::Foo;

y != MyEnum::Bar(0);

// Detect enum types

x.enum_type == &quot;Foo&quot;;

y.enum_type == &quot;Bar&quot;;

z.enum_type == &quot;Baz&quot;;

// Extract enum fields

y.field_0 == 42;

y.field_1 == ();

z.field_0 == &quot;hello&quot;;

z.field_1 == true;
<span class="boring">}
</span></code></pre></pre>
<p>Since enums are internally treated as <a href="patterns//book/vnext/rust/custom.html">custom types</a>, they are not <em>literals</em> and cannot be
used as a match case in <code>switch</code> expressions.  This is quite a limitation because the equivalent
<code>match</code> statement is commonly used in Rust to work with enums and bind variables to
variant-internal data.</p>
<p>It is possible, however, to <code>switch</code> through enum variants based on their types:</p>
<pre><code class="language-c">switch x.enum_type {
  &quot;Foo&quot; =&gt; ...,
  &quot;Bar&quot; =&gt; {
    let value = foo.field_0;
    ...
  }
  &quot;Baz&quot; =&gt; {
    let val1 = foo.field_0;
    let val2 = foo.field_1;
    ...
  }
}
</code></pre>
<h2><a class="header" href="#use-switch-through-arrays" id="use-switch-through-arrays">Use <code>switch</code> Through Arrays</a></h2>
<p>Another way to work with Rust enums in a <code>switch</code> expression is through exposing the internal data
(or at least those that act as effective <em>discriminants</em>) of each enum variant as a variable-length
<a href="patterns//book/vnext/language/arrays.html">array</a>, usually with the name of the variant as the first item for convenience:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::Array;

engine.register_get(&quot;enum_data&quot;, |x: &amp;mut Enum| {
    match x {
        Enum::Foo =&gt; vec![ &quot;Foo&quot;.into() ] as Array,

        // Say, skip the data field because it is not
        // used as a discriminant
        Enum::Bar(value) =&gt; vec![ &quot;Bar&quot;.into() ] as Array,

        // Say, all fields act as discriminants
        Enum::Baz(val1, val2) =&gt; vec![
            &quot;Baz&quot;.into(), val1.clone().into(), (*val2).into()
        ] as Array
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Then it is a simple matter to match an enum via the <code>switch</code> expression:</p>
<pre><code class="language-c">// Assume 'value' = 'MyEnum::Baz(&quot;hello&quot;, true)'
// 'enum_data' creates a variable-length array with 'MyEnum' data
let x = switch value.enum_data {
    [&quot;Foo&quot;] =&gt; 1,
    [&quot;Bar&quot;] =&gt; value.field_1,
    [&quot;Baz&quot;, &quot;hello&quot;, false] =&gt; 4,
    [&quot;Baz&quot;, &quot;hello&quot;, true] =&gt; 5,
    _ =&gt; 9
};

x == 5;

// Which is essentially the same as:
let x = switch [value.type, value.field_0, value.field_1] {
    [&quot;Foo&quot;, (), ()] =&gt; 1,
    [&quot;Bar&quot;, 42, ()] =&gt; 42,
    [&quot;Bar&quot;, 123, ()] =&gt; 123,
            :
    [&quot;Baz&quot;, &quot;hello&quot;, false] =&gt; 4,
    [&quot;Baz&quot;, &quot;hello&quot;, true] =&gt; 5,
    _ =&gt; 9
}
</code></pre>
<p>Usually, a helper method returns an array of values that can uniquely determine
the switch case based on actual usage requirements – which means that it probably
skips fields that contain data instead of discriminants.</p>
<p>Then <code>switch</code> is used to very quickly match through a large number of array shapes
and jump to the appropriate case implementation.</p>
<p>Data fields can then be extracted from the enum independently.</p>
<h1><a class="header" href="#loadable-configuration" id="loadable-configuration">Loadable Configuration</a></h1>
<h2><a class="header" href="#usage-scenario" id="usage-scenario">Usage Scenario</a></h2>
<ul>
<li>
<p>A system where settings and configurations are complex and logic-driven.</p>
</li>
<li>
<p>Where said system is too complex to configure via standard configuration file formats such as <code>JSON</code>, <code>TOML</code> or <code>YAML</code>.</p>
</li>
<li>
<p>The system is complex enough to require a full programming language to configure. Essentially <em>configuration by code</em>.</p>
</li>
<li>
<p>Yet the configuration must be flexible, late-bound and dynamically loadable, just like a configuration file.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts" id="key-concepts">Key Concepts</a></h2>
<ul>
<li>
<p>Leverage the loadable <a href="patterns//book/vnext/rust/modules/index.html">modules</a> of Rhai.  The <a href="patterns//book/vnext/start/features.html"><code>no_module</code></a> feature must not be on.</p>
</li>
<li>
<p>Expose the configuration API.  Use separate scripts to configure that API.  Dynamically load scripts via the <code>import</code> statement.</p>
</li>
<li>
<p>Leverage <a href="patterns//book/vnext/rust/functions.html#function-overloading">function overloading</a> to simplify the API design.</p>
</li>
<li>
<p>Since Rhai is <em>sand-boxed</em>, it cannot mutate the environment.  To modify the external configuration object via an API, it must be wrapped in a <code>RefCell</code> (or <code>RwLock</code>/<code>Mutex</code> for <a href="patterns//book/vnext/start/features.html"><code>sync</code></a>) and shared to the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
</li>
</ul>
<h2><a class="header" href="#implementation-1" id="implementation-1">Implementation</a></h2>
<h3><a class="header" href="#configuration-type" id="configuration-type">Configuration Type</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Default)]
struct Config {
    pub id: String;
    pub some_field: i64;
    pub some_list: Vec&lt;String&gt;;
    pub some_map: HashMap&lt;String, bool&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#make-shared-object" id="make-shared-object">Make Shared Object</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type SharedConfig = Rc&lt;RefCell&lt;Config&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Note: Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> when using the <a href="patterns//book/vnext/start/features.html"><code>sync</code></a> feature because the function
must then be <code>Send + Sync</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config: SharedConfig = Rc::new(RefCell::new(Default::default()));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#register-config-api" id="register-config-api">Register Config API</a></h3>
<p>The trick to building a Config API is to clone the shared configuration object and
move it into each function registration via a closure.</p>
<p>Therefore, it is not possible to use a <a href="patterns//book/vnext/plugins/module.html">plugin module</a> to achieve this, and each function must
be registered one after another.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice 'move' is used to move the shared configuration object into the closure.
let cfg = config.clone();
engine.register_fn(&quot;config_set_id&quot;, move |id: String| *cfg.borrow_mut().id = id);

let cfg = config.clone();
engine.register_fn(&quot;config_get_id&quot;, move || cfg.borrow().id.clone());

let cfg = config.clone();
engine.register_fn(&quot;config_set&quot;, move |value: i64| *cfg.borrow_mut().some_field = value);

// Remember Rhai functions can be overloaded when designing the API.

let cfg = config.clone();
engine.register_fn(&quot;config_add&quot;, move |value: String|
    cfg.borrow_mut().some_list.push(value)
);

let cfg = config.clone();
engine.register_fn(&quot;config_add&quot;, move |values: &amp;mut Array|
    cfg.borrow_mut().some_list.extend(values.into_iter().map(|v| v.to_string()))
);

let cfg = config.clone();
engine.register_fn(&quot;config_add&quot;, move |key: String, value: bool|
    cfg.borrow_mut().some_map.insert(key, value)
);

let cfg = config.clone();
engine.register_fn(&quot;config_contains&quot;, move |value: String|
    cfg.borrow().some_list.contains(&amp;value)
);

let cfg = config.clone();
engine.register_fn(&quot;config_is_set&quot;, move |value: String|
    cfg.borrow().some_map.get(&amp;value).cloned().unwrap_or(false)
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#configuration-script" id="configuration-script">Configuration Script</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>------------------
| my_config.rhai |
------------------

config_set_id(&quot;hello&quot;);

config_add(&quot;foo&quot;);          // add to list
config_add(&quot;bar&quot;, true);    // add to map

if config_contains(&quot;hey&quot;) || config_is_set(&quot;hey&quot;) {
    config_add(&quot;baz&quot;, false);   // add to map
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#load-the-configuration" id="load-the-configuration">Load the Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>import &quot;my_config&quot;;         // run configuration script without creating a module

let id = config_get_id();

id == &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#consider-a-custom-syntax" id="consider-a-custom-syntax">Consider a Custom Syntax</a></h2>
<p>This is probably one of the few scenarios where a <a href="patterns//book/vnext/engine/custom-syntax.html">custom syntax</a> can be recommended.</p>
<p>A properly-designed <a href="patterns//book/vnext/engine/custom-syntax.html">custom syntax</a> can make the configuration file clean, simple to write,
easy to understand and quick to modify.</p>
<p>For example, the above configuration example may be expressed by this custom syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>------------------
| my_config.rhai |
------------------

// Configure ID
id &quot;hello&quot;;

// Add to list
list + &quot;foo&quot;;

// Add to map
map &quot;bar&quot; =&gt; true;

if config contains &quot;hey&quot; || config is_set &quot;hey&quot; {
    map &quot;baz&quot; =&gt; false;
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that <code>contains</code> and <code>is_set</code> may be implemented as a <a href="patterns//book/vnext/engine/custom-op.html">custom operator</a>.</p>
<h1><a class="header" href="#scriptable-control-layer" id="scriptable-control-layer">Scriptable Control Layer</a></h1>
<h2><a class="header" href="#usage-scenario-1" id="usage-scenario-1">Usage Scenario</a></h2>
<ul>
<li>
<p>A system provides core functionalities, but no driving logic.</p>
</li>
<li>
<p>The driving logic must be dynamic and hot-loadable.</p>
</li>
<li>
<p>A script is used to drive the system and provide control intelligence.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-1" id="key-concepts-1">Key Concepts</a></h2>
<ul>
<li>
<p>Expose a Control API.</p>
</li>
<li>
<p>Leverage <a href="patterns//book/vnext/rust/functions.html#function-overloading">function overloading</a> to simplify the API design.</p>
</li>
<li>
<p>Since Rhai is <em><a href="patterns//book/vnext/safety/sandbox.html">sand-boxed</a></em>, it cannot mutate the environment.  To perform external actions via an API, the actual system must be wrapped in a <code>RefCell</code> (or <code>RwLock</code>/<code>Mutex</code> for <a href="patterns//book/vnext/start/features.html"><code>sync</code></a>) and shared to the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
</li>
</ul>
<h2><a class="header" href="#implementation-2" id="implementation-2">Implementation</a></h2>
<p>There are two broad ways for Rhai to control an external system, both of which involve
wrapping the system in a shared, interior-mutated object.</p>
<p>This is one way which does not involve exposing the data structures of the external system,
but only through exposing an abstract API primarily made up of functions.</p>
<p>Use this when the API is relatively simple and clean, and the number of functions is small enough.</p>
<p>For a complex API involving lots of functions, or an API that has a clear object structure,
use the <a href="patterns//book/vnext/patterns/singleton.html">Singleton Command Object</a> pattern instead.</p>
<h3><a class="header" href="#functional-api" id="functional-api">Functional API</a></h3>
<p>Assume that a system provides the following functional API:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EnergizerBunny;

impl EnergizerBunny {
    pub fn new () -&gt; Self { ... }
    pub fn go (&amp;mut self) { ... }
    pub fn stop (&amp;mut self) { ... }
    pub fn is_going (&amp;self) { ... }
    pub fn get_speed (&amp;self) -&gt; i64 { ... }
    pub fn set_speed (&amp;mut self, speed: i64) { ... }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#wrap-api-in-shared-object" id="wrap-api-in-shared-object">Wrap API in Shared Object</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type SharedBunny = Rc&lt;RefCell&lt;EnergizerBunny&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Note: Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> when using the <a href="patterns//book/vnext/start/features.html"><code>sync</code></a> feature because the function
must then be <code>Send + Sync</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bunny: SharedBunny = Rc::new(RefCell::(EnergizerBunny::new()));
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#register-control-api" id="register-control-api">Register Control API</a></h3>
<p>The trick to building a Control API is to clone the shared API object and
move it into each function registration via a closure.</p>
<p>Therefore, it is not possible to use a <a href="patterns//book/vnext/plugins/module.html">plugin module</a> to achieve this, and each function must
be registered one after another.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Notice 'move' is used to move the shared API object into the closure.
let b = bunny.clone();
engine.register_fn(&quot;bunny_power&quot;, move |on: bool| {
    if on {
        if b.borrow().is_going() {
            println!(&quot;Still going...&quot;);
        } else {
            b.borrow_mut().go();
        }
    } else {
        if b.borrow().is_going() {
            b.borrow_mut().stop();
        } else {
            println!(&quot;Already out of battery!&quot;);
        }
    }
});

let b = bunny.clone();
engine.register_fn(&quot;bunny_is_going&quot;, move || b.borrow().is_going());

let b = bunny.clone();
engine.register_fn(&quot;bunny_get_speed&quot;, move ||
    if b.borrow().is_going() { b.borrow().get_speed() } else { 0 }
);

let b = bunny.clone();
engine.register_result_fn(&quot;bunny_set_speed&quot;, move |speed: i64|
    if speed &lt;= 0 {
        return Err(&quot;Speed must be positive!&quot;.into());
    } else if speed &gt; 100 {
        return Err(&quot;Bunny will be going too fast!&quot;.into());
    }

    if b.borrow().is_going() {
        b.borrow_mut().set_speed(speed)
    } else {
        return Err(&quot;Bunny is not yet going!&quot;.into());
    }

    Ok(Dynamic::UNIT)
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#use-the-api" id="use-the-api">Use the API</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !bunny_is_going() { bunny_power(true); }

if bunny_get_speed() &gt; 50 { bunny_set_speed(50); }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#caveat-1" id="caveat-1">Caveat</a></h2>
<p>Although this usage pattern appears a perfect fit for <em>game</em> logic, avoid writing the
<em>entire game</em> in Rhai.  Performance will not be acceptable.</p>
<p>Implement as much functionalities of the game engine in Rust as possible.
Rhai integrates well with Rust so this is usually not a hinderance.</p>
<p>Lift as much out of Rhai as possible.
Use Rhai only for the logic that <em>must</em> be dynamic or hot-loadable.</p>
<h1><a class="header" href="#singleton-command-object" id="singleton-command-object">Singleton Command Object</a></h1>
<h2><a class="header" href="#usage-scenario-2" id="usage-scenario-2">Usage Scenario</a></h2>
<ul>
<li>
<p>A system provides core functionalities, but no driving logic.</p>
</li>
<li>
<p>The driving logic must be dynamic and hot-loadable.</p>
</li>
<li>
<p>A script is used to drive the system and provide control intelligence.</p>
</li>
<li>
<p>The API is multiplexed, meaning that it can act on multiple system-provided entities, or</p>
</li>
<li>
<p>The API lends itself readily to an object-oriented (OO) representation.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-2" id="key-concepts-2">Key Concepts</a></h2>
<ul>
<li>
<p>Expose a Command type with an API.  The <a href="patterns//book/vnext/start/features.html"><code>no_object</code></a> feature must not be on.</p>
</li>
<li>
<p>Leverage <a href="patterns//book/vnext/rust/functions.html#function-overloading">function overloading</a> to simplify the API design.</p>
</li>
<li>
<p>Since Rhai is <em><a href="patterns//book/vnext/safety/sandbox.html">sand-boxed</a></em>, it cannot mutate the environment.  To perform external actions via an API, the command object type must be wrapped in a <code>RefCell</code> (or <code>RwLock</code>/<code>Mutex</code> for <a href="patterns//book/vnext/start/features.html"><code>sync</code></a>) and shared to the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
</li>
<li>
<p>Load each command object into a custom <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a> as constant variables.</p>
</li>
<li>
<p>Control each command object in script via the constants.</p>
</li>
</ul>
<h2><a class="header" href="#implementation-3" id="implementation-3">Implementation</a></h2>
<p>There are two broad ways for Rhai to control an external system, both of which involve
wrapping the system in a shared, interior-mutated object.</p>
<p>This is the other way which involves directly exposing the data structures of the external system
as a name singleton object in the scripting space.</p>
<p>Use this when the API is complex but has a clear object structure.</p>
<p>For a relatively simple API that is action-based and not object-based,
use the <a href="patterns//book/vnext/patterns/control.html">Control Layer</a> pattern instead.</p>
<h3><a class="header" href="#functional-api-1" id="functional-api-1">Functional API</a></h3>
<p>Assume the following command object type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EnergizerBunny { ... }

impl EnergizerBunny {
    pub fn new () -&gt; Self { ... }
    pub fn go (&amp;mut self) { ... }
    pub fn stop (&amp;mut self) { ... }
    pub fn is_going (&amp;self) -&gt; bol { ... }
    pub fn get_speed (&amp;self) -&gt; i64 { ... }
    pub fn set_speed (&amp;mut self, speed: i64) { ... }
    pub fn turn (&amp;mut self, left_turn: bool) { ... }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#wrap-command-object-type-as-shared" id="wrap-command-object-type-as-shared">Wrap Command Object Type as Shared</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type SharedBunny = Rc&lt;RefCell&lt;EnergizerBunny&gt;&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Note: Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> or <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> when using the <a href="patterns//book/vnext/start/features.html"><code>sync</code></a> feature because the function
must then be <code>Send + Sync</code>.</p>
<h3><a class="header" href="#register-the-custom-type" id="register-the-custom-type">Register the Custom Type</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.register_type_with_name::&lt;SharedBunny&gt;(&quot;EnergizerBunny&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#develop-a-plugin-with-methods-and-getterssetters" id="develop-a-plugin-with-methods-and-getterssetters">Develop a Plugin with Methods and Getters/Setters</a></h3>
<p>The easiest way to develop a complete set of API for a <a href="patterns//book/vnext/rust/custom.html">custom type</a> is via a <a href="patterns//book/vnext/plugins/module.html">plugin module</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;

#[export_module]
pub mod bunny_api {
    pub const MAX_SPEED: i64 = 100;

    #[rhai_fn(get = &quot;power&quot;)]
    pub fn get_power(bunny: &amp;mut SharedBunny) -&gt; bool {
        bunny.borrow().is_going()
    }
    #[rhai_fn(set = &quot;power&quot;)]
    pub fn set_power(bunny: &amp;mut SharedBunny, on: bool) {
        if on {
            if bunny.borrow().is_going() {
                println!(&quot;Still going...&quot;);
            } else {
                bunny.borrow_mut().go();
            }
        } else {
            if bunny.borrow().is_going() {
                bunny.borrow_mut().stop();
            } else {
                println!(&quot;Already out of battery!&quot;);
            }
        }
    }
    #[rhai_fn(get = &quot;speed&quot;)]
    pub fn get_speed(bunny: &amp;mut SharedBunny) -&gt; i64 {
        if bunny.borrow().is_going() {
            bunny.borrow().get_speed()
        } else {
            0
        }
    }
    #[rhai_fn(set = &quot;speed&quot;, return_raw)]
    pub fn set_speed(bunny: &amp;mut SharedBunny, speed: i64)
            -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;
    {
        if speed &lt;= 0 {
            Err(&quot;Speed must be positive!&quot;.into())
        } else if speed &gt; MAX_SPEED {
            Err(&quot;Bunny will be going too fast!&quot;.into())
        } else if !bunny.borrow().is_going() {
            Err(&quot;Bunny is not yet going!&quot;.into())
        } else {
            b.borrow_mut().set_speed(speed);
            Ok(Dynamic::UNIT)
        }
    }
    pub fn turn_left(bunny: &amp;mut SharedBunny) {
        if bunny.borrow().is_going() {
            bunny.borrow_mut().turn(true);
        }
    }
    pub fn turn_right(bunny: &amp;mut SharedBunny) {
        if bunny.borrow().is_going() {
            bunny.borrow_mut().turn(false);
        }
    }
}

engine.register_global_module(exported_module!(bunny_api).into());
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#push-constant-command-object-into-custom-scope" id="push-constant-command-object-into-custom-scope">Push Constant Command Object into Custom Scope</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bunny: SharedBunny = Rc::new(RefCell::(EnergizerBunny::new()));

let mut scope = Scope::new();

// Add the command object into a custom Scope.
scope.push_constant(&quot;Bunny&quot;, bunny.clone());

engine.consume_with_scope(&amp;mut scope, script)?;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#use-the-command-api-in-script" id="use-the-command-api-in-script">Use the Command API in Script</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access the command object via constant variable 'Bunny'.

if !Bunny.power { Bunny.power = true; }

if Bunny.speed &gt; 50 { Bunny.speed = 50; }

Bunny.turn_left();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#multi-layer-functions" id="multi-layer-functions">Multi-Layer Functions</a></h1>
<h2><a class="header" href="#usage-scenario-3" id="usage-scenario-3">Usage Scenario</a></h2>
<ul>
<li>
<p>A system is divided into separate <em>layers</em>, each providing logic in terms of scripted <a href="patterns//book/vnext/language/functions.html">functions</a>.</p>
</li>
<li>
<p>A lower layer provides <em>default implementations</em> of certain functions.</p>
</li>
<li>
<p>Higher layers each provide progressively more specific implementations of the same functions.</p>
</li>
<li>
<p>A more specific function, if defined in a higher layer, always overrides the implementation in a lower layer.</p>
</li>
<li>
<p>This is akin to object-oriented programming but with functions.</p>
</li>
<li>
<p>This type of system is extremely convenient for dynamic business rules configuration, setting corporate-wide
policies, granting permissions for specific roles etc. where specific, local rules need to override
corporate-wide defaults.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-3" id="key-concepts-3">Key Concepts</a></h2>
<ul>
<li>
<p>Each layer is a separate script.</p>
</li>
<li>
<p>The lowest layer script is compiled into a base <a href="patterns//book/vnext/engine/compile.html"><code>AST</code></a>.</p>
</li>
<li>
<p>Higher layer scripts are also compiled into <a href="patterns//book/vnext/engine/compile.html"><code>AST</code></a> and <em>combined</em> into the base using <code>AST::combine</code>
(or the <code>+=</code> operator), overriding any existing functions.</p>
</li>
</ul>
<h2><a class="header" href="#examples-13" id="examples-13">Examples</a></h2>
<p>Assume the following four scripts:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>----------------
| default.rhai |
----------------

// Default implementation of 'foo'.
fn foo(x) { x + 1 }

// Default implementation of 'bar'.
fn bar(x, y) { x + y }

// Default implementation of 'no_touch'.
fn no_touch() { throw &quot;do not touch me!&quot;; }


---------------
| lowest.rhai |
---------------

// Specific implementation of 'foo'.
fn foo(x) { x * 2 }

// New implementation for this layer.
fn baz() { print(&quot;hello!&quot;); }


---------------
| middle.rhai |
---------------

// Specific implementation of 'bar'.
fn bar(x, y) { x - y }

// Specific implementation of 'baz'.
fn baz() { print(&quot;hey!&quot;); }


----------------
| highest.rhai |
----------------

// Specific implementation of 'foo'.
fn foo(x) { x + 42 }
<span class="boring">}
</span></code></pre></pre>
<p>Load and combine them sequentially:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let engine = Engine::new();

// Compile the baseline default implementations.
let mut ast = engine.compile_file(&quot;default.rhai&quot;.into())?;

// Combine the first layer.
let lowest = engine.compile_file(&quot;lowest.rhai&quot;.into())?;
ast += lowest;

// Combine the second layer.
let middle = engine.compile_file(&quot;middle.rhai&quot;.into())?;
ast += lowest;

// Combine the third layer.
let highest = engine.compile_file(&quot;highest.rhai&quot;.into())?;
ast += lowest;

// Now, 'ast' contains the following functions:
//
// fn no_touch() {              // from 'default.rhai'
//     throw &quot;do not touch me!&quot;;
// }
// fn foo(x) { x + 42 }         // from 'highest.rhai'
// fn bar(x, y) { x - y }       // from 'middle.rhai'
// fn baz() { print(&quot;hey!&quot;); }  // from 'middle.rhai'
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, there is no <code>super</code> call that calls the base implementation
(i.e. no way for a higher-layer function to call an equivalent lower-layer function).</p>
<h1><a class="header" href="#one-engine-instance-per-call" id="one-engine-instance-per-call">One Engine Instance Per Call</a></h1>
<h2><a class="header" href="#usage-scenario-4" id="usage-scenario-4">Usage Scenario</a></h2>
<ul>
<li>
<p>A system where scripts are called a <em>lot</em>, in tight loops or in parallel.</p>
</li>
<li>
<p>Keeping a global <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance is sub-optimal due to contention and locking.</p>
</li>
<li>
<p>Scripts need to be executed independently from each other, perhaps concurrently.</p>
</li>
<li>
<p>Scripts are used to <a href="patterns//book/vnext/engine/func.html">create Rust closure</a> that are stored and may be called at any time, perhaps concurrently.
In this case, the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance is usually moved into the closure itself.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-4" id="key-concepts-4">Key Concepts</a></h2>
<ul>
<li>
<p>Create a single instance of each standard <a href="patterns//book/vnext/rust/packages/index.html">package</a> required.
To duplicate <code>Engine::new</code>, create a <a href="patterns//book/vnext/rust/packages/builtin.html"><code>StandardPackage</code></a>.</p>
</li>
<li>
<p>Gather up all common custom functions into a <a href="patterns//book/vnext/rust/packages/create.html">custom package</a>.</p>
</li>
<li>
<p>Store a global <code>AST</code> for use with all engines.</p>
</li>
<li>
<p>Always use <code>Engine::new_raw</code> to create a <a href="patterns//book/vnext/engine/raw.html">raw <code>Engine</code></a>, instead of <code>Engine::new</code> which is <em>much</em> more expensive.
A <a href="patterns//book/vnext/engine/raw.html">raw <code>Engine</code></a> is <em>extremely</em> cheap to create.</p>
<p>Registering the <a href="patterns//book/vnext/rust/packages/builtin.html"><code>StandardPackage</code></a> into a <a href="patterns//book/vnext/engine/raw.html">raw <code>Engine</code></a> via
<code>Engine::register_global_module</code> is essentially the same as <code>Engine::new</code>.</p>
<p>However, because packages are shared, using existing package is <em>much cheaper</em> than
registering all the functions one by one.</p>
</li>
<li>
<p>Register the required packages with the <a href="patterns//book/vnext/engine/raw.html">raw <code>Engine</code></a> via <code>Engine::register_global_module</code>,
using <code>Package::as_shared_module</code> to obtain a shared <a href="patterns//book/vnext/rust/modules/index.html">module</a>.</p>
</li>
</ul>
<h2><a class="header" href="#examples-14" id="examples-14">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::packages::{Package, StandardPackage};

let ast = /* ... some AST ... */;
let std_pkg = StandardPackage::new();
let custom_pkg = MyCustomPackage::new();

let make_call = |x: i64| -&gt; Result&lt;(), Box&lt;EvalAltResult&gt;&gt; {
    // Create a raw Engine - extremely cheap
    let mut engine = Engine::new_raw();

    // Register packages as global modules - cheap
    engine.register_global_module(std_pkg.as_shared_module());
    engine.register_global_module(custom_pkg.as_shared_module());

    // Create custom scope - cheap
    let mut scope = Scope::new();

    // Push variable into scope - relatively cheap
    scope.push(&quot;x&quot;, x);

    // Evaluate script.
    engine.consume_ast_with_scope(&amp;mut scope, &amp;ast)
};

// The following loop creates 10,000 Engine instances!
for x in 0..10_000 {
    make_call(x)?;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#multi-threaded-synchronization" id="multi-threaded-synchronization">Multi-Threaded Synchronization</a></h1>
<h2><a class="header" href="#usage-scenarios" id="usage-scenarios">Usage Scenarios</a></h2>
<ul>
<li>
<p>A system needs to communicate with an <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> running in a separate thread.</p>
</li>
<li>
<p>Multiple <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a>s running in separate threads need to coordinate/synchronize with each other.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-5" id="key-concepts-5">Key Concepts</a></h2>
<ul>
<li>
<p>An MPSC channel (or any other appropriate synchronization primitive) is used to send/receive
messages to/from an <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> running in a separate thread.</p>
</li>
<li>
<p>An API is registered with the <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> that is essentially <em>blocking</em> until synchronization is achieved.</p>
</li>
</ul>
<h2><a class="header" href="#example-3" id="example-3">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">use rhai::{Engine, RegisterFn};

fn main() {
    // Channel: Script -&gt; Master
    let (tx_script, rx_master) = std::sync::mpsc::channel();
    // Channel: Master -&gt; Script
    let (tx_master, rx_script) = std::sync::mpsc::channel();

    // Spawn thread with Engine
    std::thread::spawn(move || {
        // Create Engine
        let mut engine = Engine::new();

        // Register API
        // Notice that the API functions are blocking
        engine
            .register_fn(&quot;get&quot;, move || rx_script.recv().unwrap())
            .register_fn(&quot;put&quot;, move |v: i64| tx_script.send(v).unwrap());

        // Run script
        engine
            .consume(
                r#&quot;
                    print(&quot;Starting script loop...&quot;);

                    loop {
                        // The following call blocks until there is data
                        // in the channel
                        let x = get();
                        print(&quot;Script Read: &quot; + x);

                        x += 1;

                        print(&quot;Script Write: &quot; + x);

                        // The following call blocks until the data
                        // is successfully sent to the channel
                        put(x);
                    }
                &quot;#,
            )
            .unwrap();
    });

    // This is the main processing thread

    println!(&quot;Starting main loop...&quot;);

    let mut value = 0_i64;

    while value &lt; 10 {
        println!(&quot;Value: {}&quot;, value);
        // Send value to script
        tx_master.send(value).unwrap();
        // Receive value from script
        value = rx_master.recv().unwrap();
    }
}
</code></pre></pre>
<h2><a class="header" href="#considerations-for-a-hrefpatternpatternsbookvnextstartfeatureshtmlsynca" id="considerations-for-a-hrefpatternpatternsbookvnextstartfeatureshtmlsynca">Considerations for <a href="pattern/../patterns//book/vnext/start/features.html"><code>sync</code></a></a></h2>
<p><code>std::mpsc::Sender</code> and <code>std::mpsc::Receiver</code> are not <code>Sync</code>, therefore they cannot be used in
registered functions if the <a href="pattern/../patterns//book/vnext/start/features.html"><code>sync</code></a> feature is enabled.</p>
<p>In that situation, it is possible to wrap the <code>Sender</code> and <code>Receiver</code> each in a <code>Mutex</code>,
which makes them <code>Sync</code>. This, however, incurs the additional overhead of locking and unlocking
the <code>Mutex</code> during every function call, which is technically not necessary because there are no
other references to them.</p>
<h2><a class="header" href="#regarding-async-functions" id="regarding-async-functions">Regarding Async Functions</a></h2>
<p>The example above highlights the fact that Rhai scripts can call any Rust function,
including ones that are <em>blocking</em>.</p>
<p>However, Rhai is essentially a blocking, single-threaded engine.
Therefore it does <em>not</em> provide an async API.</p>
<p>That means, although it is simple to use Rhai within a multi-threading environment where blocking a
thread is acceptable or even expected, it is currently not possible to call <em>async</em> functions
within Rhai scripts because there is no mechanism in <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> to wrap the state of the call stack
inside a future.</p>
<p>Fortunately an <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> is re-entrant so it can be shared among many async tasks.
It is usually possible to split a script into multiple parts to avoid having to call async functions.</p>
<p>Creating an <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> is also relatively cheap (extremely cheap if creating a <a href="pattern/../patterns//book/vnext/engine/raw.html">raw <code>Engine</code></a>),
so it is also a valid pattern to spawn a new <a href="pattern/../patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance for each task.</p>
<h1><a class="header" href="#scriptable-event-handler-with-state" id="scriptable-event-handler-with-state">Scriptable Event Handler with State</a></h1>
<h2><a class="header" href="#usage-scenario-5" id="usage-scenario-5">Usage Scenario</a></h2>
<ul>
<li>
<p>A system sends <em>events</em> that must be handled.</p>
</li>
<li>
<p>Flexibility in event handling must be provided, through user-side scripting.</p>
</li>
<li>
<p>State must be kept between invocations of event handlers.</p>
</li>
<li>
<p>Default implementations of event handlers can be provided.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-6" id="key-concepts-6">Key Concepts</a></h2>
<ul>
<li>
<p>An <em>event handler</em> object is declared that holds the following items:</p>
<ul>
<li><a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> with registered functions serving as an API,</li>
<li><a href="patterns//book/vnext/engine/compile.html"><code>AST</code></a> of the user script,</li>
<li>a <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a> containing state.</li>
</ul>
</li>
<li>
<p>Upon an event, the appropriate event handler function in the script is called via <a href="patterns//book/vnext/engine/call-fn.html"><code>Engine::call_fn</code></a>.</p>
</li>
<li>
<p>Optionally, trap the <code>EvalAltResult::ErrorFunctionNotFound</code> error to provide a default implementation.</p>
</li>
</ul>
<h2><a class="header" href="#implementation-4" id="implementation-4">Implementation</a></h2>
<h3><a class="header" href="#declare-handler-object" id="declare-handler-object">Declare Handler Object</a></h3>
<p>In most cases, it would be simpler to store an <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance together with the handler object
because it only requires registering all API functions only once.</p>
<p>In rare cases where handlers are created and destroyed in a tight loop, a new <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance
can be created for each event. See <a href="patterns/parallel.html"><em>One Engine Instance Per Call</em></a> for more details.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, Scope, AST, EvalAltResult};

// Event handler
struct Handler {
    // Scripting engine
    pub engine: Engine,
    // Use a custom 'Scope' to keep stored state
    pub scope: Scope,
    // Program script
    pub ast: AST
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#register-api-for-any-custom-type" id="register-api-for-any-custom-type">Register API for Any Custom Type</a></h3>
<p><a href="patterns//book/vnext/rust/custom.html">Custom types</a> are often used to hold state. The easiest way to register an entire API is via a <a href="patterns//book/vnext/plugins/module.html">plugin module</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::plugin::*;

// A custom type to a hold state value.
#[derive(Debug, Clone, Eq, PartialEq, Hash, Default)]
pub struct SomeType {
    data: i64;
}

#[export_module]
mod SomeTypeAPI {
    #[rhai_fn(global)]
    pub func1(obj: &amp;mut SomeType) -&gt; bool { ... }
    #[rhai_fn(global)]
    pub func2(obj: &amp;mut SomeType) -&gt; bool { ... }
    pub process(data: i64) -&gt; i64 { ... }
    #[rhai_fn(get = &quot;value&quot;)]
    pub get_value(obj: &amp;mut SomeType) -&gt; i64 { obj.data }
    #[rhai_fn(set = &quot;value&quot;)]
    pub set_value(obj: &amp;mut SomeType, value: i64) { obj.data = value; }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#initialize-handler-object" id="initialize-handler-object">Initialize Handler Object</a></h3>
<p>Steps to initialize the event handler:</p>
<ol>
<li>Register an API with the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a>,</li>
<li>Create a custom <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a> to serve as the stored state,</li>
<li>Add default state variables into the custom <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a>,</li>
<li>Get the handler script and <a href="patterns//book/vnext/engine/compile.html">compile</a> it,</li>
<li>Store the compiled <a href="patterns//book/vnext/engine/compile.html"><code>AST</code></a> for future evaluations,</li>
<li>Run the <a href="patterns//book/vnext/engine/compile.html"><code>AST</code></a> to initialize event handler state variables.</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler {
    pub new(path: impl Into&lt;PathBuf&gt;) -&gt; Self {
        let mut engine = Engine::new();

        // Register custom types and API's
        engine
            .register_type_with_name::&lt;SomeType&gt;(&quot;SomeType&quot;)
            .register_global_module(exported_module!(SomeTypeAPI));

        // Create a custom 'Scope' to hold state
        let mut scope = Scope::new();

        // Add initialized state into the custom 'Scope'
        scope.push(&quot;state1&quot;, false);
        scope.push(&quot;state2&quot;, SomeType::new(42));

        // Compile the handler script.
        // In a real application you'd be handling errors...
        let ast = engine.compile_file(path).unwrap();

        // Evaluate the script to initialize it and other state variables.
        // In a real application you'd again be handling errors...
        engine.consume_ast_with_scope(&amp;mut scope, &amp;ast).unwrap();

        // The event handler is essentially these three items:
        Handler { engine, scope, ast }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#hook-up-events" id="hook-up-events">Hook up events</a></h3>
<p>There is usually an interface or trait that gets called when an event comes from the system.</p>
<p>Mapping an event from the system into a scripted handler is straight-forward:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Handler {
    // Say there are three events: 'start', 'end', 'update'.
    // In a real application you'd be handling errors...
    pub fn on_event(&amp;mut self, event_name: &amp;str, event_data: i64) -&gt; Result&lt;(), Error&gt; {
        let engine = &amp;self.engine;
        let scope = &amp;mut self.scope;
        let ast = &amp;self.ast;

        match event_name {
            // The 'start' event maps to function 'start'.
            // In a real application you'd be handling errors...
            &quot;start&quot; =&gt; engine.call_fn(scope, ast, &quot;start&quot;, (event_data,))?,

            // The 'end' event maps to function 'end'.
            // In a real application you'd be handling errors...
            &quot;end&quot; =&gt; engine.call_fn(scope, ast, &quot;end&quot;, (event_data,))?,

            // The 'update' event maps to function 'update'.
            // This event provides a default implementation when the scripted function
            // is not found.
            &quot;update&quot; =&gt;
                engine.call_fn(scope, ast, &quot;update&quot;, (event_data,))
                      .or_else(|err| match *err {
                         EvalAltResult::ErrorFunctionNotFound(fn_name, _) if fn_name == &quot;update&quot; =&gt; {
                            // Default implementation of 'update' event handler
                            self.scope.set_value(&quot;state2&quot;, SomeType::new(42));
                            // Turn function-not-found into a success
                            Ok(Dynamic::UNIT)
                         }
                         _ =&gt; Err(err.into())
                      })?
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#sample-handler-script" id="sample-handler-script">Sample Handler Script</a></h3>
<p>Because the stored state is kept in a custom <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a>, it is possible for all functions defined
in the handler script to access and modify these state variables.</p>
<p>The API registered with the <a href="patterns//book/vnext/engine/hello-world.html"><code>Engine</code></a> can be also used throughout the script.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn start(data) {
    if state1 {
        throw &quot;Already started!&quot;;
    }
    if state2.func1() || state2.func2() {
        throw &quot;Conditions not yet ready to start!&quot;;
    }
    state1 = true;
    state2.value = data;
}

fn end(data) {
    if !state1 {
        throw &quot;Not yet started!&quot;;
    }
    if state2.func1() || state2.func2() {
        throw &quot;Conditions not yet ready to start!&quot;;
    }
    state1 = false;
    state2.value = data;
}

fn update(data) {
    state2.value += process(data);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#dynamic-constants-provider" id="dynamic-constants-provider">Dynamic Constants Provider</a></h1>
<h2><a class="header" href="#usage-scenario-6" id="usage-scenario-6">Usage Scenario</a></h2>
<ul>
<li>
<p>A system has a <em>large</em> number of constants, but only a minor set will be used by any script.</p>
</li>
<li>
<p>The system constants are expensive to load.</p>
</li>
<li>
<p>The system constants set is too massive to push into a custom <a href="patterns//book/vnext/engine/scope.html"><code>Scope</code></a>.</p>
</li>
<li>
<p>The values of system constants are volatile and call-dependent.</p>
</li>
</ul>
<h2><a class="header" href="#key-concepts-7" id="key-concepts-7">Key Concepts</a></h2>
<ul>
<li>
<p>Use a <a href="patterns//book/vnext/engine/var.html">variable resolver</a> to intercept variable access.</p>
</li>
<li>
<p>Only load a variable when it is being used.</p>
</li>
<li>
<p>Perform a lookup based on variable name, and provide the correct data value.</p>
</li>
<li>
<p>May even perform back-end network access or look up the latest value from a database.</p>
</li>
</ul>
<h2><a class="header" href="#implementation-5" id="implementation-5">Implementation</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

// Create shared data provider.
// Assume that SystemValuesProvider::get(&amp;str) -&gt; Option&lt;value&gt; gets a value.
let provider = Arc::new(SystemValuesProvider::new());

// Clone the shared provider
let db = provider.clone();

// Register a variable resolver.
// Move the shared provider into the closure.
engine.on_var(move |name, _, _, _| Ok(db.get(name).map(Dynamic::from)));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#values-are-constants" id="values-are-constants">Values are Constants</a></h2>
<p>All values provided by a <a href="patterns//book/vnext/engine/var.html">variable resolver</a> are <em>constants</em> due to their dynamic nature.
They cannot be assigned to.</p>
<p>In order to change values in an external system, register a dedicated API for that purpose.</p>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<p>This section covers advanced features of the Rhai <a href="/book/vnext/engine/hello-world.html"><code>Engine</code></a>.</p>
<h1><a class="header" href="#capture-the-calling-scope-for-function-call" id="capture-the-calling-scope-for-function-call">Capture The Calling Scope for Function Call</a></h1>
<h2><a class="header" href="#peeking-out-of-the-pure-box" id="peeking-out-of-the-pure-box">Peeking Out of The Pure Box</a></h2>
<p>Rhai functions are <em>pure</em>, meaning that they depend on on their arguments and have no
access to the calling environment.</p>
<p>When a function accesses a variable that is not defined within that function’s scope,
it raises an evaluation error.</p>
<p>It is possible, through a special syntax, to capture the calling scope – i.e. the scope
that makes the function call – and access variables defined there.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(y) {             // function accesses 'x' and 'y', but 'x' is not defined
    x += y;             // 'x' is modified in this function
    x
}

let x = 1;

foo(41);                // error: variable 'x' not found

// Calling a function with a '!' causes it to capture the calling scope

foo!(41) == 42;         // the function can access the value of 'x', but cannot change it

x == 1;                 // 'x' is still the original value

x.method!();            // &lt;- syntax error: capturing is not allowed in method-call style

// Capturing also works for function pointers

let f = Fn(&quot;foo&quot;);

call!(f, 41) == 42;     // must use function-call style

f.call!(41);            // &lt;- syntax error: capturing is not allowed in method-call style

// Capturing is not available for module functions

import &quot;hello&quot; as h;

h::greet!();            // &lt;- syntax error: capturing is not allowed in namespace-qualified calls
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#no-mutations" id="no-mutations">No Mutations</a></h2>
<p>Variables in the calling scope are captured as cloned copies.
Changes to them do <strong>not</strong> reflect back to the calling scope.</p>
<p>Rhai functions remain <em>pure</em> in the sense that they can never mutate their environment.</p>
<h2><a class="header" href="#caveat-emptor" id="caveat-emptor">Caveat Emptor</a></h2>
<p>Functions relying on the calling scope is often a <em>Very Bad Idea™</em> because it makes code
almost impossible to reason and maintain, as their behaviors are volatile and unpredictable.</p>
<p>They behave more like macros that are expanded inline than actual function calls, thus the
syntax is also similar to Rust’s macro invocations.</p>
<p>This usage should be at the last resort. YOU HAVE BEEN WARNED.</p>
<h1><a class="header" href="#use-the-low-level-api-to-register-a-rust-function" id="use-the-low-level-api-to-register-a-rust-function">Use the Low-Level API to Register a Rust Function</a></h1>
<p>When a native Rust function is registered with an <code>Engine</code> using the <code>Engine::register_XXX</code> API,
Rhai transparently converts all function arguments from <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> into the correct types before
calling the function.</p>
<p>For more power and flexibility, there is a <em>low-level</em> API to work directly with <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> values
without the conversions.</p>
<h2><a class="header" href="#raw-function-registration" id="raw-function-registration">Raw Function Registration</a></h2>
<p>The <code>Engine::register_raw_fn</code> method is marked <em>volatile</em>, meaning that it may be changed without warning.</p>
<p>If this is acceptable, then using this method to register a Rust function opens up more opportunities.</p>
<p>In particular, a the current <em>native call context</em> (in form of the <code>NativeCallContext</code> type) is passed as an argument.
<code>NativeCallContext</code> exposes the current <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a>, among others, so the Rust function can also use <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a> facilities
(such as evaluating a script).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.register_raw_fn(
    &quot;increment_by&quot;,                                         // function name
    &amp;[                                                      // a slice containing parameter types
        std::any::TypeId::of::&lt;i64&gt;(),                      // type of first parameter
        std::any::TypeId::of::&lt;i64&gt;()                       // type of second parameter
    ],
    |context, args| {                                       // fixed function signature
        // Arguments are guaranteed to be correct in number and of the correct types.

        // But remember this is Rust, so you can keep only one mutable reference at any one time!
        // Therefore, get a '&amp;mut' reference to the first argument _last_.
        // Alternatively, use `args.split_first_mut()` etc. to split the slice first.

        let y = *args[1].read_lock::&lt;i64&gt;().unwrap();       // get a reference to the second argument
                                                            // then copy it because it is a primary type

        let y = std::mem::take(args[1]).cast::&lt;i64&gt;();      // alternatively, directly 'consume' it

        let x = args[0].write_lock::&lt;i64&gt;().unwrap();       // get a '&amp;mut' reference to the first argument

        *x += y;                                            // perform the action

        Ok(Dynamic::UNIT)                                       // must be 'Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;'
    }
);

// The above is the same as (in fact, internally they are equivalent):

engine.register_fn(&quot;increment_by&quot;, |x: &amp;mut i64, y: i64| *x += y);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#function-signature" id="function-signature">Function Signature</a></h2>
<p>The function signature passed to <code>Engine::register_raw_fn</code> takes the following form:</p>
<blockquote>
<p><code>Fn(context: NativeCallContext, args: &amp;mut [&amp;mut Dynamic])</code><br />
<code>-&gt; Result&lt;T, Box&lt;EvalAltResult&gt;&gt; + 'static</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th>Parameter</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>T</code></td><td align="center"><code>impl Clone</code></td><td>return type of the function</td></tr>
<tr><td><code>context</code></td><td align="center"><code>NativeCallContext</code></td><td>the current <em>native call context</em></td></tr>
<tr><td>• <code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>the current <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a>, with all configurations and settings.<br/>This is sometimes useful for calling a script-defined function within the same evaluation context using <a href="rust//book/vnext/engine/call-fn.html"><code>Engine::call_fn</code></a>, or calling a <a href="rust//book/vnext/language/fn-ptr.html">function pointer</a>.</td></tr>
<tr><td>• <code>fn_name()</code></td><td align="center"><code>&amp;str</code></td><td>name of the function called (useful when the same Rust function is mapped to multiple Rhai-callable function names)</td></tr>
<tr><td>• <code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td>• <code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="rust//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td>• <code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="rust//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="rust//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td>• <code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="rust//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td>• <code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="rust//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="rust//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td><code>args</code></td><td align="center"><code>&amp;mut [&amp;mut Dynamic]</code></td><td>a slice containing <code>&amp;mut</code> references to <a href="rust//book/vnext/language/dynamic.html"><code>Dynamic</code></a> values.<br/>The slice is guaranteed to contain enough arguments <em>of the correct types</em>.</td></tr>
</tbody></table>
<h3><a class="header" href="#return-value" id="return-value">Return value</a></h3>
<p>The return value is the result of the function call.</p>
<p>Remember, in Rhai, all arguments <em>except</em> the <em>first</em> one are always passed by <em>value</em> (i.e. cloned).
Therefore, it is unnecessary to ever mutate any argument except the first one, as all mutations
will be on the cloned copy.</p>
<h2><a class="header" href="#extract-arguments" id="extract-arguments">Extract Arguments</a></h2>
<p>To extract an argument from the <code>args</code> parameter (<code>&amp;mut [&amp;mut Dynamic]</code>), use the following:</p>
<table><thead><tr><th>Argument type</th><th>Access (<code>n</code> = argument position)</th><th>Result</th></tr></thead><tbody>
<tr><td><a href="rust//book/vnext/language/values-and-types.html">Primary type</a></td><td><code>args[n].clone().cast::&lt;T&gt;()</code></td><td>copy of value</td></tr>
<tr><td><a href="rust//book/vnext/rust/custom.html">Custom type</a></td><td><code>args[n].read_lock::&lt;T&gt;().unwrap()</code></td><td>immutable reference to value</td></tr>
<tr><td><a href="rust//book/vnext/rust/custom.html">Custom type</a> (consumed)</td><td><code>std::mem::take(args[n]).cast::&lt;T&gt;()</code></td><td>the <em>consumed</em> value; the original value becomes <code>()</code></td></tr>
<tr><td><code>this</code> object</td><td><code>args[0].write_lock::&lt;T&gt;().unwrap()</code></td><td>mutable reference to value</td></tr>
</tbody></table>
<p>When there is a mutable reference to the <code>this</code> object (i.e. the first argument),
there can be no other immutable references to <code>args</code>, otherwise the Rust borrow checker will complain.</p>
<h2><a class="header" href="#example--passing-a-callback-to-a-rust-function" id="example--passing-a-callback-to-a-rust-function">Example – Passing a Callback to a Rust Function</a></h2>
<p>The low-level API is useful when there is a need to interact with the scripting <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a>
within a function.</p>
<p>The following example registers a function that takes a <a href="rust//book/vnext/language/fn-ptr.html">function pointer</a> as an argument,
then calls it within the same <a href="rust//book/vnext/engine/hello-world.html"><code>Engine</code></a>.  This way, a <em>callback</em> function can be provided
to a native Rust function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, FnPtr};

let mut engine = Engine::new();

// Register a Rust function
engine.register_raw_fn(
    &quot;bar&quot;,
    &amp;[
        std::any::TypeId::of::&lt;i64&gt;(),                      // parameter types
        std::any::TypeId::of::&lt;FnPtr&gt;(),
        std::any::TypeId::of::&lt;i64&gt;(),
    ],
    |context, args| {
        // 'args' is guaranteed to contain enough arguments of the correct types

        let fp = std::mem::take(args[1]).cast::&lt;FnPtr&gt;();   // 2nd argument - function pointer
        let value = args[2].clone();                        // 3rd argument - function argument
        let this_ptr = args.get_mut(0).unwrap();            // 1st argument - this pointer

        // Use 'FnPtr::call_dynamic' to call the function pointer.
        // Beware, private script-defined functions will not be found.
        fp.call_dynamic(context, Some(this_ptr), [value])
    },
);

let result = engine.eval::&lt;i64&gt;(
          r#&quot;
                fn foo(x) { this += x; }    // script-defined function 'foo'

                let x = 41;                 // object
                x.bar(Fn(&quot;foo&quot;), 1);        // pass 'foo' as function pointer
                x
          &quot;#)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#tldr--why-read_lock-and-write_lock" id="tldr--why-read_lock-and-write_lock">TL;DR – Why <code>read_lock</code> and <code>write_lock</code></a></h2>
<p>The <code>Dynamic</code> API that casts it to a reference to a particular data type  is <code>read_lock</code>
(for an immutable reference) and <code>write_lock</code> (for a mutable reference).</p>
<p>As the naming shows, something is <em>locked</em> in order to allow this access, and that something
is a <em>shared value</em> created by <a href="rust//book/vnext/language/fn-closure.html">capturing</a> variables from <a href="rust//book/vnext/language/fn-closure.html">closures</a>.</p>
<p>Shared values are implemented as <code>Rc&lt;RefCell&lt;Dynamic&gt;&gt;</code> (<code>Arc&lt;RwLock&lt;Dynamic&gt;&gt;</code> under <a href="rust//book/vnext/start/features.html"><code>sync</code></a>).</p>
<p>If the value is <em>not</em> a shared value, or if running under <a href="rust//book/vnext/start/features.html"><code>no_closure</code></a> where there is
no <a href="rust//book/vnext/language/fn-closure.html">capturing</a>, this API de-sugars to a simple <code>Dynamic::downcast_ref</code> and
<code>Dynamic::downcast_mut</code>.  In other words, there is no locking and reference counting overhead
for the vast majority of non-shared values.</p>
<p>If the value is a shared value, then it is first locked and the returned lock guard
then allows access to the underlying value in the specified type.</p>
<h2><a class="header" href="#hold-multiple-references" id="hold-multiple-references">Hold Multiple References</a></h2>
<p>In order to access a value argument that is expensive to clone <em>while</em> holding a mutable reference
to the first argument, either <em>consume</em> that argument via <code>mem::take</code> as above, or use <code>args.split_first</code>
to partition the slice:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Partition the slice
let (first, rest) = args.split_first_mut().unwrap();

// Mutable reference to the first parameter
let this_ptr = &amp;mut *first.write_lock::&lt;A&gt;().unwrap();

// Immutable reference to the second value parameter
// This can be mutable but there is no point because the parameter is passed by value
let value_ref = &amp;*rest[0].read_lock::&lt;B&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#variable-resolver" id="variable-resolver">Variable Resolver</a></h1>
<p>By default, Rhai looks up access to variables from the enclosing block scope,
working its way outwards until it reaches the top (global) level, then it
searches the <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> that is passed into the <code>Engine::eval</code> call.</p>
<p>There is a built-in facility for advanced users to <em>hook</em> into the variable
resolution service and to override its default behavior.</p>
<p>To do so, provide a closure to the <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a> via the <code>Engine::on_var</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut engine = Engine::new();

// Register a variable resolver.
engine.on_var(|name, index, context| {
    match name {
        &quot;MYSTIC_NUMBER&quot; =&gt; Ok(Some((42 as INT).into())),
        // Override a variable - make it not found even if it exists!
        &quot;DO_NOT_USE&quot; =&gt; Err(Box::new(
            EvalAltResult::ErrorVariableNotFound(name.to_string(), Position::NONE)
        )),
        // Silently maps 'chameleon' into 'innocent'.
        &quot;chameleon&quot; =&gt; context.scope().get_value(&quot;innocent&quot;).map(Some).ok_or_else(|| Box::new(
            EvalAltResult::ErrorVariableNotFound(name.to_string(), Position::NONE)
        )),
        // Return Ok(None) to continue with the normal variable resolution process.
        _ =&gt; Ok(None)
    }
});
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#returned-values-are-constants" id="returned-values-are-constants">Returned Values are Constants</a></h2>
<p>Variable values, if any returned, are treated as <em>constants</em> by the script and cannot be assigned to.
This is to avoid needing a mutable reference to the underlying data provider which may not be possible to obtain.</p>
<p>In order to change these variables, it is best to push them into a custom <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> instead of using
a variable resolver. Then these variables can be assigned to and their updated values read back after
the script is evaluated.</p>
<h2><a class="header" href="#benefits-of-using-a-variable-resolver" id="benefits-of-using-a-variable-resolver">Benefits of Using a Variable Resolver</a></h2>
<ol>
<li>
<p>Avoid having to maintain a custom <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> with all variables regardless of need (because a script may not use them all).</p>
</li>
<li>
<p><em>Short-circuit</em> variable access, essentially overriding standard behavior.</p>
</li>
<li>
<p><em>Lazy-load</em> variables when they are accessed, not up-front. This benefits when the number of variables is very large, when they are timing-dependent, or when they are expensive to load.</p>
</li>
<li>
<p>Rename system variables on a script-by-script basis without having to construct different <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a>‘s.</p>
</li>
</ol>
<h2><a class="header" href="#function-signature-1" id="function-signature-1">Function Signature</a></h2>
<p>The function signature passed to <code>Engine::on_var</code> takes the following form:</p>
<blockquote>
<p><code>Fn(name: &amp;str, index: usize, context: &amp;EvalContext)</code><br />
<code>-&gt; Result&lt;Option&lt;Dynamic&gt;, Box&lt;EvalAltResult&gt;&gt; + 'static</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th>Parameter</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td align="center"><code>&amp;str</code></td><td>variable name</td></tr>
<tr><td><code>index</code></td><td align="center"><code>usize</code></td><td>an offset from the bottom of the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> that the variable is supposed to reside.<br/>Offsets start from 1, with 1 meaning the last variable in the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a>.  Essentially the correct variable is at position <code>scope.len() - index</code>.<br/>If <code>index</code> is zero, then there is no pre-calculated offset position and a search through the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> must be performed.</td></tr>
<tr><td><code>context</code></td><td align="center"><code>&amp;EvalContext</code></td><td>reference to the current evaluation <em>context</em></td></tr>
<tr><td>• <code>scope()</code></td><td align="center"><code>&amp;Scope</code></td><td>reference to the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a></td></tr>
<tr><td>• <code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>reference to the current <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a></td></tr>
<tr><td>• <code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td>• <code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="engine//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td>• <code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="engine//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="engine//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td>• <code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="engine//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td>• <code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="engine//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="engine//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td>• <code>this_ptr()</code></td><td align="center"><code>Option&lt;&amp;Dynamic&gt;</code></td><td>reference to the current bound [<code>this</code>] pointer, if any</td></tr>
<tr><td>• <code>call_level()</code></td><td align="center"><code>usize</code></td><td>the current nesting level of function calls</td></tr>
</tbody></table>
<h3><a class="header" href="#return-value-1" id="return-value-1">Return Value</a></h3>
<p>The return value is <code>Result&lt;Option&lt;Dynamic&gt;, Box&lt;EvalAltResult&gt;&gt;</code> where:</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Ok(None)</code></td><td>normal variable resolution process should continue, i.e. continue searching through the <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a></td></tr>
<tr><td><code>Ok(Some(Dynamic))</code></td><td>value of the variable, treated as a constant</td></tr>
<tr><td><code>Err(Box&lt;EvalAltResult&gt;)</code></td><td>error that is reflected back to the <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a>.<br/>Normally this is <code>EvalAltResult::ErrorVariableNotFound(var_name, Position::NONE)</code> to indicate that the variable does not exist, but it can be any <code>EvalAltResult</code>.</td></tr>
</tbody></table>
<h1><a class="header" href="#use-rhai-as-a-domain-specific-language-dsl" id="use-rhai-as-a-domain-specific-language-dsl">Use Rhai as a Domain-Specific Language (DSL)</a></h1>
<p>Rhai can be successfully used as a domain-specific language (DSL).</p>
<h2><a class="header" href="#expressions-only" id="expressions-only">Expressions Only</a></h2>
<p>In many DSL scenarios, only evaluation of expressions is needed.</p>
<p>The <a href="engine//book/vnext/engine/expressions.html"><code>Engine::eval_expression_XXX</code></a> API can be used to restrict
a script to expressions only.</p>
<h2><a class="header" href="#unicode-standard-annex-31-identifiers-1" id="unicode-standard-annex-31-identifiers-1">Unicode Standard Annex #31 Identifiers</a></h2>
<p>Variable names and other identifiers do not necessarily need to be ASCII-only.</p>
<p>The <a href="engine//book/vnext/start/features.html"><code>unicode-xid-ident</code></a> feature, when turned on, causes Rhai to allow variable names and identifiers
that follow <a href="http://www.unicode.org/reports/tr31/">Unicode Standard Annex #31</a>.</p>
<p>This is sometimes useful in a non-English DSL.</p>
<h2><a class="header" href="#disable-keywords-andor-operators" id="disable-keywords-andor-operators">Disable Keywords and/or Operators</a></h2>
<p>In some DSL scenarios, it is necessary to further restrict the language to exclude certain
language features that are not necessary or dangerous to the application.</p>
<p>For example, a DSL may disable the <code>while</code> loop while keeping all other statement types intact.</p>
<p>It is possible, in Rhai, to surgically <a href="engine//book/vnext/engine/disable.html">disable keywords and operators</a>.</p>
<h2><a class="header" href="#custom-operators" id="custom-operators">Custom Operators</a></h2>
<p>On the other hand, some DSL scenarios require special operators that make sense only for
that specific environment.  In such cases, it is possible to define <a href="engine//book/vnext/engine/custom-op.html">custom operators</a> in Rhai.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let animal = &quot;rabbit&quot;;
let food = &quot;carrot&quot;;

animal eats food            // custom operator 'eats'

eats(animal, food)          // &lt;- the above really de-sugars to this
<span class="boring">}
</span></code></pre></pre>
<p>Although a <a href="engine//book/vnext/engine/custom-op.html">custom operator</a> always de-sugars to a simple function call,
nevertheless it makes the DSL syntax much simpler and expressive.</p>
<h2><a class="header" href="#custom-syntax" id="custom-syntax">Custom Syntax</a></h2>
<p>For advanced DSL scenarios, it is possible to define entire expression <a href="engine//book/vnext/engine/custom-syntax.html"><em>syntax</em></a> &amp;ndash
essentially custom statement types.</p>
<p>For example, the following is a SQL-like syntax for some obscure DSL operation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let table = [..., ..., ..., ...];

// Syntax = calculate $ident$ ( $expr$ -&gt; $ident$ ) =&gt; $ident$ : $expr$
let total = calculate sum(table-&gt;price) =&gt; row : row.weight &gt; 50;

// Note: There is nothing special about those symbols; to make it look exactly like SQL:
// Syntax = SELECT $ident$ ( $ident$ ) AS $ident$ FROM $expr$ WHERE $expr$
let total = SELECT sum(price) AS row FROM table WHERE row.weight &gt; 50;
<span class="boring">}
</span></code></pre></pre>
<p>After registering this custom syntax with Rhai, it can be used anywhere inside a script as
a normal expression.</p>
<p>For its evaluation, the callback function will receive the following list of inputs:</p>
<ul>
<li><code>inputs[0] = &quot;sum&quot;</code> - math operator</li>
<li><code>inputs[1] = &quot;price&quot;</code> - field name</li>
<li><code>inputs[2] = &quot;row&quot;</code> - loop variable name</li>
<li><code>inputs[3] = Expression(table)</code> - data source</li>
<li><code>inputs[4] = Expression(row.wright &gt; 50)</code> - filter predicate</li>
</ul>
<p>Other identifiers, such as <code>&quot;calculate&quot;</code>, <code>&quot;FROM&quot;</code>, as well as symbols such as <code>-&gt;</code> and <code>:</code> etc.,
are parsed in the order defined within the custom syntax.</p>
<h1><a class="header" href="#disable-certain-keywords-andor-operators" id="disable-certain-keywords-andor-operators">Disable Certain Keywords and/or Operators</a></h1>
<p>For certain embedded usage, it is sometimes necessary to restrict the language to a strict subset of Rhai
to prevent usage of certain language features.</p>
<p>Rhai supports surgically disabling a keyword or operator via the <code>Engine::disable_symbol</code> method.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::Engine;

let mut engine = Engine::new();

engine
    .disable_symbol(&quot;if&quot;)       // disable the 'if' keyword
    .disable_symbol(&quot;+=&quot;);      // disable the '+=' operator

// The following all return parse errors.

engine.compile(&quot;let x = if true { 42 } else { 0 };&quot;)?;
//                      ^ 'if' is rejected as a reserved keyword

engine.compile(&quot;let x = 40 + 2; x += 1;&quot;)?;
//                                ^ '+=' is not recognized as an operator
//                         ^ other operators are not affected
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#custom-operators-1" id="custom-operators-1">Custom Operators</a></h1>
<p>For use as a DSL (Domain-Specific Languages), it is sometimes more convenient to augment Rhai with
customized operators performing specific logic.</p>
<p><code>Engine::register_custom_operator</code> registers a keyword as a custom operator, giving it a particular
<em>precedence</em> (which cannot be zero).</p>
<h2><a class="header" href="#example-4" id="example-4">Example</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rhai::{Engine, RegisterFn};

let mut engine = Engine::new();

// Register a custom operator named 'foo' and give it a precedence of 160
// (i.e. between +|- and *|/)
// Also register the implementation of the customer operator as a function
engine
    .register_custom_operator(&quot;foo&quot;, 160)?
    .register_fn(&quot;foo&quot;, |x: i64, y: i64| (x * y) - (x + y));

// The custom operator can be used in expressions
let result = engine.eval_expression::&lt;i64&gt;(&quot;1 + 2 * 3 foo 4 - 5 / 6&quot;)?;
//                                                    ^ custom operator

// The above is equivalent to: 1 + ((2 * 3) foo 4) - (5 / 6)
result == 15;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#alternatives-to-a-custom-operator" id="alternatives-to-a-custom-operator">Alternatives to a Custom Operator</a></h2>
<p>Custom operators are merely <em>syntactic sugar</em>.  They map directly to registered functions.</p>
<p>Therefore, the following are equivalent (assuming <code>foo</code> has been registered as a custom operator):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 + 2 * 3 foo 4 - 5 / 6     // use custom operator

1 + foo(2 * 3, 4) - 5 / 6   // use function call
<span class="boring">}
</span></code></pre></pre>
<p>A script using custom operators can always be pre-processed, via a pre-processor application,
into a syntax that uses the corresponding function calls.</p>
<p>Using <code>Engine::register_custom_operator</code> merely enables a convenient shortcut.</p>
<h2><a class="header" href="#must-be-a-valid-identifier-or-reserved-symbol" id="must-be-a-valid-identifier-or-reserved-symbol">Must be a Valid Identifier or Reserved Symbol</a></h2>
<p>All custom operators must be <em>identifiers</em> that follow the same naming rules as <a href="engine//book/vnext/language/variables.html">variables</a>.</p>
<p>Alternatively, they can also be <a href="engine//book/vnext/appendix/operators.html#symbols">reserved symbols</a>,
<a href="engine//book/vnext/engine/disable.html">disabled operators or keywords</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.register_custom_operator(&quot;foo&quot;, 20);     // 'foo' is a valid custom operator

engine.register_custom_operator(&quot;#&quot;, 20);       // the reserved symbol '#' is also
                                                // a valid custom operator

engine.register_custom_operator(&quot;+&quot;, 30);       // &lt;- error: '+' is an active operator

engine.register_custom_operator(&quot;=&gt;&quot;, 30);      // &lt;- error: '=&gt;' is an active symbol
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#binary-operators-only" id="binary-operators-only">Binary Operators Only</a></h2>
<p>All custom operators must be <em>binary</em> (i.e. they take two operands).
<em>Unary</em> custom operators are not supported.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine
    .register_custom_operator(&quot;foo&quot;, 160)?
    .register_fn(&quot;foo&quot;, |x: i64| x * x);

engine.eval::&lt;i64&gt;(&quot;1 + 2 * 3 foo 4 - 5 / 6&quot;)?; // error: function 'foo (i64, i64)' not found
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#operator-precedence" id="operator-precedence">Operator Precedence</a></h2>
<p>All operators in Rhai has a <em>precedence</em> indicating how tightly they bind.</p>
<p>A higher precedence binds more tightly than a lower precedence, so <code>*</code> and <code>/</code> binds before <code>+</code> and <code>-</code> etc.</p>
<p>When registering a custom operator, the operator’s precedence must also be provided.</p>
<p>The following <em>precedence table</em> shows the built-in precedence of standard Rhai operators:</p>
<table><thead><tr><th>Category</th><th align="center">Operators</th><th align="center">Precedence (0-255)</th></tr></thead><tbody>
<tr><td>Assignments</td><td align="center"><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>~=</code>, <code>%=</code>,<br/><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code></td><td align="center">0</td></tr>
<tr><td>Logic and bit masks</td><td align="center"><code>||</code>,  <code>|</code>, <code>^</code></td><td align="center">30</td></tr>
<tr><td>Logic and bit masks</td><td align="center"><code>&amp;&amp;</code>, <code>&amp;</code></td><td align="center">60</td></tr>
<tr><td>Comparisons</td><td align="center"><code>==</code>, <code>!=</code></td><td align="center">90</td></tr>
<tr><td></td><td align="center"><code>in</code></td><td align="center">110</td></tr>
<tr><td>Comparisons</td><td align="center"><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></td><td align="center">130</td></tr>
<tr><td>Arithmetic</td><td align="center"><code>+</code>, <code>-</code></td><td align="center">150</td></tr>
<tr><td>Arithmetic</td><td align="center"><code>*</code>, <code>/</code>, <code>%</code></td><td align="center">180</td></tr>
<tr><td>Arithmetic</td><td align="center"><code>~</code></td><td align="center">190</td></tr>
<tr><td>Bit-shifts</td><td align="center"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td align="center">210</td></tr>
<tr><td>Object</td><td align="center"><code>.</code> <em>(binds to right)</em></td><td align="center">240</td></tr>
<tr><td>Unary operators</td><td align="center">unary <code>+</code>, <code>-</code>, <code>!</code> <em>(binds to right)</em></td><td align="center">255</td></tr>
</tbody></table>
<h1><a class="header" href="#extend-rhai-with-custom-syntax" id="extend-rhai-with-custom-syntax">Extend Rhai with Custom Syntax</a></h1>
<p>For the ultimate adventurous, there is a built-in facility to <em>extend</em> the Rhai language
with custom-defined <em>syntax</em>.</p>
<p>But before going off to define the next weird statement type, heed this warning:</p>
<h2><a class="header" href="#dont-do-it" id="dont-do-it">Don’t Do It™</a></h2>
<p>Stick with standard language syntax as much as possible.</p>
<p>Having to learn Rhai is bad enough, no sane user would ever want to learn <em>yet</em> another
obscure language syntax just to do something.</p>
<p>Try to use <a href="engine//book/vnext/engine/custom-op.html">custom operators</a> first.  Defining a custom syntax should be considered a <em>last resort</em>.</p>
<h2><a class="header" href="#where-this-might-be-useful" id="where-this-might-be-useful">Where This Might Be Useful</a></h2>
<ul>
<li>
<p>Where an operation is used a <em>LOT</em> and a custom syntax saves a lot of typing.</p>
</li>
<li>
<p>Where a custom syntax <em>significantly</em> simplifies the code and <em>significantly</em> enhances understanding of the code’s intent.</p>
</li>
<li>
<p>Where certain logic cannot be easily encapsulated inside a function.</p>
</li>
<li>
<p>Where you just want to confuse your user and make their lives miserable, because you can.</p>
</li>
</ul>
<h2><a class="header" href="#step-one--design-the-syntax" id="step-one--design-the-syntax">Step One – Design The Syntax</a></h2>
<p>A custom syntax is simply a list of symbols.</p>
<p>These symbol types can be used:</p>
<ul>
<li>
<p>Standard <a href="engine//book/vnext/appendix/keywords.html">keywords</a></p>
</li>
<li>
<p>Standard <a href="engine//book/vnext/appendix/operators.html#operators">operators</a>.</p>
</li>
<li>
<p>Reserved <a href="engine//book/vnext/appendix/operators.html#symbols">symbols</a>.</p>
</li>
<li>
<p>Identifiers following the <a href="engine//book/vnext/language/variables.html">variable</a> naming rules.</p>
</li>
<li>
<p><code>$expr$</code> – any valid expression, statement or statement block.</p>
</li>
<li>
<p><code>$block$</code> – any valid statement block (i.e. must be enclosed by <code>'{'</code> .. <code>'}'</code>).</p>
</li>
<li>
<p><code>$ident$</code> – any <a href="engine//book/vnext/language/variables.html">variable</a> name.</p>
</li>
</ul>
<h3><a class="header" href="#the-first-symbol-must-be-an-identifier" id="the-first-symbol-must-be-an-identifier">The First Symbol Must be an Identifier</a></h3>
<p>There is no specific limit on the combination and sequencing of each symbol type,
except the <em>first</em> symbol which must be a custom keyword that follows the naming rules
of <a href="engine//book/vnext/language/variables.html">variables</a>.</p>
<p>The first symbol also cannot be a normal or reserved <a href="engine//book/vnext/appendix/keywords.html">keyword</a>.
In other words, any valid identifier that is not a <a href="engine//book/vnext/appendix/keywords.html">keyword</a> will work fine.</p>
<h3><a class="header" href="#the-first-symbol-must-be-unique" id="the-first-symbol-must-be-unique">The First Symbol Must be Unique</a></h3>
<p>Rhai uses the <em>first</em> symbol as a clue to parse custom syntax.</p>
<p>Therefore, at any one time, there can only be <em>one</em> custom syntax starting with each unique symbol.</p>
<p>Any new custom syntax definition using the same first symbol simply <em>overwrites</em> the previous one.</p>
<h3><a class="header" href="#example-5" id="example-5">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>exec $ident$ &lt;- $expr$ : $block$
<span class="boring">}
</span></code></pre></pre>
<p>The above syntax is made up of a stream of symbols:</p>
<table><thead><tr><th align="center">Position</th><th align="center">Input</th><th align="center">Symbol</th><th>Description</th></tr></thead><tbody>
<tr><td align="center">1</td><td align="center"></td><td align="center"><code>exec</code></td><td>custom keyword</td></tr>
<tr><td align="center">2</td><td align="center">1</td><td align="center"><code>$ident$</code></td><td>a variable name</td></tr>
<tr><td align="center">3</td><td align="center"></td><td align="center"><code>&lt;-</code></td><td>the left-arrow symbol (which is a <a href="engine//book/vnext/appendix/operators.html#symbols">reserved symbol</a> in Rhai).</td></tr>
<tr><td align="center">4</td><td align="center">2</td><td align="center"><code>$expr$</code></td><td>an expression, which may be enclosed with <code>{</code> .. <code>}</code>, or not.</td></tr>
<tr><td align="center">5</td><td align="center"></td><td align="center"><code>:</code></td><td>the colon symbol</td></tr>
<tr><td align="center">6</td><td align="center">3</td><td align="center"><code>$block$</code></td><td>a statement block, which must be enclosed with <code>{</code> .. <code>}</code>.</td></tr>
</tbody></table>
<p>This syntax matches the following sample code and generates three inputs (one for each non-keyword):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming the 'exec' custom syntax implementation declares the variable 'hello':
let x = exec hello &lt;- foo(1, 2) : {
            hello += bar(hello);
            baz(hello);
        };

print(x);       // variable 'x'  has a value returned by the custom syntax

print(hello);   // variable declared by a custom syntax persists!
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#step-two--implementation" id="step-two--implementation">Step Two – Implementation</a></h2>
<p>Any custom syntax must include an <em>implementation</em> of it.</p>
<h3><a class="header" href="#function-signature-2" id="function-signature-2">Function Signature</a></h3>
<p>The function signature of an implementation is:</p>
<blockquote>
<p><code>Fn(context: &amp;mut EvalContext, inputs: &amp;[Expression]) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th>Parameter</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>context</code></td><td align="center"><code>&amp;mut EvalContext</code></td><td>mutable reference to the current evaluation <em>context</em></td></tr>
<tr><td>• <code>scope()</code></td><td align="center"><code>&amp;Scope</code></td><td>reference to the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a></td></tr>
<tr><td>• <code>scope_mut()</code></td><td align="center"><code>&amp;mut &amp;mut Scope</code></td><td>mutable reference to the current <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a>; variables can be added to/removed from it</td></tr>
<tr><td>• <code>engine()</code></td><td align="center"><code>&amp;Engine</code></td><td>reference to the current <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a></td></tr>
<tr><td>• <code>source()</code></td><td align="center"><code>Option&lt;&amp;str&gt;</code></td><td>reference to the current source, if any</td></tr>
<tr><td>• <code>iter_imports()</code></td><td align="center"><code>impl Iterator&lt;Item = (&amp;str, &amp;Module)&gt;</code></td><td>iterator of the current stack of <a href="engine//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements</td></tr>
<tr><td>• <code>imports()</code></td><td align="center"><code>&amp;Imports</code></td><td>reference to the current stack of <a href="engine//book/vnext/rust/modules/index.html">modules</a> imported via <code>import</code> statements; requires the <a href="engine//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td>• <code>iter_namespaces()</code></td><td align="center"><code>impl Iterator&lt;Item = &amp;Module&gt;</code></td><td>iterator of the namespaces (as <a href="engine//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions</td></tr>
<tr><td>• <code>namespaces()</code></td><td align="center"><code>&amp;[&amp;Module]</code></td><td>reference to the namespaces (as <a href="engine//book/vnext/rust/modules/index.html">modules</a>) containing all script-defined functions; requires the <a href="engine//book/vnext/start/features.html"><code>internals</code></a> feature</td></tr>
<tr><td>• <code>this_ptr()</code></td><td align="center"><code>Option&lt;&amp;Dynamic&gt;</code></td><td>reference to the current bound [<code>this</code>] pointer, if any</td></tr>
<tr><td>• <code>call_level()</code></td><td align="center"><code>usize</code></td><td>the current nesting level of function calls</td></tr>
<tr><td><code>inputs</code></td><td align="center"><code>&amp;[Expression]</code></td><td>a list of input expression trees</td></tr>
</tbody></table>
<h3><a class="header" href="#return-value-2" id="return-value-2">Return Value</a></h3>
<p>Return value is the result of evaluating the custom syntax expression.</p>
<h3><a class="header" href="#access-arguments" id="access-arguments">Access Arguments</a></h3>
<p>The most important argument is <code>inputs</code> where the matched identifiers (<code>$ident$</code>), expressions/statements (<code>$expr$</code>)
and statement blocks (<code>$block$</code>) are provided.</p>
<p>To access a particular argument, use the following patterns:</p>
<table><thead><tr><th align="center">Argument type</th><th>Pattern (<code>n</code> = slot in <code>inputs</code>)</th><th align="center">Result type</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><code>$ident$</code></td><td><code>inputs[n].get_variable_name().unwrap()</code></td><td align="center"><code>&amp;str</code></td><td>name of a variable</td></tr>
<tr><td align="center"><code>$expr$</code></td><td><code>inputs.get(n).unwrap()</code></td><td align="center"><code>Expression</code></td><td>an expression tree</td></tr>
<tr><td align="center"><code>$block$</code></td><td><code>inputs.get(n).unwrap()</code></td><td align="center"><code>Expression</code></td><td>an expression tree</td></tr>
</tbody></table>
<h3><a class="header" href="#evaluate-an-expression-tree" id="evaluate-an-expression-tree">Evaluate an Expression Tree</a></h3>
<p>Use the <code>EvalContext::eval_expression_tree</code> method to evaluate an arbitrary expression tree
within the current evaluation context.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expression = inputs.get(0).unwrap();
let result = context.eval_expression_tree(expression)?;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#declare-variables" id="declare-variables">Declare Variables</a></h3>
<p>New variables maybe declared (usually with a variable name that is passed in via `$ident$).</p>
<p>It can simply be pushed into the <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a>.</p>
<p>However, beware that all new variables must be declared <em>prior</em> to evaluating any expression tree.
In other words, any <a href="engine//book/vnext/engine/scope.html"><code>Scope</code></a> calls that change the list of must come <em>before</em> any
<code>EvalContext::eval_expression_tree</code> calls.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let var_name = inputs[0].get_variable_name().unwrap();
let expression = inputs.get(1).unwrap();

context.scope_mut().push(var_name, 0 as INT);   // do this BEFORE 'context.eval_expression_tree'!

let result = context.eval_expression_tree(expression)?;
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#step-three--register-the-custom-syntax" id="step-three--register-the-custom-syntax">Step Three – Register the Custom Syntax</a></h2>
<p>Use <code>Engine::register_custom_syntax</code> to register a custom syntax.</p>
<p>Again, beware that the <em>first</em> symbol must be unique.  If there already exists a custom syntax starting
with that symbol, the previous syntax will be overwritten.</p>
<p>The syntax is passed simply as a slice of <code>&amp;str</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom syntax implementation
fn implementation_func(
    context: &amp;mut EvalContext,
    inputs: &amp;[Expression]
) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt; {
    let var_name = inputs[0].get_variable_name().unwrap().to_string();
    let stmt = inputs.get(1).unwrap();
    let condition = inputs.get(2).unwrap();

    // Push one new variable into the scope BEFORE 'context.eval_expression_tree'
    context.scope_mut().push(var_name, 0 as INT);

    loop {
        // Evaluate the statement block
        context.eval_expression_tree(stmt)?;

        // Evaluate the condition expression
        let stop = !context.eval_expression_tree(condition)?
                            .as_bool().map_err(|err| Box::new(
                                EvalAltResult::ErrorMismatchDataType(
                                    &quot;bool&quot;.to_string(),
                                    err.to_string(),
                                    condition.position(),
                                )
                            ))?;

        if stop {
            break;
        }
    }

    Ok(Dynamic::UNIT)
}

// Register the custom syntax (sample): exec |x| -&gt; { x += 1 } while x &lt; 0
engine.register_custom_syntax(
    &amp;[ &quot;exec&quot;, &quot;|&quot;, &quot;$ident$&quot;, &quot;|&quot;, &quot;-&gt;&quot;, &quot;$block$&quot;, &quot;while&quot;, &quot;$expr$&quot; ], // the custom syntax
    1,  // the number of new variables declared within this custom syntax
    implementation_func
)?;
<span class="boring">}
</span></code></pre></pre>
<p>Remember that a custom syntax acts as an <em>expression</em>, so it can show up practically anywhere:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use as an expression:
let foo = (exec |x| -&gt; { x += 1 } while x &lt; 0) * 100;

// Use as a function call argument:
do_something(exec |x| -&gt; { x += 1 } while x &lt; 0, 24, true);

// Use as a statement:
exec |x| -&gt; { x += 1 } while x &lt; 0;
//                                ^ terminate statement with ';'
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#step-four--disable-unneeded-statement-types" id="step-four--disable-unneeded-statement-types">Step Four – Disable Unneeded Statement Types</a></h2>
<p>When a DSL needs a custom syntax, most likely than not it is extremely specialized.
Therefore, many statement types actually may not make sense under the same usage scenario.</p>
<p>So, while at it, better <a href="engine//book/vnext/engine/disable.html">disable</a> those built-in keywords
and operators that should not be used by the user.  The would leave only the bare minimum
language surface exposed, together with the custom syntax that is tailor-designed for
the scenario.</p>
<p>A keyword or operator that is disabled can still be used in a custom syntax.</p>
<p>In an extreme case, it is possible to disable <em>every</em> keyword in the language, leaving only
custom syntax (plus possibly expressions).  But again, Don’t Do It™ – unless you are certain
of what you’re doing.</p>
<h2><a class="header" href="#step-five--document" id="step-five--document">Step Five – Document</a></h2>
<p>For custom syntax, documentation is crucial.</p>
<p>Make sure there are <em>lots</em> of examples for users to follow.</p>
<h2><a class="header" href="#step-six--profit" id="step-six--profit">Step Six – Profit!</a></h2>
<h2><a class="header" href="#really-advanced--custom-parsers" id="really-advanced--custom-parsers">Really Advanced – Custom Parsers</a></h2>
<p>Sometimes it is desirable to have multiple custom syntax starting with the
same symbol.  This is especially common for <em>command-style</em> syntax where the
second symbol calls a particular command:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following simulates a command-style syntax, all starting with 'perform'.
perform hello world;        // A fixed sequence of symbols
perform action 42;          // Perform a system action with a parameter
perform update system;      // Update the system
perform check all;          // Check all system settings
perform cleanup;            // Clean up the system
perform add something;      // Add something to the system
perform remove something;   // Delete something from the system
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, a custom syntax may have variable length, with a termination symbol:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following is a variable-length list terminated by '&gt;'  
tags &lt; &quot;foo&quot;, &quot;bar&quot;, 123, ... , x+y, true &gt;
<span class="boring">}
</span></code></pre></pre>
<p>For even more flexibility in order to handle these advanced use cases, there is a
<em>low level</em> API for custom syntax that allows the registration of an entire mini-parser.</p>
<p>Use <code>Engine::register_custom_syntax_raw</code> to register a custom syntax <em>parser</em>
together with the implementation function.</p>
<h3><a class="header" href="#how-custom-parsers-work" id="how-custom-parsers-work">How Custom Parsers Work</a></h3>
<p>A custom parser takes as input parameters two pieces of information:</p>
<ul>
<li>
<p>The symbols parsed so far; <code>$ident$</code> is replaced with the actual identifier parsed,
while <code>$expr$</code> and <code>$block$</code> stay as they were.</p>
<p>The custom parser can inspect this symbols stream to determine the next symbol to parse.</p>
</li>
<li>
<p>The <em>look-ahead</em> symbol, which is the symbol that will be parsed <em>next</em>.</p>
<p>If the look-ahead is an expected symbol, the customer parser just returns it to continue parsing,
or it can return <code>$ident$</code> to parse it as an identifier, or even <code>$expr$</code> to start parsing
an expression.</p>
<p>If the look-ahead is ‘<code>{</code>‘, then the custom parser may also return <code>$block$</code> to start parsing a
statements block.</p>
<p>If the look-ahead is unexpected, the custom parser should then return the symbol expected
and Rhai will fail with a parse error containing information about the expected symbol.</p>
</li>
</ul>
<p>A custom parser always returns the <em>next</em> symbol expected, which can also be <code>$ident$</code>,
<code>$expr$</code> or <code>$block$</code>, or <code>None</code> if parsing should terminate (<em>without</em> reading the
look-ahead symbol).</p>
<h3><a class="header" href="#example-6" id="example-6">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>engine.register_custom_syntax_raw(
    &quot;perform&quot;,
    // The custom parser implementation - always returns the next symbol expected
    // 'look_ahead' is the next symbol about to be read
    |symbols, look_ahead| match symbols.len() {
        // perform ...
        1 =&gt; Ok(Some(&quot;$ident$&quot;.to_string())),
        // perform command ...
        2 =&gt; match symbols[1].as_str() {
            &quot;action&quot; =&gt; Ok(Some(&quot;$expr$&quot;.into())),
            &quot;hello&quot; =&gt; Ok(Some(&quot;world&quot;.into())),
            &quot;update&quot; | &quot;check&quot; | &quot;add&quot; | &quot;remove&quot; =&gt; Ok(Some(&quot;$ident$&quot;.into())),
            &quot;cleanup&quot; =&gt; Ok(None),
            cmd =&gt; Err(ParseError(Box::new(ParseErrorType::BadInput(
                LexError::ImproperSymbol(format!(&quot;Improper command: {}&quot;, cmd))
            )), Position::NONE)),
        },
        // perform command arg ...
        3 =&gt; match (symbols[1].as_str(), symbols[2].as_str()) {
            (&quot;action&quot;, _) =&gt; Ok(None),
            (&quot;hello&quot;, &quot;world&quot;) =&gt; Ok(None),
            (&quot;update&quot;, arg) if arg == &quot;system&quot; =&gt; Ok(None),
            (&quot;update&quot;, arg) if arg == &quot;client&quot; =&gt; Ok(None),
            (&quot;check&quot;, arg) =&gt; Ok(None),
            (&quot;add&quot;, arg) =&gt; Ok(None),
            (&quot;remove&quot;, arg) =&gt; Ok(None),
            (cmd, arg) =&gt; Err(ParseError(Box::new(ParseErrorType::BadInput(
                LexError::ImproperSymbol(
                    format!(&quot;Invalid argument for command {}: {}&quot;, cmd, arg)
                )
            )), Position::NONE)),
        },
        _ =&gt; unreachable!(),
    },
    // Number of new variables declared by this custom syntax
    0,
    // Implementation function
    implementation_func
);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#function-signature-3" id="function-signature-3">Function Signature</a></h3>
<p>The custom syntax parser has the following signature:</p>
<blockquote>
<p><code>Fn(symbols: &amp;[ImmutableString], look_ahead: &amp;str) -&gt; Result&lt;Option&lt;ImmutableString&gt;, ParseError&gt;</code></p>
</blockquote>
<p>where:</p>
<table><thead><tr><th>Parameter</th><th align="center">Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>symbols</code></td><td align="center"><code>&amp;[ImmutableString]</code></td><td>a slice of symbols that have been parsed so far, possibly containing <code>$expr$</code> and/or <code>$block$</code>; <code>$ident$</code> is replaced by the actual identifier</td></tr>
<tr><td><code>look_ahead</code></td><td align="center"><code>&amp;str</code></td><td>a string slice containing the next symbol that is about to be read</td></tr>
</tbody></table>
<p>Most strings are <a href="engine//book/vnext/language/strings-chars.html"><code>ImmutableString</code></a>‘s so it is usually more efficient to just <code>clone</code> the appropriate one
(if any matches, or keep an internal cache for commonly-used symbols) as the return value.</p>
<h3><a class="header" href="#return-value-3" id="return-value-3">Return Value</a></h3>
<p>The return value is <code>Result&lt;Option&lt;ImmutableString&gt;, ParseError&gt;</code> where:</p>
<table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td><code>Ok(None)</code></td><td>parsing complete and there are no more symbols to match</td></tr>
<tr><td><code>Ok(Some(symbol))</code></td><td>the next symbol to match, which can also be <code>$expr$</code>, <code>$ident$</code> or <code>$block$</code></td></tr>
<tr><td><code>Err(ParseError)</code></td><td>error that is reflected back to the <a href="engine//book/vnext/engine/hello-world.html"><code>Engine</code></a> – normally <code>ParseError(ParseErrorType::BadInput(LexError::ImproperSymbol(message)), Position::NONE)</code> to indicate that there is a syntax error, but it can be any <code>ParseError</code>.</td></tr>
</tbody></table>
<h1><a class="header" href="#multiple-instantiation" id="multiple-instantiation">Multiple Instantiation</a></h1>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>Rhai’s <a href="patterns//book/vnext/start/features.html">features</a> are not strictly additive.  This is easily deduced from the <a href="patterns//book/vnext/start/features.html"><code>no_std</code></a> feature
which prepares the crate for <code>no-std</code> builds.  Obviously, turning on this feature has a material
impact on how Rhai behaves.</p>
<p>Many crates resolve this by going the opposite direction: build for <code>no-std</code> in default,
but add a <code>std</code> feature, included by default, which builds for the <code>stdlib</code>.</p>
<h2><a class="header" href="#rhai-language-features-are-not-additive" id="rhai-language-features-are-not-additive">Rhai Language Features Are Not Additive</a></h2>
<p>Rhai, however, is more complex.  Language features cannot be easily made <em>additive</em>.</p>
<p>That is because the <em>lack</em> of a language feature is a feature by itself.</p>
<p>For example, by including <a href="patterns//book/vnext/start/features.html"><code>no_float</code></a>, a project sets the Rhai language to ignore floating-point math.
Floating-point numbers do not even parse under this case and will generate syntax errors.
Assume that the project expects this behavior (why? perhaps integers are all that make sense
within the project domain).</p>
<p>Now, assume that a dependent crate also depends on Rhai. Under such circumstances,
unless <em>exact</em> versioning is used and the dependent crate depends on a <em>different</em> version
of Rhai, Cargo automatically <em>merges</em> both dependencies, with the <a href="patterns//book/vnext/start/features.html"><code>no_float</code></a> feature turned on
because Cargo features are <em>additive</em>.</p>
<p>This will break the dependent crate, which does not by itself specify <a href="patterns//book/vnext/start/features.html"><code>no_float</code></a>
and expects floating-point numbers and math to work normally.</p>
<p>There is no way out of this dilemma.  Reversing the <a href="patterns//book/vnext/start/features.html">features</a> set with a <code>float</code> feature
causes the project to break because floating-point numbers are not rejected as expected.</p>
<h2><a class="header" href="#multiple-instantiations-of-rhai-within-the-same-project" id="multiple-instantiations-of-rhai-within-the-same-project">Multiple Instantiations of Rhai Within The Same Project</a></h2>
<p>The trick is to differentiate between multiple identical copies of Rhai, each having
a different <a href="patterns//book/vnext/start/features.html">features</a> set, by their <em>sources</em>:</p>
<ul>
<li>
<p>Different versions from <a href="https://crates.io/crates/rhai/"><code>crates.io</code></a> – The official crate.</p>
</li>
<li>
<p>Different releases from <a href="https://github.com/rhaiscript/rhai"><code>GitHub</code></a> – Crate source on GitHub.</p>
</li>
<li>
<p>Forked copy of <a href="https://github.com/rhaiscript/rhai">https://github.com/rhaiscript/rhai</a> on GitHub.</p>
</li>
<li>
<p>Local copy of <a href="https://github.com/rhaiscript/rhai">https://github.com/rhaiscript/rhai</a> downloaded form GitHub.</p>
</li>
</ul>
<p>Use the following configuration in <code>Cargo.toml</code> to pull in multiple copies of Rhai within the same project:</p>
<pre><code class="language-toml">[dependencies]
rhai = { version = &quot;0.19.11&quot;, features = [ &quot;no_float&quot; ] }
rhai_github = { git = &quot;https://github.com/rhaiscript/rhai&quot;, features = [ &quot;unchecked&quot; ] }
rhai_my_github = { git = &quot;https://github.com/my_github/rhai&quot;, branch = &quot;variation1&quot;, features = [ &quot;serde&quot;, &quot;no_closure&quot; ] }
rhai_local = { path = &quot;../rhai_copy&quot; }
</code></pre>
<p>The example above creates four different modules: <code>rhai</code>, <code>rhai_github</code>, <code>rhai_my_github</code> and
<code>rhai_local</code>, each referring to a different Rhai copy with the appropriate <a href="patterns//book/vnext/start/features.html">features</a> set.</p>
<p>Only one crate of any particular version can be used from each source, because Cargo merges
all candidate cases within the same source, adding all <a href="patterns//book/vnext/start/features.html">features</a> together.</p>
<p>If more than four different instantiations of Rhai is necessary (why?), create more local repositories
or GitHub forks or branches.</p>
<h2><a class="header" href="#caveat--no-way-to-avoid-dependency-conflicts" id="caveat--no-way-to-avoid-dependency-conflicts">Caveat – No Way To Avoid Dependency Conflicts</a></h2>
<p>Unfortunately, pulling in Rhai from different sources do not resolve the problem of
<a href="patterns//book/vnext/start/features.html">features</a> conflict between dependencies.  Even overriding <code>crates.io</code> via the <code>[patch]</code> manifest
section doesn’t work – all dependencies will eventually find the only one copy.</p>
<p>What is necessary – multiple copies of Rhai, one for each dependent crate that requires it,
together with their <em>unique</em> <a href="patterns//book/vnext/start/features.html">features</a> set intact.  In other words, turning off Cargo’s
crate merging feature <em>just for Rhai</em>.</p>
<p>Unfortunately, as of this writing, there is no known method to achieve it.</p>
<p>Therefore, moral of the story: avoid pulling in multiple crates that depend on Rhai.</p>
<h1><a class="header" href="#functions-metadata" id="functions-metadata">Functions Metadata</a></h1>
<p>The <em>metadata</em> of a <a href="engine/metadata//book/vnext/language/functions.html">function</a> means all relevant information related to a function’s
definition including:</p>
<ol>
<li>
<p>Its callable name</p>
</li>
<li>
<p>Its access mode (public or <a href="engine/metadata//book/vnext/engine/call-fn.html">private</a>)</p>
</li>
<li>
<p>Its parameters and types (if any)</p>
</li>
<li>
<p>Its return value and type (if any)</p>
</li>
<li>
<p>Its nature (i.e. native Rust-based or Rhai script-based)</p>
</li>
<li>
<p>Its <a href="engine/metadata//book/vnext/language/fn-namespaces.html">namespace</a> (module or global)</p>
</li>
<li>
<p>Its purpose, in the form of <a href="engine/metadata//book/vnext/language/doc-comments.html">doc-comments</a></p>
</li>
<li>
<p>Usage notes, warnings, etc., in the form of <a href="engine/metadata//book/vnext/language/doc-comments.html">doc-comments</a></p>
</li>
</ol>
<p>A function’s <em>signature</em> encapsulates the first four pieces of information in a single
concise line of definition:</p>
<blockquote>
<p><code>[private] fn_name ( param_1: type_1, param_2: type_2, ... , param_n : type_n ) -&gt; return_type</code></p>
</blockquote>
<h1><a class="header" href="#generate-function-signatures" id="generate-function-signatures">Generate Function Signatures</a></h1>
<h2><a class="header" href="#enginegen_fn_signatures" id="enginegen_fn_signatures"><code>Engine::gen_fn_signatures</code></a></h2>
<p>As part of a <em>reflections</em> API, <code>Engine::gen_fn_signatures</code> returns a list of function <em>signatures</em>
(as <code>Vec&lt;String&gt;</code>), each corresponding to a particular function available to that <a href="engine/metadata//book/vnext/engine/hello-world.html"><code>Engine</code></a> instance.</p>
<blockquote>
<p><code>fn_name ( param_1: type_1, param_2: type_2, ... , param_n : type_n ) -&gt; return_type</code></p>
</blockquote>
<h3><a class="header" href="#sources" id="sources">Sources</a></h3>
<p>Functions from the following sources are included, in order:</p>
<ol>
<li>Native Rust functions registered into the global namespace via the <code>Engine::register_XXX</code> API</li>
<li><em>Public</em> (i.e. non-<a href="engine/metadata//book/vnext/engine/call-fn.html"><code>private</code></a>) functions (native Rust or Rhai scripted) in global sub-modules
registered via <code>Engine::register_static_module</code>.</li>
<li>Native Rust functions in global modules registered via <code>Engine::register_global_module</code> (optional)</li>
</ol>
<h2><a class="header" href="#functions-metadata-1" id="functions-metadata-1">Functions Metadata</a></h2>
<p>Beware, however, that not all function signatures contain parameters and return value information.</p>
<h3><a class="header" href="#engineregister_xxx" id="engineregister_xxx"><code>Engine::register_XXX</code></a></h3>
<p>For instance, functions registered via <code>Engine::register_XXX</code> contain no information on
the names of parameter and their actual types because Rust simply does not make such metadata
available natively. The return type is also undetermined.</p>
<p>A function registered under the name <code>foo</code> with three parameters and unknown return type:</p>
<blockquote>
<p><code>foo(_, _, _)</code></p>
</blockquote>
<p>An operator function – again, unknown parameters and return type.
Notice that function names do not need to be valid identifiers.</p>
<blockquote>
<p><code>+(_, _)</code></p>
</blockquote>
<p>A <a href="engine/metadata//book/vnext/rust/getters-setters.html">property setter</a> – again, unknown parameters and return type.
Notice that function names do not need to be valid identifiers.
In this case, the first parameter should be <code>&amp;mut T</code> of the custom type and the return value is <code>()</code>:</p>
<blockquote>
<p><code>set$prop(_, _, _)</code></p>
</blockquote>
<h3><a class="header" href="#script-defined-functions" id="script-defined-functions">Script-Defined Functions</a></h3>
<p>Script-defined <a href="engine/metadata//book/vnext/language/functions.html">function</a> signatures contain parameter names. Since all parameters, as well as
the return value, are <a href="engine/metadata//book/vnext/language/dynamic.html"><code>Dynamic</code></a> the types are simply not shown.</p>
<p>A script-defined function always takes dynamic arguments, and the return type is also dynamic,
so no type information is needed:</p>
<blockquote>
<p><code>foo(x, y, z)</code></p>
</blockquote>
<p>probably defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x, y, z) {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>is the same as:</p>
<blockquote>
<p><code>foo(x: Dynamic, y: Dynamic, z: Dynamic) -&gt; Result&lt;Dynamic, Box&lt;EvalAltResult&gt;&gt;</code></p>
</blockquote>
<h3><a class="header" href="#plugin-functions" id="plugin-functions">Plugin Functions</a></h3>
<p>Functions defined in <a href="engine/metadata//book/vnext/plugins/module.html">plugin modules</a> are the best.  They contain all the metadata
describing the functions.</p>
<p>For example, a plugin function <code>merge</code>:</p>
<blockquote>
<p><code>merge(list: &amp;mut MyStruct&lt;i64&gt;, num: usize, name: &amp;str) -&gt; Option&lt;bool&gt;</code></p>
</blockquote>
<p>Notice that function names do not need to be valid identifiers.</p>
<p>For example, an operator defined as a <a href="engine/metadata//book/vnext/rust/fallible.html">fallible function</a> in a <a href="engine/metadata//book/vnext/plugins/module.html">plugin module</a> via
<code>#[rhai_fn(name=&quot;+=&quot;, return_raw)]</code> returns <code>Result&lt;bool, Box&lt;EvalAltResult&gt;&gt;</code>:</p>
<blockquote>
<p><code>+=(list: &amp;mut MyStruct&lt;i64&gt;, num: usize, name: &amp;str) -&gt; Result&lt;bool, Box&lt;EvalAltResult&gt;&gt;</code></p>
</blockquote>
<p>For example, a <a href="engine/metadata//book/vnext/rust/getters-setters.html">property getter</a> defined in a <a href="engine/metadata//book/vnext/plugins/module.html">plugin module</a>:</p>
<blockquote>
<p><code>get$prop(obj: &amp;mut MyStruct&lt;i64&gt;) -&gt; String</code></p>
</blockquote>
<h1><a class="header" href="#export-functions-metadata-to-json" id="export-functions-metadata-to-json">Export Functions Metadata to JSON</a></h1>
<h2><a class="header" href="#enginegen_fn_metadata_to_jsonbrenginegen_fn_metadata_with_ast_to_json" id="enginegen_fn_metadata_to_jsonbrenginegen_fn_metadata_with_ast_to_json"><code>Engine::gen_fn_metadata_to_json</code><br/><code>Engine::gen_fn_metadata_with_ast_to_json</code></a></h2>
<p>As part of a <em>reflections</em> API, <code>Engine::gen_fn_metadata_to_json</code> and the corresponding
<code>Engine::gen_fn_metadata_with_ast_to_json</code> export the full list of <a href="engine/metadata//book/vnext/engine/metadata/index.html">functions metadata</a>
in JSON format.</p>
<p>The <a href="engine/metadata//book/vnext/start/features.html"><code>metadata</code></a> feature must be used to turn on this API, which requires
the <a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> crate.</p>
<h3><a class="header" href="#sources-1" id="sources-1">Sources</a></h3>
<p>Functions from the following sources are included:</p>
<ol>
<li>Script-defined functions in an <a href="engine/metadata//book/vnext/engine/compile.html"><code>AST</code></a> (for <code>Engine::gen_fn_metadata_with_ast_to_json</code>)</li>
<li>Native Rust functions registered into the global namespace via the <code>Engine::register_XXX</code> API</li>
<li><em>Public</em> (i.e. non-<a href="engine/metadata//book/vnext/engine/call-fn.html"><code>private</code></a>) functions (native Rust or Rhai scripted) in static modules
registered via <code>Engine::register_static_module</code></li>
<li>Native Rust functions in global modules registered via <code>Engine::register_global_module</code> (optional)</li>
</ol>
<p>Notice that if a function has been <a href="engine/metadata//book/vnext/rust/functions.html#function-overloading">overloaded</a>, only the overriding function’s
metadata is included.</p>
<h2><a class="header" href="#json-schema" id="json-schema">JSON Schema</a></h2>
<p>The JSON schema used to hold functions metadata is very simple, containing a nested structure of
<code>modules</code> and a list of <code>functions</code>.</p>
<h3><a class="header" href="#modules-schema" id="modules-schema">Modules Schema</a></h3>
<pre><code class="language-json">{
  &quot;modules&quot;:
  {
    &quot;sub_module_1&quot;:
    {
      &quot;modules&quot;:
      {
        &quot;sub_sub_module_A&quot;:
        {
          &quot;functions&quot;:
          [
            { ... function metadata ... },
            { ... function metadata ... },
            { ... function metadata ... },
            { ... function metadata ... },
            ...
          ]
        },
        &quot;sub_sub_module_B&quot;:
        {
            ...
        }
      }
    },
    &quot;sub_module_2&quot;:
    {
      ...
    },
    ...
  },
  &quot;functions&quot;:
  [
    { ... function metadata ... },
    { ... function metadata ... },
    { ... function metadata ... },
    { ... function metadata ... },
    ...
  ]
}
</code></pre>
<h3><a class="header" href="#function-metadata-schema" id="function-metadata-schema">Function Metadata Schema</a></h3>
<pre><code class="language-json">{
  &quot;namespace&quot;: &quot;internal&quot; | &quot;global&quot;,
  &quot;access&quot;: &quot;public&quot; | &quot;private&quot;,
  &quot;name&quot;: &quot;fn_name&quot;,
  &quot;type&quot;: &quot;native&quot; | &quot;script&quot;,
  &quot;numParams&quot;: 42,  /* number of parameters */
  &quot;params&quot;:  /* omitted if no parameters */
  [
    { &quot;name&quot;: &quot;param_1&quot;, &quot;type&quot;: &quot;type_1&quot; },
    { &quot;name&quot;: &quot;param_2&quot; },  /* no type info */
    { &quot;name&quot;: &quot;_&quot;, &quot;type&quot;: &quot;type_3&quot; },
    ...
  ],
  &quot;returnType&quot;: &quot;ret_type&quot;,  /* omitted if unknown */
  &quot;signature&quot;: &quot;[private] fn_name(param_1: type_1, param_2, _: type_3) -&gt; ret_type&quot;,
  &quot;docComments&quot;:  /* omitted if none */
  [
    &quot;/// doc-comment line 1&quot;,
    &quot;/// doc-comment line 2&quot;,
    &quot;/** doc-comment block */&quot;,
    ...
  ]
}
</code></pre>
<h1><a class="header" href="#external-tools-1" id="external-tools-1">External Tools</a></h1>
<p>External tools available to work with Rhai.</p>
<h1><a class="header" href="#online-playground-1" id="online-playground-1">Online Playground</a></h1>
<p>The Online Playground runs off a <a href="tools//book/vnext/start/builds/wasm.html">WASM</a> build of Rhai and allows evaluating
Rhai scripts directly within a browser editor window.</p>
<p>Author : <a href="https://github.com/alvinhochun"><code>@alvinhochun</code></a></p>
<p>Repo : <a href="https://github.com/rhaiscript/playground">On GitHub</a></p>
<p>URL : <a href="https://rhai.rs/playground">Link to Online Playground</a></p>
<h1><a class="header" href="#rhai-script-documentation-tool" id="rhai-script-documentation-tool">Rhai Script Documentation Tool</a></h1>
<p>The Rhai Script Documentation Tool, <code>rhai-doc</code>, takes a source directory and scans for
Rhai script files (recursively), building a web-based documentation site for all functions
defined.  Documentation is taken from <a href="http://en.wikipedia.org/wiki/Markdown">MarkDown</a> <a href="tools//book/vnext/language/doc-comments.html">doc-comments</a> on the functions.</p>
<p>Author: <a href="https://github.com/semirix"><code>@semirix</code></a></p>
<p>Repo: <a href="https://github.com/rhaiscript/rhai-doc">On GitHub</a></p>
<p>Binary: <code>rhai-doc</code></p>
<h2><a class="header" href="#flags-and-options" id="flags-and-options">Flags and Options</a></h2>
<table><thead><tr><th align="center">Flag/Option</th><th align="center">Parameter</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><code>-h</code>, <code>--help</code></td><td align="center"></td><td>print help</td></tr>
<tr><td align="center"><code>-V</code>, <code>--version</code></td><td align="center"></td><td>print version</td></tr>
<tr><td align="center"><code>-D</code>, <code>--dest</code></td><td align="center"><em>&lt;directory&gt;</em></td><td>set destination path for documentation output (default <code>./dist</code>)</td></tr>
<tr><td align="center"><code>-d</code>, <code>--dir</code></td><td align="center"><em>&lt;directory&gt;</em></td><td>set source path for Rhai script files (default <code>.</code>)</td></tr>
<tr><td align="center"><code>-p</code>, <code>--pages</code></td><td align="center"><em>&lt;directory&gt;</em></td><td>set source path for additional <a href="http://en.wikipedia.org/wiki/Markdown">MarkDown</a> files to include in documentation (default <code>./pages</code>)</td></tr>
</tbody></table>
<h2><a class="header" href="#rhaitoml" id="rhaitoml"><code>rhai.toml</code></a></h2>
<p>The file <code>rhai.toml</code> contains configuration options for <code>rhai-doc</code> and must be placed in the source directory.</p>
<p>Example:</p>
<pre><code class="language-toml">name = &quot;My Rhai Project&quot;                # project name
colour = [246, 119, 2]                  # theme color
index = &quot;home.md&quot;                       # this file becomes 'index.html`
root = &quot;https://example.com/docs/&quot;      # root URL for generated site
icon = &quot;logo.svg&quot;                       # project icon
extension = &quot;rhai&quot;                      # script extension

[[links]]                               # external link for 'Blog'
name = &quot;Blog&quot;
link = &quot;https://example.com/blog&quot;

[[links]]                               # external link for 'Tools'
name = &quot;Tools&quot;
link = &quot;https://example.com/tools&quot;
</code></pre>
<p>Options for <code>rhai.toml</code>:</p>
<table><thead><tr><th align="center">Option</th><th align="center">Value</th><th>Description</th></tr></thead><tbody>
<tr><td align="center"><code>name</code></td><td align="center">string</td><td>name of project – used as titles on documentation pages</td></tr>
<tr><td align="center"><code>colour</code></td><td align="center">RGB value string</td><td>theme color for generated documentation</td></tr>
<tr><td align="center"><code>index</code></td><td align="center">file name</td><td>main MarkDown file – becomes <code>index.html</code></td></tr>
<tr><td align="center"><code>root</code></td><td align="center">URL string</td><td>root URL generated as part of documentation</td></tr>
<tr><td align="center"><code>icon</code></td><td align="center">file path</td><td>project icon</td></tr>
<tr><td align="center"><code>extension</code></td><td align="center">extension string</td><td>script file extension (default <code>rhai</code>)</td></tr>
<tr><td align="center"><code>[[links]]</code></td><td align="center">table</td><td>external links</td></tr>
<tr><td align="center"><code>links.name</code></td><td align="center">string</td><td>• title of external link</td></tr>
<tr><td align="center"><code>links.link</code></td><td align="center">URL string</td><td>• URL of external link</td></tr>
</tbody></table>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>This section contains miscellaneous reference materials.</p>
<h1><a class="header" href="#keywords-list" id="keywords-list">Keywords List</a></h1>
<table><thead><tr><th align="center">Keyword</th><th>Description</th><th align="center">Inactive under</th><th align="center">Is function?</th><th align="center">Overloadable</th></tr></thead><tbody>
<tr><td align="center"><code>true</code></td><td>boolean true literal</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>false</code></td><td>boolean false literal</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>let</code></td><td>variable declaration</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>const</code></td><td>constant declaration</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>if</code></td><td>if statement</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>else</code></td><td>else block of if statement</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>switch</code></td><td>matching</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>do</code></td><td>looping</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>while</code></td><td>1) while loop<br/>2) condition for do loop</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>until</code></td><td>do loop</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>loop</code></td><td>infinite loop</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>for</code></td><td>for loop</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>in</code></td><td>1) containment test<br/>2) part of for loop</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>continue</code></td><td>continue a loop at the next iteration</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>break</code></td><td>break out of loop iteration</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>return</code></td><td>return value</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>throw</code></td><td>throw exception</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>try</code></td><td>trap exception</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>catch</code></td><td>catch exception</td><td align="center"></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>import</code></td><td>import module</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_module</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>export</code></td><td>export variable</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_module</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>as</code></td><td>alias for variable export</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_module</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>private</code></td><td>mark function private</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_function</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>fn</code> (lower-case <code>f</code>)</td><td>function definition</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_function</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>Fn</code> (capital <code>F</code>)</td><td>create a <a href="appendix//book/vnext/language/fn-ptr.html">function pointer</a></td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center"><code>call</code></td><td>call a <a href="appendix//book/vnext/language/fn-ptr.html">function pointer</a></td><td align="center"></td><td align="center">yes</td><td align="center">no</td></tr>
<tr><td align="center"><code>curry</code></td><td>curry a <a href="appendix//book/vnext/language/fn-ptr.html">function pointer</a></td><td align="center"></td><td align="center">yes</td><td align="center">no</td></tr>
<tr><td align="center"><code>this</code></td><td>reference to base object for method call</td><td align="center"><a href="appendix//book/vnext/start/features.html"><code>no_function</code></a></td><td align="center">no</td><td align="center"></td></tr>
<tr><td align="center"><code>type_of</code></td><td>get type name of value</td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center"><code>print</code></td><td>print value</td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center"><code>debug</code></td><td>print value in debug format</td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
<tr><td align="center"><code>eval</code></td><td>evaluate script</td><td align="center"></td><td align="center">yes</td><td align="center">yes</td></tr>
</tbody></table>
<h2><a class="header" href="#reserved-keywords" id="reserved-keywords">Reserved Keywords</a></h2>
<table><thead><tr><th>Keyword</th><th>Potential usage</th></tr></thead><tbody>
<tr><td><code>var</code></td><td>variable declaration</td></tr>
<tr><td><code>static</code></td><td>variable declaration</td></tr>
<tr><td><code>begin</code></td><td>block scope</td></tr>
<tr><td><code>end</code></td><td>block scope</td></tr>
<tr><td><code>shared</code></td><td>share value</td></tr>
<tr><td><code>each</code></td><td>looping</td></tr>
<tr><td><code>then</code></td><td>control flow</td></tr>
<tr><td><code>goto</code></td><td>control flow</td></tr>
<tr><td><code>exit</code></td><td>control flow</td></tr>
<tr><td><code>unless</code></td><td>control flow</td></tr>
<tr><td><code>match</code></td><td>matching</td></tr>
<tr><td><code>case</code></td><td>matching</td></tr>
<tr><td><code>public</code></td><td>function/field access</td></tr>
<tr><td><code>new</code></td><td>constructor</td></tr>
<tr><td><code>use</code></td><td>import namespace</td></tr>
<tr><td><code>with</code></td><td>scope</td></tr>
<tr><td><code>module</code></td><td>module</td></tr>
<tr><td><code>package</code></td><td>package</td></tr>
<tr><td><code>thread</code></td><td>threading</td></tr>
<tr><td><code>spawn</code></td><td>threading</td></tr>
<tr><td><code>go</code></td><td>threading</td></tr>
<tr><td><code>await</code></td><td>async</td></tr>
<tr><td><code>async</code></td><td>async</td></tr>
<tr><td><code>sync</code></td><td>async</td></tr>
<tr><td><code>yield</code></td><td>async</td></tr>
<tr><td><code>default</code></td><td>special value</td></tr>
<tr><td><code>void</code></td><td>special value</td></tr>
<tr><td><code>null</code></td><td>special value</td></tr>
<tr><td><code>nil</code></td><td>special value</td></tr>
</tbody></table>
<h1><a class="header" href="#operators-and-symbols" id="operators-and-symbols">Operators and Symbols</a></h1>
<h2><a class="header" href="#operators" id="operators">Operators</a></h2>
<table><thead><tr><th align="center">Operator</th><th>Description</th><th align="center">Binary?</th><th align="center">Binding direction</th></tr></thead><tbody>
<tr><td align="center"><code>+</code></td><td>add</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>-</code></td><td>1) subtract<br/>2) negative (prefix)</td><td align="center">yes<br/>no</td><td align="center">left<br/>right</td></tr>
<tr><td align="center"><code>*</code></td><td>multiply</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>/</code></td><td>divide</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>%</code></td><td>modulo</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>~</code></td><td>power</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&gt;&gt;</code></td><td>right bit-shift</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&lt;&lt;</code></td><td>left bit-shift</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&amp;</code></td><td>1) bit-wise <em>AND</em><br/>2) boolean <em>AND</em></td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>|</code></td><td>1) bit-wise <em>OR</em><br/>2) boolean <em>OR</em></td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>^</code></td><td>1) bit-wise <em>XOR</em><br/>2) boolean <em>XOR</em></td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>,<br/><code>~=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>,<br/><code>|=</code>, <code>^=</code></td><td>assignments</td><td align="center">yes</td><td align="center">right</td></tr>
<tr><td align="center"><code>==</code></td><td>equals to</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>~=</code></td><td>not equals to</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&gt;</code></td><td>greater than</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&gt;=</code></td><td>greater than or equals to</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&lt;</code></td><td>less than</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&lt;=</code></td><td>less than or equals to</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>&amp;&amp;</code></td><td>boolean <em>AND</em> (short-circuits)</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>||</code></td><td>boolean <em>OR</em> (short-circuits)</td><td align="center">yes</td><td align="center">left</td></tr>
<tr><td align="center"><code>!</code></td><td>boolean <em>NOT</em></td><td align="center">no</td><td align="center">left</td></tr>
<tr><td align="center"><code>[</code> .. <code>]</code></td><td>indexing</td><td align="center">yes</td><td align="center">right</td></tr>
<tr><td align="center"><code>.</code></td><td>1) property access<br/>2) method call</td><td align="center">yes</td><td align="center">right</td></tr>
</tbody></table>
<h2><a class="header" href="#symbols-and-patterns" id="symbols-and-patterns">Symbols and Patterns</a></h2>
<table><thead><tr><th>Symbol</th><th align="center">Name</th><th>Description</th></tr></thead><tbody>
<tr><td><code>_</code></td><td align="center">underscore</td><td>default <code>switch</code> case</td></tr>
<tr><td><code>;</code></td><td align="center">semicolon</td><td>statement separator</td></tr>
<tr><td><code>,</code></td><td align="center">comma</td><td>list separator</td></tr>
<tr><td><code>:</code></td><td align="center">colon</td><td><a href="appendix//book/vnext/language/object-maps.html">object map</a> property value separator</td></tr>
<tr><td><code>::</code></td><td align="center">path</td><td>module path separator</td></tr>
<tr><td><code>#{</code> .. <code>}</code></td><td align="center">hash map</td><td><a href="appendix//book/vnext/language/object-maps.html">object map</a> literal</td></tr>
<tr><td><code>&quot;</code> .. <code>&quot;</code></td><td align="center">double quote</td><td><a href="appendix//book/vnext/language/strings-chars.html">string</a></td></tr>
<tr><td><code>'</code> .. <code>'</code></td><td align="center">single quote</td><td><a href="appendix//book/vnext/language/strings-chars.html">character</a></td></tr>
<tr><td><code>\</code></td><td align="center">escape</td><td>escape character literal</td></tr>
<tr><td><code>(</code> .. <code>)</code></td><td align="center">parentheses</td><td>expression grouping</td></tr>
<tr><td><code>{</code> .. <code>}</code></td><td align="center">braces</td><td>block statement</td></tr>
<tr><td><code>|</code> .. <code>|</code></td><td align="center">pipes</td><td>closure</td></tr>
<tr><td><code>[</code> .. <code>]</code></td><td align="center">brackets</td><td><a href="appendix//book/vnext/language/arrays.html">array</a> literal</td></tr>
<tr><td><code>!</code></td><td align="center">bang</td><td>function call in calling scope</td></tr>
<tr><td><code>=&gt;</code></td><td align="center">double arrow</td><td><code>switch</code> expression case separator</td></tr>
<tr><td><code>//</code></td><td align="center">comment</td><td>line comment</td></tr>
<tr><td><code>/*</code> .. <code>*/</code></td><td align="center">comment</td><td>block comment</td></tr>
<tr><td><code>(*</code> .. <code>*)</code></td><td align="center">comment</td><td><em>reserved</em></td></tr>
<tr><td><code>&lt;</code> .. <code>&gt;</code></td><td align="center">angular brackets</td><td><em>reserved</em></td></tr>
<tr><td><code>++</code></td><td align="center">increment</td><td><em>reserved</em></td></tr>
<tr><td><code>--</code></td><td align="center">decrement</td><td><em>reserved</em></td></tr>
<tr><td><code>..</code></td><td align="center">range</td><td><em>reserved</em></td></tr>
<tr><td><code>...</code></td><td align="center">range</td><td><em>reserved</em></td></tr>
<tr><td><code>**</code></td><td align="center">exponentiation</td><td><em>reserved</em></td></tr>
<tr><td><code>#</code></td><td align="center">hash</td><td><em>reserved</em></td></tr>
<tr><td><code>@</code></td><td align="center">at</td><td><em>reserved</em></td></tr>
<tr><td><code>$</code></td><td align="center">dollar</td><td><em>reserved</em></td></tr>
<tr><td><code>-&gt;</code></td><td align="center">arrow</td><td><em>reserved</em></td></tr>
<tr><td><code>&lt;-</code></td><td align="center">left arrow</td><td><em>reserved</em></td></tr>
<tr><td><code>===</code></td><td align="center">strict equals to</td><td><em>reserved</em></td></tr>
<tr><td><code>!==</code></td><td align="center">strict not equals to</td><td><em>reserved</em></td></tr>
<tr><td><code>:=</code></td><td align="center">assignment</td><td><em>reserved</em></td></tr>
<tr><td><code>::&lt;</code> .. <code>&gt;</code></td><td align="center">turbofish</td><td><em>reserved</em></td></tr>
</tbody></table>
<h1><a class="header" href="#literals-syntax" id="literals-syntax">Literals Syntax</a></h1>
<table><thead><tr><th align="center">Type</th><th align="center">Literal syntax</th></tr></thead><tbody>
<tr><td align="center"><code>INT</code></td><td align="center">decimal: <code>42</code>, <code>-123</code>, <code>0</code><br/>hex: <code>0x????..</code><br/>binary: <code>0b????..</code><br/>octal: <code>0o????..</code></td></tr>
<tr><td align="center"><code>FLOAT</code></td><td align="center"><code>42.0</code>, <code>-123.456</code>, <code>0.0</code></td></tr>
<tr><td align="center"><a href="appendix//book/vnext/language/strings-chars.html">String</a></td><td align="center"><code>&quot;... \x?? \u???? \U???????? ...&quot;</code></td></tr>
<tr><td align="center"><a href="appendix//book/vnext/language/strings-chars.html">Character</a></td><td align="center">single: <code>'?'</code><br/>ASCII hex: <code>'\x??'</code><br/>Unicode: <code>'\u????'</code>, <code>'\U????????'</code></td></tr>
<tr><td align="center"><a href="appendix//book/vnext/language/arrays.html"><code>Array</code></a></td><td align="center"><code>[ ???, ???, ??? ]</code></td></tr>
<tr><td align="center"><a href="appendix//book/vnext/language/object-maps.html">Object map</a></td><td align="center"><code>#{ a: ???, b: ???, c: ???, &quot;def&quot;: ??? }</code></td></tr>
<tr><td align="center">Boolean true</td><td align="center"><code>true</code></td></tr>
<tr><td align="center">Boolean false</td><td align="center"><code>false</code></td></tr>
<tr><td align="center"><code>Nothing</code>/<code>null</code>/<code>nil</code>/<code>void</code>/Unit</td><td align="center"><code>()</code></td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
